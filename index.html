<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CO₂ EOR Economic Model</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 4px; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Load React -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  
  <!-- Load PropTypes -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  
  <!-- Load Recharts from cdnjs -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.7/Recharts.min.js"></script>
  
  <!-- Load Babel -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect, useRef } = React;
    const { BarChart, Bar, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine, AreaChart, Area, PieChart, Pie, Cell } = Recharts;




// Pattern type configurations - defined outside component to prevent re-render loops
// Simplified to only patterns appropriate for each EOR method
const PATTERN_TYPES = {
  '5-spot': { inj: 1, prod: 4, name: '5-Spot', desc: '1 injector center, 4 producers at corners', acresPerPattern: 1.0 },
  'inv-5-spot': { inj: 4, prod: 1, name: 'Inverted 5-Spot', desc: '4 injectors at corners, 1 producer center', acresPerPattern: 1.0 },
  'single-well': { inj: 1, prod: 0, name: 'Single Well (H&P)', desc: 'Same well injects and produces cyclically', acresPerPattern: 0.25 },
};

// EOR Method configurations with defaults
const EOR_METHOD_CONFIG = {
  continuous: {
    name: 'Continuous CO₂',
    pattern: '5-spot',
    defaultInjRate: 30000, // t/well/yr - single injector takes all CO₂
    desc: 'Continuous CO₂ injection with dedicated injector wells'
  },
  wag: {
    name: 'WAG (Water-Alternating-Gas)',
    pattern: '5-spot',
    defaultInjRate: 25000, // t/well/yr - slightly lower than continuous due to water phases
    desc: 'Alternating water and CO₂ slugs for better sweep efficiency'
  },
  huffpuff: {
    name: 'Huff & Puff (Cyclic)',
    pattern: 'single-well',
    defaultInjRate: 20000, // t/well/yr - lower than flood; ~500-2000t per cycle over multiple cycles/year
    desc: 'Single-well cyclic: inject, soak, produce from same well'
  }
};

const EORModelApp = () => {
  const [activeTab, setActiveTab] = useState('inputs');
  const [scenarioType, setScenarioType] = useState('New'); // 'Existing' or 'New'
  const [modelMode, setModelMode] = useState('pattern'); // 'simple' or 'pattern'
  const [tornadoHover, setTornadoHover] = useState(null); // Hover state for tornado chart

  // ============ EOR METHOD & PATTERN TYPE ============
  // EOR injection method: continuous, WAG (water-alternating-gas), or huff-and-puff (cyclic)
  const [eorMethod, setEorMethod] = useState('continuous'); // 'continuous', 'wag', 'huffpuff'
  
  // WAG parameters (when eorMethod === 'wag')
  const [wagRatio, setWagRatio] = useState(1); // water:gas ratio (1 = 1:1, 2 = 2:1 water:gas)
  const [wagCycleMonths, setWagCycleMonths] = useState(3); // months per half-cycle (CO₂ or water phase)
  
  // Huff-and-Puff parameters (when eorMethod === 'huffpuff')
  const [hpInjectionDays, setHpInjectionDays] = useState(14); // days of CO₂ injection per cycle (typical: 1-4 weeks)
  const [hpSoakDays, setHpSoakDays] = useState(14); // days of soak period (typical: 1-4 weeks)
  const [hpProductionDays, setHpProductionDays] = useState(120); // days of production per cycle (typical: 2-6 months)
  const [hpCycles, setHpCycles] = useState(4); // number of H&P cycles (typically 3-6 optimal)
  
  // Pattern type: different well configurations
  const [patternType, setPatternType] = useState('5-spot'); // '5-spot', 'inv-5-spot', 'single-well'

  // ============ PATTERN-BASED MODE INPUTS ============
  // Facility & Field
  const [facilitySize, setFacilitySize] = useState(100000); // t CO₂/yr capture capacity
  const [fieldSize, setFieldSize] = useState(640); // acres (1 section = 640 acres)
  const [wellSpacing, setWellSpacing] = useState(40); // acres per 5-spot pattern (literature: 20-80)
  const [fieldShapeFactor, setFieldShapeFactor] = useState(0.85); // efficiency loss from irregular boundaries
  const [injRatePerWell, setInjRatePerWell] = useState(30000); // t CO₂/well/yr (your field data)
  
  // Pattern Lifecycle
  const [patternFillYears, setPatternFillYears] = useState(1); // years for CO₂ bank to develop
  const [patternRampYears, setPatternRampYears] = useState(2); // years to reach peak production
  const [patternPeakYears, setPatternPeakYears] = useState(4); // years at peak before decline
  const [patternDeclineRate, setPatternDeclineRate] = useState(12); // %/yr decline after peak
  const [patternAbandonmentPct, setPatternAbandonmentPct] = useState(20); // % of peak when pattern abandoned
  
  // Existing Flood - Pattern Maturity
  const [pctDeveloped, setPctDeveloped] = useState(50); // % of max patterns already active
  const [avgPatternAge, setAvgPatternAge] = useState(5); // average age of existing patterns (years)
  
  // Pattern activation threshold - activate new pattern when spare capacity exceeds this
  const [activationThreshold, setActivationThreshold] = useState(20000); // t CO₂/yr spare capacity to trigger new pattern

  // Fixed project life - override simulated duration
  const [useFixedProjectLife, setUseFixedProjectLife] = useState(false);
  const [fixedProjectLife, setFixedProjectLife] = useState(20); // years

  // Feeder Pipeline (infield gathering system)
  // Literature: 4-6" flowlines at $50-150k/mile; typical pattern spacing ~660-1320 ft between wells
  const [feederPipePerPattern, setFeederPipePerPattern] = useState(0.5); // miles of feeder pipe per pattern (injector + producers)
  const [feederPipeCostPerMile, setFeederPipeCostPerMile] = useState(100000); // $/mile for small-diameter flowlines
  
  // Existing infrastructure toggle (for New Flood - does recycle plant already exist?)
  const [recycleExists, setRecycleExists] = useState(false); // true = recycle plant already in place (no CAPEX)
  
  // New wells percentage - what portion of wells are new drill vs retrofit
  const [newWellsPct, setNewWellsPct] = useState(0); // 0-100%, default 0 (all retrofit)
  
  // ============ SCHEDULE & RAMP ============
  // Project timeline
  const [eorStartYear, setEorStartYear] = useState(2025); // Year EOR operations begin (backdated for existing)
  const [eorStartMonth, setEorStartMonth] = useState(1); // Month (1-12)
  
  // Construction periods (months) - time before EOR starts
  const [captureConstructionMonths, setCaptureConstructionMonths] = useState(24); // Capture facility construction
  const [recycleConstructionMonths, setRecycleConstructionMonths] = useState(18); // Recycle facility construction
  const [pipelineConstructionMonths, setPipelineConstructionMonths] = useState(12); // Pipeline construction
  
  // Pattern ramp control
  const [usePatternRamp, setUsePatternRamp] = useState(true); // Toggle ramp on/off
  const [patternsPerMonth, setPatternsPerMonth] = useState(1); // How many patterns to activate per month
  const [rampIntervalMonths, setRampIntervalMonths] = useState(1); // Months between pattern activations
  
  // Animation state for development visualization
  const [animationMonth, setAnimationMonth] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);

  // Oil Pricing
  const [wtiPrice, setWtiPrice] = useState(65);
  const [oilDiff, setOilDiff] = useState(5);
  const [discountRate, setDiscountRate] = useState(10);

  // Oil Production
  const [producingYears, setProducingYears] = useState(12);
  const [prodWellCost, setProdWellCost] = useState(0);
  const [prodWellCount, setProdWellCount] = useState(100);
  const [prodPerWellPerYr, setProdPerWellPerYr] = useState(15000);

  // CO2 Injection
  const [injWellCost, setInjWellCost] = useState(0);
  const [injWellCount, setInjWellCount] = useState(62.5);
  const [injPerWellPerYr, setInjPerWellPerYr] = useState(30000);
  
  // Well Costs - depth-based calculation
  // Literature: New wells $150-400/ft depending on complexity; Retrofit $15-50/ft
  // Permian Basin avg depth ~7,000-10,000 ft; Gulf Coast ~8,000-12,000 ft
  const [wellDepth, setWellDepth] = useState(8000); // ft
  const [newWellCostPerFt, setNewWellCostPerFt] = useState(200); // $/ft for drill + complete
  const [retrofitCostPerFt, setRetrofitCostPerFt] = useState(25); // $/ft for workover/recompletion
  
  // Well Retrofit/Conversion: cost to convert existing wells for CO₂ injection service
  // Scope: integrity assessment, squeeze cement, CO₂-resistant tubing, wellhead upgrade, packer, MIT
  // Literature: $150k–$500k/well depending on depth, casing condition, CRA requirements
  // API/SACROC: 4,500+ wells converted; NETL/EPA: retrofit significantly cheaper than new drill ($0.4–2.7MM)
  // Now calculated from depth × $/ft
  const [retrofitCostPerWell, setRetrofitCostPerWell] = useState(0);
  const [retrofitWellCount, setRetrofitWellCount] = useState(0); // wells needing conversion (may differ from injWellCount)

  // CO2 Pricing - unified input instead of multiple cases
  const [co2Price, setCo2Price] = useState(0); // $/tonne - negative = purchasing, 0 = free, positive = receiving credit
  const [recycledCo2Cost, setRecycledCo2Cost] = useState(12.35);

  // Production OPEX
  const [prodOpex, setProdOpex] = useState(10);
  const [oilTransport, setOilTransport] = useState(5);
  // severanceTax is now defined in Tax Parameters section with state config

  // 45Q Credit
  const [creditYears, setCreditYears] = useState(12);
  const [creditTotal, setCreditTotal] = useState(85);
  const [creditEnabled, setCreditEnabled] = useState(true);
  const [creditInflation, setCreditInflation] = useState(true);
  const [creditInflationRate, setCreditInflationRate] = useState(2.5);

  // CO2 Recycle Mode
  const [recycleMode, setRecycleMode] = useState('ramping'); // 'fixed' or 'ramping'
  const [fixedRecycleRate, setFixedRecycleRate] = useState(60); // % for fixed mode

  // Value Chain Scope
  const [fullValueChain, setFullValueChain] = useState(true);
  const [autoCalcCapex, setAutoCalcCapex] = useState(true); // auto-compute capture/transport CAPEX from injection rate
  const [pipelineDistance, setPipelineDistance] = useState(50); // miles for transport CAPEX scaling
  const [co2SourceType, setCo2SourceType] = useState('ngp'); // CO₂ source purity preset
  const [co2Concentration, setCo2Concentration] = useState(96); // vol% CO₂ in source stream
  const [pipelineCostPerInchMile, setPipelineCostPerInchMile] = useState(85000); // $/inch-mile

  // CCUS Costs
  const [captureCapex, setCaptureCapex] = useState(0);
  const [recycleCapex, setRecycleCapex] = useState(0);
  const [storageCapex, setStorageCapex] = useState(0);
  const [transportCapex, setTransportCapex] = useState(6.32);
  const [captureOpex, setCaptureOpex] = useState(0);
  const [recycleOpex, setRecycleOpex] = useState(12.35);
  const [storageOpex, setStorageOpex] = useState(2.7);
  const [transportOpex, setTransportOpex] = useState(1);

  // ============ FINANCING & TAX ============
  // Capital Structure
  const [debtPct, setDebtPct] = useState(60); // % of CAPEX financed with debt
  const [debtInterestRate, setDebtInterestRate] = useState(8); // % annual interest rate
  const [debtTerm, setDebtTerm] = useState(10); // years for loan amortization
  const [costOfEquity, setCostOfEquity] = useState(15); // % required return on equity
  
  // Discount Rate Mode
  const [useHurdleRate, setUseHurdleRate] = useState(true); // true = fixed rate, false = WACC
  const [hurdleRate, setHurdleRate] = useState(10); // % fixed discount rate when useHurdleRate=true
  
  // Tax Parameters
  const [federalTaxRate, setFederalTaxRate] = useState(21); // % federal corporate tax
  const [stateTaxRate, setStateTaxRate] = useState(5); // % state tax (varies by state)
  const [severanceTax, setSeveranceTax] = useState(4.6); // % severance tax on oil production
  const [idcPct, setIdcPct] = useState(70); // % of well CAPEX that is IDC (expensed Year 1)
  const [bonusDepreciation, setBonusDepreciation] = useState(40); // % bonus depreciation (phasing out)
  const [depletionAllowance, setDepletionAllowance] = useState(15); // % of gross oil revenue (small producers)
  const [enableTaxCalc, setEnableTaxCalc] = useState(true); // toggle tax calculations on/off
  
  // State selection for tax configuration
  const [selectedState, setSelectedState] = useState('TX');
  
  // State-specific tax configurations
  // Sources: RRC Texas, LA DNR, ND Tax Commissioner, WY DOR, NM TRD, OK Tax Commission
  const STATE_TAX_CONFIG = {
    TX: {
      name: 'Texas',
      stateTax: 0, // No state income tax
      severance: 4.6, // Standard oil severance
      eorSeverance: 2.3, // EOR incentive: 50% reduction for 10 years
      anthropogenicCO2Bonus: true, // Additional 50% reduction for anthropogenic CO₂ EOR (to 1.15%)
      eorDuration: 10, // Years of EOR incentive
      notes: 'EOR projects: 2.3% (50% reduction). With anthropogenic CO₂: 1.15% (additional 50%) for up to 30 years.'
    },
    LA: {
      name: 'Louisiana',
      stateTax: 8, // Corporate income tax (graduated 3.5-7.5%, using effective ~8% for oil corps)
      severance: 12.5, // Standard rate (legacy wells)
      eorSeverance: 6.5, // New wells after July 2025: 6.5%
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'New wells (post-July 2025): 6.5%. Inactive/orphan well incentives available. Deep wells may qualify for reduced rates.'
    },
    ND: {
      name: 'North Dakota',
      stateTax: 4.31, // Corporate income tax (flat rate)
      severance: 11.5, // Combined: 5% extraction + 6.5% gross production (effective ~10% after triggers)
      eorSeverance: 11.5, // No specific EOR reduction currently
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'No EOR-specific incentive. Triggers reduce rate to 10% when oil < $55-70/bbl or rig count low.'
    },
    WY: {
      name: 'Wyoming',
      stateTax: 0, // No state income tax
      severance: 6, // Oil severance tax
      eorSeverance: 0, // Historic HB54 exemption (expired 2008, revival pending)
      anthropogenicCO2Bonus: true, // Proposed $5/t CO₂ incentive for EOR with 45Q
      adValorem: 6.7, // Property/ad valorem tax on production
      eorDuration: 5, // If HB54-style exemption revived
      notes: 'Severance 6% + ~6.7% ad valorem. Legislators considering EOR incentives ($5/t CO₂ for 45Q projects).'
    },
    NM: {
      name: 'New Mexico',
      stateTax: 5.9, // Corporate income tax (5.9% top rate)
      severance: 6.9, // Effective combined rate (severance + conservation + emergency school)
      eorSeverance: 6.9, // No specific EOR reduction
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'Combined ~6.9% (severance + conservation + emergency school taxes). No EOR-specific incentives.'
    },
    OK: {
      name: 'Oklahoma',
      stateTax: 4, // Corporate income tax (4% flat)
      severance: 5, // Gross production tax on oil (rebate programs may apply)
      eorSeverance: 4, // Reduced rate for qualifying EOR/secondary recovery
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'Standard 5%, reduced rates for secondary/tertiary recovery projects. Rebate programs may reduce effective rate.'
    },
    CO: {
      name: 'Colorado',
      stateTax: 4.4, // Corporate income tax (flat)
      severance: 5, // Severance tax (after deductions, often lower effective)
      eorSeverance: 5,
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'Severance tax with significant deductions possible. No EOR-specific incentives.'
    },
    MS: {
      name: 'Mississippi',
      stateTax: 5, // Corporate income tax (5% over $10k)
      severance: 6, // Oil severance tax
      eorSeverance: 3, // 50% reduction for EOR projects
      anthropogenicCO2Bonus: false,
      eorDuration: 10,
      notes: 'EOR projects qualify for 50% severance tax reduction (3% vs 6%).'
    },
    MT: {
      name: 'Montana',
      stateTax: 6.75, // Corporate income tax
      severance: 9, // Primary recovery (first 12-18 months at lower rate)
      eorSeverance: 5.5, // Tertiary recovery rate
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'Tertiary/EOR production taxed at 5.5% vs 9% for primary. New well exemptions for first 12-18 months.'
    },
    KS: {
      name: 'Kansas',
      stateTax: 7, // Corporate income tax (7% normal + 3% surtax)
      severance: 8, // Oil severance tax
      eorSeverance: 8, // No specific EOR reduction
      anthropogenicCO2Bonus: false,
      eorDuration: 0,
      notes: 'No EOR-specific incentives. Stripper well exemptions may apply.'
    },
    CUSTOM: {
      name: 'Custom',
      stateTax: 5,
      severance: 4.6,
      eorSeverance: 2.3,
      anthropogenicCO2Bonus: false,
      eorDuration: 10,
      notes: 'User-defined values'
    }
  };
  
  // Update tax rates when state changes
  useEffect(() => {
    if (selectedState !== 'CUSTOM') {
      const config = STATE_TAX_CONFIG[selectedState];
      setStateTaxRate(config.stateTax);
      setSeveranceTax(config.severance);
    }
  }, [selectedState]);

  // Auto-update field size to optimal when facility size changes
  // Uses the 2.5x sustainability multiplier for optimal pattern count
  useEffect(() => {
    const injPerPattern = PATTERN_TYPES[patternType]?.inj || 1;
    const patternsNeededForFacility = Math.ceil(facilitySize / (injRatePerWell * injPerPattern));
    const sustainabilityMultiplier = 2.5;
    const optimalPatternCount = Math.ceil(patternsNeededForFacility * sustainabilityMultiplier);
    const effectiveSpacing = wellSpacing * (PATTERN_TYPES[patternType]?.acresPerPattern || 1);
    const optimalFieldSize = Math.ceil((optimalPatternCount * effectiveSpacing) / fieldShapeFactor);
    
    // Round to nearest reasonable value (nearest 10 acres for small, 100 for large)
    const roundedFieldSize = optimalFieldSize < 1000 
      ? Math.round(optimalFieldSize / 10) * 10 
      : Math.round(optimalFieldSize / 100) * 100;
    
    setFieldSize(roundedFieldSize);
  }, [facilitySize, patternType, injRatePerWell, wellSpacing, fieldShapeFactor]);
  
  // Auto-toggle 45Q credits based on value chain mode
  // EOR Only = no capture = no 45Q qualification
  // Full Value Chain = capture eligible for 45Q
  useEffect(() => {
    if (!fullValueChain) {
      setCreditEnabled(false);
    } else {
      setCreditEnabled(true);
    }
  }, [fullValueChain]);
  
  // Auto-toggle recycleExists based on scenario type
  // Existing flood = recycle facility likely already exists
  // New flood = need to build recycle facility
  useEffect(() => {
    if (scenarioType === 'Existing') {
      setRecycleExists(true);
    } else {
      setRecycleExists(false);
    }
  }, [scenarioType]);
  
  // When fixed project life is enabled, initialize it to the simulated duration
  useEffect(() => {
    if (useFixedProjectLife && calcs?.actualProjectYears) {
      setFixedProjectLife(prev => prev === 20 ? Math.round(calcs.actualProjectYears) : prev);
    }
  }, [useFixedProjectLife, calcs?.actualProjectYears]);
  
  // Computed EOR severance rate based on state and whether using anthropogenic CO₂
  const computedEORSeverance = useMemo(() => {
    const config = STATE_TAX_CONFIG[selectedState];
    if (!config) return severanceTax;
    
    let rate = config.eorSeverance;
    // Additional reduction for anthropogenic CO₂ in Texas
    if (config.anthropogenicCO2Bonus && creditEnabled) {
      rate = rate / 2; // Additional 50% reduction
    }
    return rate;
  }, [selectedState, creditEnabled, severanceTax]);
  
  // Section 43 Enhanced Oil Recovery Credit
  // 15% of qualified EOR costs, but phases out when oil price > ~$59/bbl (inflation-adjusted)
  // Currently phased out at prices above $59/bbl threshold (2025)
  const [section43Enabled, setSection43Enabled] = useState(false); // usually phased out at current prices
  const [section43PriceThreshold, setSection43PriceThreshold] = useState(59); // $/bbl - credit phases out above this

  // Link recycledCo2Cost ↔ recycleOpex (same underlying cost, shown in two places)
  const setRecycledCo2CostLinked = useCallback((v) => { setRecycledCo2Cost(v); setRecycleOpex(v); }, []);
  const setRecycleOpexLinked = useCallback((v) => { setRecycleOpex(v); setRecycledCo2Cost(v); }, []);

  // CO₂/Oil Ratio (tonnes CO₂ per barrel of incremental oil)
  // Literature: EERC (31 projects) 4.8-10.5 MCF/bbl; DOE 0.3-0.5 t/bbl; OGJ 4-5 MCF/bbl purchased;
  // Bell Creek: ~1 t/bbl gross early flood; PMC: net 7.96 MCF/bbl ≈ 0.41 t/bbl
  // Kuuskraa/DOE: 30 Bt CO₂ for 100 Bbbl = 0.30 t/bbl net (project-life average)
  // Default: 2.0 t/bbl (early flood, ~38 MCF/bbl) — conservative for new projects
  const [co2OilRatio, setCo2OilRatio] = useState(1.0); // tonnes CO₂ per barrel at steady-state

  // Ramp profile mode: 'auto' (set by scenario type) or 'custom' (user-defined)
  const [rampMode, setRampMode] = useState('auto');
  // Custom ramp: array of {year, multiplier} breakpoints, linearly interpolated between
  // multiplier × base ratio = effective ratio at that year. 1.0 = steady-state.
  const [customRamp, setCustomRamp] = useState([
    { year: 0, mult: 50 },
    { year: 0.5, mult: 15 },
    { year: 1, mult: 5 },
    { year: 2, mult: 2.5 },
    { year: 3, mult: 1.5 },
    { year: 5, mult: 1.0 },
    { year: 7, mult: 1.0 },
  ]);
  // Post-ramp degradation rate (%/yr) after last breakpoint
  const [customDegradation, setCustomDegradation] = useState(2.0);

  // Oil Production Profile: ramp-up and decline
  // Real EOR production follows: ramp-up (1-3 yrs) → peak/plateau (2-5 yrs) → decline (remainder)
  const [prodProfileFlat, setProdProfileFlat] = useState(true); // flat = no ramp/decline, just steady production
  const [prodRampUpYears, setProdRampUpYears] = useState(3); // years to reach peak production
  const [prodPeakYears, setProdPeakYears] = useState(2); // years at peak before decline begins
  const [prodDeclineRate, setProdDeclineRate] = useState(8); // %/year decline after peak

  // Previous metrics for comparison
  const [prevMetrics, setPrevMetrics] = useState(null);
  const prevMetricsRef = useRef(null);
  const scrollContainerRef = useRef(null);

  // Monte Carlo State
  const [mcIterations, setMcIterations] = useState(1000);
  const [mcResults, setMcResults] = useState(null);
  const [mcRunning, setMcRunning] = useState(false);
  const [mcOutputMetric, setMcOutputMetric] = useState('npv');
  const mcScrollRef = useRef(0);

  const [mcParams, setMcParams] = useState({
    wtiPrice: { enabled: true, dist: 'triangular', spread: 30 },
    co2Price: { enabled: false, dist: 'uniform', spread: 50 },
    co2OilRatio: { enabled: true, dist: 'triangular', spread: 20 },
    injPerWellPerYr: { enabled: false, dist: 'triangular', spread: 15 },
    prodOpex: { enabled: true, dist: 'triangular', spread: 25 },
    captureOpex: { enabled: false, dist: 'triangular', spread: 20 },
    recycleOpex: { enabled: true, dist: 'triangular', spread: 20 },
    discountRate: { enabled: false, dist: 'triangular', spread: 20 },
    creditTotal: { enabled: false, dist: 'uniform', spread: 15 },
  });

  // CO₂ Source presets: type → { label, concentration (vol%), capexPerTpa ($/tonne-annual-capacity), opex ($/t levelized), description }
  // CAPEX data from: NETL "Cost of Capturing CO₂ from Industrial Sources" (2022), IEA, Incorrys, Shand study
  // NETL COC: high-purity (>95%) avg $17.5/t, low-purity (<50%) avg $62/t (Dec 2018 USD)
  // Incorrys (2025): global CCS avg CAPEX ~$270-320/tpa; EOR projects ~$270/tpa
  // Boundary Dam FOAK: ~$800/tpa; Shand NOAK est: ~$265/tpa; Quest: ~$750/tpa all-in
  const CO2_SOURCES = {
    ngp:      { label: 'Natural Gas Processing',    conc: 96, capexPerTpa: 75,  opex: 8,    desc: '~96% CO₂. Minimal separation needed. NETL COC: $16/t' },
    ethanol:  { label: 'Ethanol Fermentation',      conc: 99, capexPerTpa: 60,  opex: 6,    desc: '~99% CO₂. Nearly pure stream, compression only. NETL COC: $18/t' },
    ammonia:  { label: 'Ammonia / Hydrogen',        conc: 97, capexPerTpa: 90,  opex: 10,   desc: '~97% CO₂ from SMR syngas. NETL COC: $22/t' },
    refinery: { label: 'Refinery / SMR Flue Gas',   conc: 20, capexPerTpa: 280, opex: 35,   desc: '~20% CO₂. Amine scrubbing required. NETL COC: $44/t' },
    cement:   { label: 'Cement Plant',              conc: 22, capexPerTpa: 350, opex: 50,   desc: '~22% CO₂. Large flue gas volumes. NETL COC: $58/t' },
    coal:     { label: 'Coal Power Plant',          conc: 12, capexPerTpa: 400, opex: 55,   desc: '~12% CO₂. Dilute stream, high energy penalty. Shand NOAK: $265/tpa, BD FOAK: $800/tpa' },
    ngcc:     { label: 'NGCC Power Plant',          conc: 4,  capexPerTpa: 500, opex: 65,   desc: '~4% CO₂. Very dilute. DOE NGCC CCS: ~$84/t levelized' },
    custom:   { label: 'Custom',                    conc: 50, capexPerTpa: 200, opex: 30,   desc: 'User-defined concentration and costs' },
  };

  // Auto-calculated CAPEX estimates based on injection rate, source purity, and pipeline engineering
  //
  // CAPTURE CAPEX: Driven by CO₂ source purity (NETL 2022, IEA, Incorrys 2025)
  //   High purity (>90%): $60-90/tpa — mainly compression + dehydration
  //   Medium purity (15-50%): $200-350/tpa — amine scrubbing + compression
  //   Low purity (<15%): $400-500/tpa — large absorber towers, high energy penalty
  //   Scales sub-linearly with capacity (0.7 exponent, per NETL/ChemE scaling)
  //
  // TRANSPORT CAPEX: Pipeline inch-mile cost model (OSTI, Trimeric, EPA)
  //   Literature range: $51k-$228k per inch-mile (Trimeric $51-119k; EPA Platform v6 $228k)
  //   Default: $85k/inch-mile (mid-range, 2024$)
  //   Diameter from throughput: D(in) = 5.35 × Q^0.45 where Q in Mt/yr (fit to Kinder Morgan data)
  //   CAPEX = diameter(in) × distance(mi) × $/inch-mile × 1.15 (compression/ROW adder)
  //
  // RECYCLE CAPEX: OSTI formula (unchanged)

  // ============ HELPER: CALCULATE PATTERN DERIVED VALUES ============
  // This helper allows recalculating pattern-derived values for different facility/field sizes
  const calcPatternDerivedForSize = useCallback((overrideFacilitySize, overrideFieldSize) => {
    const facSize = overrideFacilitySize ?? facilitySize;
    const fldSize = overrideFieldSize ?? fieldSize;
    
    const patConfig = PATTERN_TYPES[patternType] || PATTERN_TYPES['5-spot'];
    const effectiveSpacing = Math.max(1, wellSpacing * patConfig.acresPerPattern);
    const maxPatterns = Math.max(1, Math.floor((fldSize * fieldShapeFactor) / effectiveSpacing));
    const injPerPattern = patConfig.inj;
    const prodPerPatternConfig = patConfig.prod;
    const isSingleWell = patternType === 'single-well';
    
    const getProducersForPatterns = (n) => {
      if (n <= 0) return 0;
      if (n === 1) return 4;
      const cols = Math.ceil(Math.sqrt(n));
      const rows = Math.ceil(n / cols);
      return (rows + 1) * (cols + 1);
    };
    
    const effectiveProdPerPattern = isSingleWell 
      ? 0
      : patternType.includes('inv') 
        ? prodPerPatternConfig
        : maxPatterns > 0 ? getProducersForPatterns(maxPatterns) / maxPatterns : 4;
    
    const injectorsForFacility = Math.ceil(facSize / injRatePerWell);
    const maxInjectors = Math.min(injectorsForFacility * injPerPattern, maxPatterns * injPerPattern);
    const maxProducers = isSingleWell ? maxInjectors : getProducersForPatterns(maxPatterns);
    
    const safeDeclineRate = Math.max(0.01, Math.min(99.99, patternDeclineRate));
    const declineYearsToAbandonment = patternAbandonmentPct < 100 && patternAbandonmentPct > 0
      ? Math.log(patternAbandonmentPct / 100) / Math.log(1 - safeDeclineRate / 100)
      : 20;
    const patternLifeYears = patternFillYears + patternRampYears + patternPeakYears + Math.abs(declineYearsToAbandonment);
    
    const existingPatterns = Math.round(maxPatterns * (pctDeveloped / 100));
    const injectorsAtCapacity = Math.floor(facSize / injRatePerWell);
    const patternsAtCapacity = Math.max(1, Math.floor(injectorsAtCapacity / injPerPattern));
    
    const wagStaggerMultiplier = eorMethod === 'wag' ? (1 + wagRatio) : 1;
    const hpCycleDays = hpInjectionDays + hpSoakDays + hpProductionDays;
    const hpInjectionFraction = hpInjectionDays / hpCycleDays;
    const hpStaggerMultiplier = eorMethod === 'huffpuff' ? Math.min(3, Math.floor(1 / hpInjectionFraction)) : 1;
    
    const effectivePatternsAtCapacity = Math.floor(patternsAtCapacity * wagStaggerMultiplier * hpStaggerMultiplier);
    const startingPatternsNew = Math.min(effectivePatternsAtCapacity, maxPatterns);
    const patternsPerPhase = Math.max(1, Math.min(effectivePatternsAtCapacity, maxPatterns));
    
    const yearsPerPhase = 0.75;
    const remainingPatterns = maxPatterns - existingPatterns;
    
    let estProjectLife;
    if (scenarioType === 'Existing') {
      if (remainingPatterns <= 0) {
        const remainingPatternLife = Math.max(patternLifeYears - avgPatternAge, Math.abs(declineYearsToAbandonment) + 2);
        estProjectLife = Math.ceil(remainingPatternLife);
      } else {
        const phasesToComplete = Math.ceil(remainingPatterns / patternsPerPhase);
        const developmentTime = phasesToComplete * yearsPerPhase;
        estProjectLife = Math.ceil(developmentTime + patternLifeYears);
      }
    } else {
      const patternsToDevAfterStart = maxPatterns - startingPatternsNew;
      const phasesToFullDev = Math.ceil(patternsToDevAfterStart / patternsPerPhase);
      const developmentTime = phasesToFullDev * yearsPerPhase;
      estProjectLife = Math.ceil(developmentTime + patternLifeYears);
    }
    estProjectLife = Math.max(estProjectLife, Math.ceil(patternLifeYears));
    
    // Optimal field size calculation
    const patternsNeededForFacility = Math.ceil(facSize / (injRatePerWell * injPerPattern));
    const sustainabilityMultiplier = 2.5;
    const optimalPatternCount = Math.ceil(patternsNeededForFacility * sustainabilityMultiplier);
    const minOptimalFieldSize = Math.ceil((optimalPatternCount * effectiveSpacing) / fieldShapeFactor);
    const fieldSizeAdequate = fldSize >= minOptimalFieldSize * 0.9;
    
    return {
      maxPatterns,
      injPerPattern,
      prodPerPattern: effectiveProdPerPattern,
      effectiveSpacing,
      patternLifeYears: Math.round(patternLifeYears * 10) / 10,
      existingPatterns,
      startingPatternsNew,
      patternsPerPhase,
      estProjectLife,
      maxInjectors,
      maxProducers,
      effectivePatternsAtCapacity,
      facilitySize: facSize,
      fieldSize: fldSize,
      // Additional fields needed by UI
      patternsNeededForFacility,
      optimalPatternCount,
      minOptimalFieldSize,
      fieldSizeAdequate,
      declineYearsToAbandonment: Math.round(declineYearsToAbandonment * 10) / 10,
      remainingPatterns,
      injectorsForFacility,
      injectorsAtCapacity,
      patternsAtCapacity,
      isSingleWell,
    };
  }, [facilitySize, fieldSize, patternType, wellSpacing, fieldShapeFactor, injRatePerWell,
      patternDeclineRate, patternAbandonmentPct, patternFillYears, patternRampYears, patternPeakYears,
      pctDeveloped, avgPatternAge, scenarioType, eorMethod, wagRatio, hpInjectionDays, hpSoakDays, hpProductionDays]);

  // ============ PATTERN-BASED DERIVED VALUES ============
  const patternDerived = useMemo(() => {
    return calcPatternDerivedForSize(facilitySize, fieldSize);
  }, [calcPatternDerivedForSize, facilitySize, fieldSize]);

  const computedCapex = useMemo(() => {
    const annualInjection = injPerWellPerYr * injWellCount; // tonnes/yr
    const mtPerYr = annualInjection / 1e6;

    // --- CAPTURE CAPEX ---
    // Base unit cost from source type ($/tonne-annual-capacity)
    const source = CO2_SOURCES[co2SourceType] || CO2_SOURCES.ngp;
    const baseCapexPerTpa = co2SourceType === 'custom'
      ? capexFromConcentration(co2Concentration)
      : source.capexPerTpa;
    // Scale factor for capacity: (Q/Q_ref)^0.7 — economies of scale, ref = 1.0 Mt/yr
    const capacityScaleFactor = Math.pow(Math.max(mtPerYr, 0.01) / 1.0, -0.3) ; // cost per tpa decreases with scale
    const scaledCapexPerTpa = baseCapexPerTpa * Math.min(capacityScaleFactor, 3.0); // cap at 3x for very small
    const captureCapexCalc = (scaledCapexPerTpa * annualInjection) / 1e6; // $MM

    // --- TRANSPORT CAPEX ---
    // Pipeline diameter from throughput: empirical fit D(in) = 5.35 × Q(Mt/yr)^0.45
    const pipeDiameterIn = Math.max(4, Math.min(36, 5.35 * Math.pow(Math.max(mtPerYr, 0.01), 0.45)));
    // Nearest standard pipe size (even inches)
    const nominalDiameter = Math.ceil(pipeDiameterIn / 2) * 2;
    const dist = Math.max(pipelineDistance, 1);
    // Pipeline CAPEX = D(in) × L(mi) × $/inch-mile × 1.15 (compression, ROW, misc)
    const transportCapexCalc = (nominalDiameter * dist * pipelineCostPerInchMile * 1.15) / 1e6; // $MM

    // --- RECYCLE CAPEX (OSTI formula, unchanged) ---
    const dailyInj = annualInjection / 365;
    const mcfd = dailyInj * 19; // MCF/day
    let recycleCapexCalc;
    if (annualInjection < 579000) {
      recycleCapexCalc = (1200 * mcfd / 1e6) * 1.5;
    } else {
      recycleCapexCalc = ((36000 + (((mcfd / 1000) - 30) * 750)) / 1000) * 1.5;
    }

    // --- OPEX (model formulas) ---
    const storageOpexCalc = (34000 + (4 * 5000)) * 1.5 / Math.max(injPerWellPerYr, 1);
    const recycleOpexCalc = wtiPrice * 0.01 * 19;
    const captureOpexBase = co2SourceType === 'custom' ? captureOpex : source.opex;

    return {
      captureCapex: Math.round(captureCapexCalc * 10) / 10,
      transportCapex: Math.round(transportCapexCalc * 10) / 10,
      recycleCapex: Math.round(recycleCapexCalc * 100) / 100,
      storageOpex: Math.round(storageOpexCalc * 100) / 100,
      recycleOpex: Math.round(recycleOpexCalc * 100) / 100,
      captureOpexRef: Math.round(captureOpexBase * 100) / 100,
      annualInjectionMt: mtPerYr,
      capexPerTpa: Math.round(scaledCapexPerTpa),
      baseCapexPerTpa: Math.round(baseCapexPerTpa),
      pipeDiameterIn: nominalDiameter,
      co2Concentration: co2SourceType === 'custom' ? co2Concentration : source.conc,
    };
  }, [injPerWellPerYr, injWellCount, pipelineDistance, pipelineCostPerInchMile, wtiPrice, co2SourceType, co2Concentration, captureOpex]);

  // Interpolate CAPEX from CO₂ concentration for custom source
  // Piecewise linear fit to NETL/IEA data points
  function capexFromConcentration(conc) {
    const pts = [
      [4, 500], [12, 400], [20, 280], [30, 220], [50, 160], [70, 120], [90, 90], [96, 75], [99, 60]
    ];
    if (conc <= pts[0][0]) return pts[0][1];
    if (conc >= pts[pts.length - 1][0]) return pts[pts.length - 1][1];
    for (let i = 0; i < pts.length - 1; i++) {
      if (conc >= pts[i][0] && conc <= pts[i + 1][0]) {
        const t = (conc - pts[i][0]) / (pts[i + 1][0] - pts[i][0]);
        return pts[i][1] + t * (pts[i + 1][1] - pts[i][1]);
      }
    }
    return 200;
  }

  // Computed well costs from depth
  const computedWellCosts = useMemo(() => {
    const newWellCost = wellDepth * newWellCostPerFt;
    const retrofitCost = wellDepth * retrofitCostPerFt;
    const blendedCost = (newWellsPct / 100) * newWellCost + (1 - newWellsPct / 100) * retrofitCost;
    return {
      newWellCost,
      retrofitCost,
      blendedCost,
      newWellCostMM: newWellCost / 1e6,
      retrofitCostK: retrofitCost / 1000,
      blendedCostK: blendedCost / 1000,
    };
  }, [wellDepth, newWellCostPerFt, retrofitCostPerFt, newWellsPct]);

  // ============ COMPUTED FINANCING PARAMETERS ============
  const computedFinancing = useMemo(() => {
    // Combined tax rate (state deductible from federal)
    const combinedTaxRate = (federalTaxRate + stateTaxRate * (1 - federalTaxRate / 100)) / 100;
    
    // After-tax cost of debt
    const afterTaxCostOfDebt = (debtInterestRate / 100) * (1 - combinedTaxRate);
    
    // WACC calculation
    const equityPct = (100 - debtPct) / 100;
    const debtPctDecimal = debtPct / 100;
    const calculatedWacc = debtPctDecimal * afterTaxCostOfDebt + equityPct * (costOfEquity / 100);
    
    // Effective discount rate (either fixed hurdle rate or calculated WACC)
    const effectiveDiscountRate = useHurdleRate ? (hurdleRate / 100) : calculatedWacc;
    
    // MACRS 7-year depreciation schedule (200% declining balance, half-year convention)
    const macrs7Year = [0.1429, 0.2449, 0.1749, 0.1249, 0.0893, 0.0892, 0.0893, 0.0446];
    
    // With bonus depreciation: bonus % in year 1, remainder follows MACRS
    const adjustedMacrs = macrs7Year.map((rate, i) => {
      if (i === 0) return (bonusDepreciation / 100) + (1 - bonusDepreciation / 100) * rate;
      return (1 - bonusDepreciation / 100) * rate;
    });
    
    return {
      combinedTaxRate,
      combinedTaxRatePct: combinedTaxRate * 100,
      afterTaxCostOfDebt,
      afterTaxCostOfDebtPct: afterTaxCostOfDebt * 100,
      calculatedWacc,
      calculatedWaccPct: calculatedWacc * 100,
      effectiveDiscountRate,
      effectiveDiscountRatePct: effectiveDiscountRate * 100,
      equityPct: equityPct * 100,
      macrs7Year,
      adjustedMacrs,
    };
  }, [federalTaxRate, stateTaxRate, debtPct, debtInterestRate, costOfEquity, useHurdleRate, hurdleRate, bonusDepreciation]);

  // Sync computed well costs to the per-well cost states (use blended cost)
  useEffect(() => {
    setInjWellCost(computedWellCosts.blendedCost);
    setProdWellCost(computedWellCosts.blendedCost);
    setRetrofitCostPerWell(computedWellCosts.retrofitCost);
  }, [computedWellCosts]);

  // When auto-calc is on and full value chain, sync computed values to state
  useEffect(() => {
    if (fullValueChain && autoCalcCapex) {
      setCaptureCapex(computedCapex.captureCapex);
      setTransportCapex(computedCapex.transportCapex);
      if (co2SourceType !== 'custom') {
        setCaptureOpex(computedCapex.captureOpexRef);
      }
    }
  }, [fullValueChain, autoCalcCapex, computedCapex, co2SourceType]);

  // Handle scenario type changes
  useEffect(() => {
    if (scenarioType === 'New') {
      setInjWellCost(1000000);
      setRecycleCapex(computedCapex.recycleCapex);
      if (!fullValueChain || !autoCalcCapex) setTransportCapex(computedCapex.transportCapex);
      setRetrofitCostPerWell(250000);
      setRetrofitWellCount(Math.round(injWellCount));
    } else {
      setInjWellCost(0);
      setRecycleCapex(0);
      if (!fullValueChain || !autoCalcCapex) setTransportCapex(0);
      setRetrofitCostPerWell(0);
      setRetrofitWellCount(0);
    }
  }, [scenarioType]);

  // Sync pattern type and injection rate when EOR method changes
  useEffect(() => {
    const config = EOR_METHOD_CONFIG[eorMethod];
    if (config) {
      setPatternType(config.pattern);
      setInjRatePerWell(config.defaultInjRate);
    }
  }, [eorMethod]);

  const resetToDefaults = () => {
    // Core mode settings - match initial load state
    setModelMode('pattern');
    setScenarioType('New');
    setFullValueChain(true);
    
    // EOR method and pattern type
    setEorMethod('continuous'); 
    setWagRatio(1); setWagCycleMonths(3);
    setHpInjectionDays(14); setHpSoakDays(14); setHpProductionDays(120); setHpCycles(4);
    setPatternType('5-spot');
    
    // Pattern-based mode defaults
    setFacilitySize(100000); setFieldSize(640); setWellSpacing(40); setFieldShapeFactor(0.85);
    setInjRatePerWell(30000); setPatternFillYears(1); setPatternRampYears(2); setPatternPeakYears(4);
    setPatternDeclineRate(12); setPatternAbandonmentPct(20); setPctDeveloped(50); setAvgPatternAge(5);
    setActivationThreshold(20000);
    setFeederPipePerPattern(0.5); setFeederPipeCostPerMile(100000);
    setRecycleExists(false);
    setNewWellsPct(0);
    setAnimationMonth(0); setIsAnimating(false);
    
    // Oil pricing
    setWtiPrice(65); setOilDiff(5); setDiscountRate(10);
    
    // Simple mode defaults (for when switching modes)
    setProducingYears(12); setProdWellCost(0); setProdWellCount(100); setProdPerWellPerYr(15000);
    setInjWellCost(0); setInjWellCount(62.5); setInjPerWellPerYr(30000);
    setWellDepth(8000); setNewWellCostPerFt(200); setRetrofitCostPerFt(25);
    setRetrofitCostPerWell(0); setRetrofitWellCount(0);
    
    // CO2 pricing
    setCo2Price(0); setRecycledCo2Cost(12.35);
    
    // Production OPEX
    setProdOpex(10); setOilTransport(5);
    
    // 45Q Credit - enabled by default
    setCreditYears(12); setCreditTotal(85); setCreditEnabled(true);
    setCreditInflation(true); setCreditInflationRate(2.5);
    
    // CO2 Recycle
    setRecycleMode('ramping'); setFixedRecycleRate(60);
    
    // Production profile
    setRampMode('auto');
    setCustomRamp([{year:0,mult:50},{year:0.5,mult:15},{year:1,mult:5},{year:2,mult:2.5},{year:3,mult:1.5},{year:5,mult:1.0},{year:7,mult:1.0}]);
    setCustomDegradation(2.0);
    setProdProfileFlat(true); setProdRampUpYears(3); setProdPeakYears(2); setProdDeclineRate(8);
    
    // Value chain settings
    setAutoCalcCapex(true); setPipelineDistance(50);
    setCo2SourceType('ngp'); setCo2Concentration(96); setPipelineCostPerInchMile(85000);
    setCaptureCapex(0); setRecycleCapex(0); setStorageCapex(0); setTransportCapex(6.32);
    setCaptureOpex(0); setRecycleOpex(12.35); setStorageOpex(2.7); setTransportOpex(1);
    
    // CO2/Oil ratio
    setCo2OilRatio(1.0);
    
    // Schedule & Ramp
    setEorStartYear(2025); setEorStartMonth(1);
    setCaptureConstructionMonths(24); setRecycleConstructionMonths(18); setPipelineConstructionMonths(12);
    setUsePatternRamp(true); setPatternsPerMonth(1); setRampIntervalMonths(1);
    
    // Financing
    setDebtPct(60); setDebtInterestRate(8); setDebtTerm(10); setCostOfEquity(15);
    setUseHurdleRate(true); setHurdleRate(10);
    
    // Tax - Texas defaults
    setSelectedState('TX');
    setFederalTaxRate(21); setStateTaxRate(0); setSeveranceTax(4.6);
    setIdcPct(70); setBonusDepreciation(40); setDepletionAllowance(15);
    setEnableTaxCalc(true);
    setSection43Enabled(false); setSection43PriceThreshold(59);
  };

  // Random number generators
  const randomGenerators = {
    uniform: (min, max) => min + Math.random() * (max - min),
    triangular: (min, mode, max) => {
      const u = Math.random();
      const fc = (mode - min) / (max - min);
      return u < fc ? min + Math.sqrt(u * (max - min) * (mode - min)) : max - Math.sqrt((1 - u) * (max - min) * (max - mode));
    },
    normal: (mean, stdDev) => {
      const u1 = Math.random(), u2 = Math.random();
      return mean + Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * stdDev;
    },
  };

  const generateRandomValue = (config, baseValue) => {
    if (!config.enabled) return baseValue;
    const spread = config.spread / 100;
    const min = baseValue * (1 - spread);
    const max = baseValue * (1 + spread);
    switch (config.dist) {
      case 'uniform': return randomGenerators.uniform(min, max);
      case 'triangular': return randomGenerators.triangular(min, baseValue, max);
      case 'normal': return randomGenerators.normal(baseValue, baseValue * spread);
      default: return baseValue;
    }
  };

  // Core calculation function
  const calculateProjectMetrics = useCallback((params = {}) => {
    const p = {
      wtiPrice, oilDiff, discountRate, producingYears, prodWellCost, prodWellCount,
      prodPerWellPerYr, injWellCost, injWellCount, injPerWellPerYr, co2Price,
      recycledCo2Cost, prodOpex, oilTransport, severanceTax, creditYears, creditTotal,
      creditEnabled, creditInflation, creditInflationRate,
      captureCapex, recycleCapex, storageCapex, transportCapex,
      captureOpex, recycleOpex, storageOpex, transportOpex, co2OilRatio,
      scenarioType, recycleMode, fixedRecycleRate, fullValueChain,
      rampMode, customRamp, customDegradation,
      retrofitCostPerWell, retrofitWellCount,
      prodProfileFlat, prodRampUpYears, prodPeakYears, prodDeclineRate,
      // Financing & Tax parameters
      enableTaxCalc, federalTaxRate, stateTaxRate, idcPct, bonusDepreciation, depletionAllowance,
      section43Enabled, section43PriceThreshold,
      debtPct, debtInterestRate, debtTerm,
      effectiveDiscountRate: computedFinancing.effectiveDiscountRate,
      combinedTaxRate: computedFinancing.combinedTaxRate,
      adjustedMacrs: computedFinancing.adjustedMacrs,
      // Schedule & Ramp parameters
      eorStartYear, eorStartMonth, 
      captureConstructionMonths, recycleConstructionMonths, pipelineConstructionMonths,
      usePatternRamp, patternsPerMonth, rampIntervalMonths,
      ...params
    };

    // If not full value chain, zero out capture and transport costs (operator buys CO₂ at field gate)
    if (!p.fullValueChain) {
      p.captureCapex = 0;
      p.captureOpex = 0;
      p.transportCapex = 0;
      p.transportOpex = 0;
    }

    const months = p.producingYears * 12;
    const monthlyInjPerWell = p.injPerWellPerYr / 12;
    const totalInjPerMonth = monthlyInjPerWell * p.injWellCount;
    const netOilPrice = p.wtiPrice - p.oilDiff;
    const sevTaxRate = p.severanceTax / 100;
    // Use effective discount rate (either hurdle rate or WACC)
    const dr = p.effectiveDiscountRate;

    // CO₂/Oil Utilization Ratio Profile
    // Literature basis:
    //   EERC study (31 EOR projects): CO₂ utilization 4.8-10.5 MCF/bbl net, highest early in flood
    //   DOE Ch.8: 0.5-0.75 t CO₂/bbl (10-15 MCF/bbl), PMC: net 7.96 MCF/bbl ≈ 0.41 t/bbl
    //   NETL: ~8,000 SCF/bbl gross; Bell Creek: ~1 t/bbl gross early flood
    //   OGJ: "4-5 MCF purchased per incremental barrel" early flood
    //   New floods: reservoir must fill with CO₂ before oil mobilizes — very high ratio initially
    //     (infinite at t=0 since you inject but get no oil), then ratio improves (decreases) as
    //     the miscible bank forms and sweeps toward producers
    //   Existing floods: ratio is already near steady-state; may degrade slightly in late life
    //     as CO₂ channels through depleted zones
    //
    // The ratio here is EFFECTIVE: tonnes of total CO₂ injected per barrel of oil produced that month.
    // A lower ratio means better efficiency (more oil per tonne CO₂).
    // Oil production = CO₂ injected / effectiveRatio

    // Custom ramp interpolation helper
    const interpolateCustomRamp = (year, rampPts, degradeRate, baseR) => {
      const sorted = [...rampPts].sort((a, b) => a.year - b.year);
      if (sorted.length === 0) return baseR;
      const lastPt = sorted[sorted.length - 1];
      if (year >= lastPt.year) {
        // Post-ramp degradation
        const yearsPost = year - lastPt.year;
        return baseR * lastPt.mult * Math.pow(1 + degradeRate / 100, yearsPost);
      }
      if (year <= sorted[0].year) return baseR * sorted[0].mult;
      // Linear interpolation between breakpoints
      for (let i = 0; i < sorted.length - 1; i++) {
        if (year >= sorted[i].year && year <= sorted[i + 1].year) {
          const t = (year - sorted[i].year) / (sorted[i + 1].year - sorted[i].year);
          return baseR * (sorted[i].mult + t * (sorted[i + 1].mult - sorted[i].mult));
        }
      }
      return baseR * lastPt.mult;
    };

    const getEffectiveCo2OilRatio = (month) => {
      const year = month / 12;
      const baseRatio = p.co2OilRatio; // steady-state tonnes CO₂ per barrel

      // Custom ramp mode
      if (p.rampMode === 'custom') {
        return interpolateCustomRamp(year, p.customRamp, p.customDegradation, baseRatio);
      }

      if (p.scenarioType === 'New') {
        // New flood: reservoir filling phase — very high ratio (low oil per CO₂)
        // Year 0-0.5: filling reservoir, essentially no oil response → ratio = 50x base (near-zero oil)
        // Year 0.5-1: first traces of oil response → ratio = 15x base
        // Year 1-2: early bank forming → ratio = 5x base → 2.5x
        // Year 2-3: main response → 2.5x → 1.5x
        // Year 3-5: approaching design efficiency → 1.5x → 1.1x
        // Year 5-7: at design efficiency → 1.0x
        // Year 7+: slight degradation due to CO₂ channeling → ratio slowly increases ~2%/yr
        if (year <= 0.5) return baseRatio * 50; // reservoir filling, minimal oil
        if (year <= 1.0) return baseRatio * (50 - (year - 0.5) * 70); // 50x → 15x
        if (year <= 2.0) return baseRatio * (15 - (year - 1.0) * 10); // 15x → 5x
        if (year <= 3.0) return baseRatio * (5 - (year - 2.0) * 2.5); // 5x → 2.5x
        if (year <= 4.0) return baseRatio * (2.5 - (year - 3.0) * 1.0); // 2.5x → 1.5x
        if (year <= 5.0) return baseRatio * (1.5 - (year - 4.0) * 0.3); // 1.5x → 1.2x
        if (year <= 7.0) return baseRatio * (1.2 - (year - 5.0) * 0.1); // 1.2x → 1.0x
        // Post-peak: slight degradation ~2%/yr as CO₂ channels through swept zones
        const yearsPostPeak = year - 7;
        return baseRatio * Math.pow(1.02, yearsPostPeak);
      } else {
        // Existing flood: CO₂ already in reservoir, near design efficiency
        // Start at 1.1x base (slight inefficiency from new injection patterns), reach 1.0x by year 1
        // After midpoint: slight degradation ~1.5%/yr
        if (year <= 1.0) return baseRatio * (1.1 - year * 0.1); // 1.1x → 1.0x
        const midpoint = p.producingYears / 2;
        if (year <= midpoint) return baseRatio;
        const yearsPostMid = year - midpoint;
        return baseRatio * Math.pow(1.015, yearsPostMid);
      }
    };

    // CAPEX
    const injectionWellCapex = p.injWellCost * p.injWellCount;
    const prodWellCapexTotal = p.prodWellCost * p.prodWellCount;
    const wellRetrofitCapex = p.retrofitCostPerWell * p.retrofitWellCount;
    const ccusCapex = (p.captureCapex + p.recycleCapex + p.storageCapex + p.transportCapex) * 1e6;
    const totalCapex = injectionWellCapex + prodWellCapexTotal + wellRetrofitCapex + ccusCapex;

    // Monthly calculations
    let totalOilRevenue = 0;
    let totalCO2CreditRevenue = 0;
    let totalOilOpex = 0;
    let totalOilTransportCost = 0;
    let totalSeveranceTaxCost = 0;
    let totalCO2PurchaseCost = 0;
    let totalCO2ReceiptRevenue = 0;
    let totalRecycleOpexCost = 0;
    let totalCaptureOpexCost = 0;
    let totalStorageOpexCost = 0;
    let totalTransportOpexCost = 0;
    let npvCashFlows = -totalCapex; // initial investment
    let totalActualProduction = 0;

    const monthlyData = [];
    let cumulativeCF = -totalCapex;
    let paybackMonth = null;

    // CO2 injection/storage tracking
    let totalCO2Injected = 0;
    let totalCO2Stored = 0;

    // CO₂ recycle fraction model
    // In EOR, injected CO₂ is initially retained in the reservoir (high storage, low recycle).
    // Over time CO₂ breaks through to production wells and an increasing fraction is recycled.
    // Denbury field data: ~20% recycled by yr 15, ~50% by yr 20, ~70% by yr 25, ~80% by yr 30.
    // For shorter project horizons we use an accelerated S-curve calibrated to typical 10-20yr floods.
    const getRecycleFraction = (month) => {
      if (p.recycleMode === 'fixed') return p.fixedRecycleRate / 100;
      const year = month / 12;
      if (year <= 1) return 0;
      if (year <= 3) return Math.min(0.10, (year - 1) * 0.05);
      if (year <= 6) return Math.min(0.30, 0.10 + (year - 3) * 0.067);
      if (year <= 10) return Math.min(0.55, 0.30 + (year - 6) * 0.0625);
      if (year <= 15) return Math.min(0.70, 0.55 + (year - 10) * 0.03);
      if (year <= 20) return Math.min(0.80, 0.70 + (year - 15) * 0.02);
      return Math.min(0.85, 0.80 + (year - 20) * 0.005);
    };

    // Oil production multiplier: ramp-up → peak → decline
    // Ramp-up: linear from ~10% to 100% over prodRampUpYears
    // Peak: flat at 100% for prodPeakYears  
    // Decline: exponential at prodDeclineRate %/yr
    const getProductionMultiplier = (month) => {
      // Flat profile: always 100%
      if (p.prodProfileFlat) return 1.0;
      
      const year = month / 12;
      const rampEnd = p.prodRampUpYears;
      const peakEnd = rampEnd + p.prodPeakYears;
      
      if (year <= rampEnd) {
        // Ramp-up phase: linear from 10% to 100%
        const rampProgress = year / rampEnd;
        return 0.1 + 0.9 * rampProgress;
      } else if (year <= peakEnd) {
        // Peak/plateau phase: 100%
        return 1.0;
      } else {
        // Decline phase: exponential decline
        const yearsInDecline = year - peakEnd;
        const declineRate = p.prodDeclineRate / 100;
        return Math.pow(1 - declineRate, yearsInDecline);
      }
    };

    for (let m = 1; m <= months; m++) {
      const year = Math.ceil(m / 12);
      const discountFactor = Math.pow(1 + dr, -(m - 0.5) / 12);

      // EOR production derived from CO₂ injection and utilization ratio
      // Oil produced = CO₂ injected / effective ratio (t CO₂ per bbl) × production multiplier
      const effectiveRatio = getEffectiveCo2OilRatio(m);
      const prodMultiplier = getProductionMultiplier(m);
      const baseEorProd = totalInjPerMonth / effectiveRatio;
      const eorProd = baseEorProd * prodMultiplier;
      totalActualProduction += eorProd;

      // CO2 volumes
      const freshCO2 = totalInjPerMonth;
      const recycleFrac = getRecycleFraction(m);
      const recycledCO2 = freshCO2 * recycleFrac;
      const netNewCO2 = freshCO2 * (1 - recycleFrac);
      const co2Stored = netNewCO2; // net stored = injected - produced/recycled

      totalCO2Injected += freshCO2;
      totalCO2Stored += co2Stored;

      // Oil Revenue
      const oilRev = eorProd * netOilPrice;
      totalOilRevenue += oilRev;

      // 45Q Credit Revenue (with optional inflation escalation)
      let creditRev = 0;
      if (p.creditEnabled && year <= p.creditYears) {
        const inflationFactor = p.creditInflation ? Math.pow(1 + p.creditInflationRate / 100, year - 1) : 1;
        creditRev = co2Stored * p.creditTotal * inflationFactor;
      }
      totalCO2CreditRevenue += creditRev;

      // CO2 Purchase Cost (if buying CO2)
      let co2PurchaseCost = 0;
      if (p.co2Price > 0) {
        co2PurchaseCost = 0; // Getting paid for CO2
      } else {
        co2PurchaseCost = netNewCO2 * Math.abs(p.co2Price);
      }
      totalCO2PurchaseCost += co2PurchaseCost;

      // CO2 credit from receiving CO2 (if someone pays you to take it)
      let co2ReceiptRevenue = 0;
      if (p.co2Price > 0) {
        co2ReceiptRevenue = netNewCO2 * p.co2Price;
      }
      totalCO2ReceiptRevenue += co2ReceiptRevenue;

      // OPEX
      const oilOpexCost = eorProd * p.prodOpex;
      const oilTransCost = eorProd * p.oilTransport;
      const sevTaxCost = oilRev * sevTaxRate;
      const recycleOpexCost = recycledCO2 * p.recycleOpex;
      const captureOpexCost = netNewCO2 * p.captureOpex;
      const storageOpexCost = co2Stored * p.storageOpex;
      const transportOpexCost = netNewCO2 * p.transportOpex;

      totalOilOpex += oilOpexCost;
      totalOilTransportCost += oilTransCost;
      totalSeveranceTaxCost += sevTaxCost;
      totalRecycleOpexCost += recycleOpexCost;
      totalCaptureOpexCost += captureOpexCost;
      totalStorageOpexCost += storageOpexCost;
      totalTransportOpexCost += transportOpexCost;

      const monthlyCF = oilRev + creditRev + co2ReceiptRevenue
        - co2PurchaseCost - oilOpexCost - oilTransCost - sevTaxCost
        - recycleOpexCost - captureOpexCost - storageOpexCost - transportOpexCost;

      npvCashFlows += monthlyCF * discountFactor;
      cumulativeCF += monthlyCF;

      if (paybackMonth === null && cumulativeCF >= 0) {
        paybackMonth = m;
      }

      if (m % 3 === 0 || m === 1 || m === months) {
        monthlyData.push({
          month: m,
          year: year,
          label: `Y${year}`,
          eorProd,
          prodMultiplier: prodMultiplier * 100, // as percentage for chart
          effectiveRatio: effectiveRatio,
          co2OilRatioMCF: Math.min(effectiveRatio * 19.25, 200), // cap display at 200 MCF/bbl for chart readability
          oilRevenue: oilRev / 1e6,
          creditRevenue: creditRev / 1e6,
          co2ReceiptRevenue: co2ReceiptRevenue / 1e6,
          totalRevenue: (oilRev + creditRev + co2ReceiptRevenue) / 1e6,
          totalCosts: (co2PurchaseCost + oilOpexCost + oilTransCost + sevTaxCost + recycleOpexCost + captureOpexCost + storageOpexCost + transportOpexCost) / 1e6,
          netCashFlow: monthlyCF / 1e6,
          cumulativeCF: cumulativeCF / 1e6,
          co2Stored: co2Stored,
          recycleFraction: recycleFrac * 100,
        });
      }
    }

    const projectNpv = npvCashFlows / 1e6;
    const pir = totalCapex > 0 ? projectNpv / (totalCapex / 1e6) : Infinity;

    // Breakeven oil price (binary search)
    let beLow = 0, beHigh = 200, bePrice = 0;
    for (let i = 0; i < 50; i++) {
      bePrice = (beLow + beHigh) / 2;
      let testNpv = -totalCapex;
      for (let m = 1; m <= months; m++) {
        const df = Math.pow(1 + dr, -(m - 0.5) / 12);
        const testNetPrice = bePrice - p.oilDiff;
        const testEffRatio = getEffectiveCo2OilRatio(m);
        const testEorProd = totalInjPerMonth / testEffRatio;
        const testOilRev = testEorProd * testNetPrice;
        const testSev = testOilRev * sevTaxRate;
        const recycleFrac = getRecycleFraction(m);
        const netNew = totalInjPerMonth * (1 - recycleFrac);
        const recycled = totalInjPerMonth * recycleFrac;
        const stored = netNew;
        const yr = Math.ceil(m / 12);
        let testCredit = 0;
        if (p.creditEnabled && yr <= p.creditYears) testCredit = stored * p.creditTotal;
        let testCo2Cost = p.co2Price > 0 ? 0 : netNew * Math.abs(p.co2Price);
        let testCo2Rev = p.co2Price > 0 ? netNew * p.co2Price : 0;
        const testCF = testOilRev + testCredit + testCo2Rev - testCo2Cost
          - testEorProd * p.prodOpex - testEorProd * p.oilTransport - testSev
          - recycled * p.recycleOpex - netNew * p.captureOpex - stored * p.storageOpex - netNew * p.transportOpex;
        testNpv += testCF * df;
      }
      if (testNpv / 1e6 > 0) beHigh = bePrice;
      else beLow = bePrice;
    }

    const totalProduction = totalActualProduction;
    const annualProduction = totalActualProduction / p.producingYears;
    const annualCO2Stored = totalCO2Stored / p.producingYears;
    const totalOpex = totalOilOpex + totalOilTransportCost + totalSeveranceTaxCost
      + totalCO2PurchaseCost + totalRecycleOpexCost + totalCaptureOpexCost
      + totalStorageOpexCost + totalTransportOpexCost;
    const totalRevenue = totalOilRevenue + totalCO2CreditRevenue;

    // IRR calculation (bisection on discount rate where NPV = 0) - allow negative IRR
    let irrLow = -0.99, irrHigh = 5.0, irr = 0;
    const cfArray = [-totalCapex];
    for (let m = 1; m <= months; m++) {
      const yr = Math.ceil(m / 12);
      const irrEffRatio = getEffectiveCo2OilRatio(m);
      const irrEorProd = totalInjPerMonth / irrEffRatio;
      const recycleFrac = getRecycleFraction(m);
      const freshCO2_ = totalInjPerMonth;
      const recycledCO2_ = freshCO2_ * recycleFrac;
      const netNewCO2_ = freshCO2_ * (1 - recycleFrac);
      const co2Stored_ = netNewCO2_;
      const oilRev_ = irrEorProd * netOilPrice;
      let creditRev_ = 0;
      if (p.creditEnabled && yr <= p.creditYears) {
        const inflFactor_ = p.creditInflation ? Math.pow(1 + p.creditInflationRate / 100, yr - 1) : 1;
        creditRev_ = co2Stored_ * p.creditTotal * inflFactor_;
      }
      let co2PurchaseCost_ = p.co2Price > 0 ? 0 : netNewCO2_ * Math.abs(p.co2Price);
      let co2ReceiptRev_ = p.co2Price > 0 ? netNewCO2_ * p.co2Price : 0;
      const cf_ = oilRev_ + creditRev_ + co2ReceiptRev_ - co2PurchaseCost_
        - irrEorProd * p.prodOpex - irrEorProd * p.oilTransport - oilRev_ * sevTaxRate
        - recycledCO2_ * p.recycleOpex - netNewCO2_ * p.captureOpex - co2Stored_ * p.storageOpex - netNewCO2_ * p.transportOpex;
      cfArray.push(cf_);
    }
    
    // Check if project ever generates enough positive cash flow to recover CAPEX
    const totalCF = cfArray.reduce((sum, cf) => sum + cf, 0);
    if (totalCF <= 0) {
      // Project never generates net positive cash flow - IRR is undefined
      irr = -1; // Will display as "< -99%"
    } else {
      // First check if IRR is even in searchable range
      // At irrLow=-0.99, what's the NPV?
      let testNpvLow = 0;
      for (let m = 0; m < cfArray.length; m++) {
        testNpvLow += cfArray[m] / Math.pow(1 + irrLow, m / 12);
      }
      
      if (testNpvLow < 0) {
        // Even at -99% discount, NPV is negative - project doesn't recover CAPEX
        irr = -1; // Display as "< -99%"
      } else {
        // Normal binary search - IRR exists in range
        for (let i = 0; i < 100; i++) {
          irr = (irrLow + irrHigh) / 2;
          let testNpv = 0;
          for (let m = 0; m < cfArray.length; m++) {
            const discountFactor = irr > -1 ? Math.pow(1 + irr, m / 12) : 1;
            testNpv += cfArray[m] / discountFactor;
          }
          if (testNpv > 0) irrLow = irr; else irrHigh = irr;
        }
      }
    }
    const projectIrr = totalCapex > 0 ? irr * 100 : Infinity;

    // LCOO: Levelized Cost of Oil = (total costs - non-oil revenue offsets) / total barrels
    // Non-oil revenue: 45Q credits + CO₂ receipt payments reduce the effective cost of producing oil
    const totalNonOilRevenue = totalCO2CreditRevenue + totalCO2ReceiptRevenue;
    const lcoo = totalProduction > 0 ? (totalCapex + totalOpex - totalNonOilRevenue) / totalProduction : 0;

    // After-Tax LCOO calculation (when tax calc enabled)
    // Tax benefits that reduce effective cost:
    // 1. IDC deduction: idcPct × wellCapex × combinedTaxRate (Year 1 expense)
    // 2. Depreciation shield: (1 - idcPct) × wellCapex × combinedTaxRate (spread over MACRS schedule)
    // 3. Depletion allowance: depletionPct × grossOilRevenue × combinedTaxRate
    // 4. Section 43 EOR Credit: 15% × qualifiedCosts (if oil price < threshold)
    // Note: 45Q credits are NOT taxable, they directly reduce tax liability
    
    let afterTaxLcoo = lcoo;
    let taxShieldTotal = 0;
    let section43CreditTotal = 0;
    
    if (p.enableTaxCalc && totalProduction > 0) {
      const wellCapex = (p.injWellCost * p.injWellCount) + (p.prodWellCost * p.prodWellCount) + (p.retrofitCostPerWell * p.retrofitWellCount);
      const taxRate = p.combinedTaxRate;
      
      // IDC deduction shield (immediate expensing of intangible drilling costs)
      const idcShield = wellCapex * (p.idcPct / 100) * taxRate;
      
      // TDC depreciation shield (simplified - assume PV of MACRS ~85% of nominal due to time value)
      const tdcShield = wellCapex * (1 - p.idcPct / 100) * taxRate * 0.85;
      
      // Depletion allowance shield (15% of gross oil revenue is tax-free)
      const grossOilRevenue = totalOilRevenue;
      const depletionShield = grossOilRevenue * (p.depletionAllowance / 100) * taxRate;
      
      // Section 43 EOR Credit (if enabled and oil price below threshold)
      // 15% of qualified EOR costs (CAPEX + tertiary injectant costs)
      if (p.section43Enabled && netOilPrice < p.section43PriceThreshold) {
        // Phase-out calculation: credit reduces by (price - threshold) / 6, eliminated at threshold + 6
        const phaseOutRatio = Math.max(0, 1 - (netOilPrice - (p.section43PriceThreshold - 6)) / 6);
        const qualifiedCosts = totalCapex; // Simplified: all CAPEX qualifies
        section43CreditTotal = qualifiedCosts * 0.15 * phaseOutRatio;
      }
      
      taxShieldTotal = idcShield + tdcShield + depletionShield + section43CreditTotal;
      afterTaxLcoo = (totalCapex + totalOpex - totalNonOilRevenue - taxShieldTotal) / totalProduction;
    }

    // Margin: net oil price minus LCOO (per barrel profit/loss)
    const margin = netOilPrice - lcoo;
    const afterTaxMargin = netOilPrice - afterTaxLcoo;

    // Annual OPEX for the bar
    const annualOpex = totalOpex / p.producingYears;

    return {
      projectNpv,
      pir,
      projectIrr,
      breakevenOil: bePrice,
      totalCapex: totalCapex / 1e6,
      totalOpex: totalOpex / 1e6,
      annualOpex: annualOpex / 1e6,
      totalRevenue: totalRevenue / 1e6,
      totalOilRevenue: totalOilRevenue / 1e6,
      totalCO2CreditRevenue: totalCO2CreditRevenue / 1e6,
      annualProduction,
      totalProduction,
      totalCO2Injected: totalCO2Injected / 1e6,
      totalCO2Stored: totalCO2Stored / 1e6,
      annualCO2Stored: annualCO2Stored / 1e6,
      lifetimeCo2OilRatio: totalProduction > 0 ? (totalCO2Injected / totalProduction) : 0, // lifetime average t CO₂/bbl
      paybackMonths: paybackMonth,
      paybackYears: paybackMonth ? (paybackMonth / 12).toFixed(1) : 'N/A',
      monthlyData,
      lcoo,
      afterTaxLcoo,
      margin,
      afterTaxMargin,
      taxShieldTotal: taxShieldTotal / 1e6,
      section43CreditTotal: section43CreditTotal / 1e6,
      // For OPEX breakdown
      oilOpex: totalOilOpex / 1e6,
      oilTransportCost: totalOilTransportCost / 1e6,
      severanceTaxCost: totalSeveranceTaxCost / 1e6,
      co2PurchaseCost: totalCO2PurchaseCost / 1e6,
      recycleOpexCost: totalRecycleOpexCost / 1e6,
      captureOpexCost: totalCaptureOpexCost / 1e6,
      storageOpexCost: totalStorageOpexCost / 1e6,
      transportOpexCost: totalTransportOpexCost / 1e6,
      // CAPEX breakdown
      injWellCapex: (injWellCost * injWellCount) / 1e6,
      prodWellCapexTotal: (prodWellCost * prodWellCount) / 1e6,
      wellRetrofitCapex: (retrofitCostPerWell * retrofitWellCount) / 1e6,
      ccusCapex: (captureCapex + recycleCapex + storageCapex + transportCapex),
    };
  }, [wtiPrice, oilDiff, discountRate, producingYears, prodWellCost, prodWellCount,
    prodPerWellPerYr, injWellCost, injWellCount, injPerWellPerYr, co2Price,
    recycledCo2Cost, prodOpex, oilTransport, severanceTax, creditYears, creditTotal,
    creditEnabled, creditInflation, creditInflationRate,
    captureCapex, recycleCapex, storageCapex, transportCapex,
    captureOpex, recycleOpex, storageOpex, transportOpex, co2OilRatio, scenarioType,
    recycleMode, fixedRecycleRate, fullValueChain,
    rampMode, customRamp, customDegradation,
    retrofitCostPerWell, retrofitWellCount,
    prodProfileFlat, prodRampUpYears, prodPeakYears, prodDeclineRate,
    computedFinancing, enableTaxCalc, federalTaxRate, stateTaxRate, idcPct, bonusDepreciation, depletionAllowance,
    section43Enabled, section43PriceThreshold,
    debtPct, debtInterestRate, debtTerm]);

  // ============ PATTERN-BASED CALCULATION ============
  const calculatePatternMetrics = useCallback((overrides = {}) => {
    // Allow parameter overrides for sensitivity analysis
    const p = {
      co2OilRatio,
      wtiPrice,
      oilDiff,
      co2Price,
      creditTotal,
      creditEnabled,
      severanceTax,
      prodOpex,
      captureOpex,
      recycleOpex,
      storageOpex,
      transportOpex,
      oilTransport,
      facilitySize,
      fieldSize,
      recycleMode,
      fixedRecycleRate,
      useFixedProjectLife,
      fixedProjectLife,
      ...overrides
    };
    
    // If facilitySize or fieldSize is overridden, recalculate pattern derived values
    // Otherwise use the precomputed patternDerived
    const pd = (overrides.facilitySize !== undefined || overrides.fieldSize !== undefined)
      ? calcPatternDerivedForSize(p.facilitySize, p.fieldSize)
      : patternDerived;
    
    if (!pd || pd.maxPatterns < 1) {
      // Return safe defaults if patternDerived is invalid
      return {
        projectNpv: 0, pir: 0, projectIrr: 0, breakevenOil: 0,
        totalCapex: 0, totalOpex: 0, annualOpex: 0, totalRevenue: 0,
        totalProduction: 0, annualProduction: 0, totalCO2Injected: 0,
        totalCO2Stored: 0, annualCO2Stored: 0, lcoo: 0, margin: 0,
        afterTaxLcoo: 0, afterTaxMargin: 0, taxShieldTotal: 0,
        section43CreditTotal: 0, paybackYears: 'N/A', monthlyData: [],
        lifetimeCo2OilRatio: 0, actualProjectYears: 0, totalPatternsDeveloped: 0,
        finalActivePatterns: 0, developmentEvents: [], patternsStartedThisProject: [],
        totalFeederPipeCost: 0, cumulativeInjectors: 0, cumulativeProducers: 0,
        totalOilRevenue: 0, totalCO2CreditRevenue: 0, oilOpex: 0, oilTransportCost: 0,
        severanceTaxCost: 0, co2PurchaseCost: 0, recycleOpexCost: 0, captureOpexCost: 0,
        storageOpexCost: 0, transportOpexCost: 0, injWellCapex: 0, prodWellCapexTotal: 0,
        wellRetrofitCapex: 0, feederPipeCapex: 0, ccusCapex: 0,
      };
    }
    const netOilPrice = p.wtiPrice - p.oilDiff;
    const sevTaxRate = p.severanceTax / 100;
    // Use effective discount rate (either hurdle rate or WACC)
    const dr = computedFinancing.effectiveDiscountRate;
    
    // Pattern state: array of { startMonth, active }
    const patterns = [];
    // If fixed project life is set, use that; otherwise run until all patterns abandoned
    // Safety cap at 1000 years to prevent infinite loops
    const maxSimulationMonths = p.useFixedProjectLife ? p.fixedProjectLife * 12 : 1000 * 12;
    let lastPatternStartMonth = 0;
    
    // Initialize patterns for existing flood
    if (scenarioType === 'Existing') {
      // For existing floods, patterns must be mature (past fill + ramp phases)
      // Minimum age should be at least (fill + ramp + 1) years to ensure all are at peak or decline
      const maturityAge = patternFillYears + patternRampYears + 1; // Years to reach peak production
      const effectiveMinAge = Math.max(avgPatternAge * 0.7, maturityAge); // Ensure minimum maturity
      const effectiveMaxAge = Math.max(avgPatternAge * 1.3, maturityAge + 2); // Spread above minimum
      
      for (let i = 0; i < pd.existingPatterns; i++) {
        // Spread existing patterns from effectiveMinAge to effectiveMaxAge
        // All patterns are mature (at peak or in decline), with ages centered around avgPatternAge
        const ageRange = pd.existingPatterns > 1 ? (i / (pd.existingPatterns - 1)) : 0.5;
        const patternAge = effectiveMinAge + ageRange * (effectiveMaxAge - effectiveMinAge);
        const startMonth = -Math.round(patternAge * 12); // negative = started in past
        patterns.push({ startMonth, active: true });
      }
    } else {
      // New flood: if ramp is enabled, start with patternsPerMonth (but capped by facility capacity)
      // Otherwise, start with full capacity
      // pd.startingPatternsNew = max patterns facility can support with 100% fresh CO₂
      const initialPatternCount = usePatternRamp ? 
        Math.min(patternsPerMonth, pd.startingPatternsNew) : 
        pd.startingPatternsNew;
      for (let i = 0; i < initialPatternCount; i++) {
        patterns.push({ startMonth: 0, active: true });
      }
    }
    
    // Pattern production model: returns bbl/month for a pattern at given age (months since start)
    // Also tracks if pattern is in blowdown (no longer injecting but still producing)
    // Modified for EOR method: WAG and H&P have different production physics
    
    // Per-pattern recycle fraction based on pattern age (same S-curve as simple mode)
    const getPatternRecycleFraction = (ageMonths) => {
      // If fixed mode, use fixed rate for all patterns
      if (p.recycleMode === 'fixed') return p.fixedRecycleRate / 100;
      
      // Ramping mode: rate based on pattern age
      const ageYears = ageMonths / 12;
      if (ageYears <= 1) return 0;
      if (ageYears <= 3) return Math.min(0.10, (ageYears - 1) * 0.05);
      if (ageYears <= 6) return Math.min(0.30, 0.10 + (ageYears - 3) * 0.067);
      if (ageYears <= 10) return Math.min(0.55, 0.30 + (ageYears - 6) * 0.0625);
      if (ageYears <= 15) return Math.min(0.70, 0.55 + (ageYears - 10) * 0.03);
      if (ageYears <= 20) return Math.min(0.80, 0.70 + (ageYears - 15) * 0.02);
      return Math.min(0.85, 0.80 + (ageYears - 20) * 0.005);
    };
    
    const getPatternProduction = (ageMonths, currentMonth) => {
      if (ageMonths < 0) return { oil: 0, co2Inj: 0, waterInj: 0, co2Produced: 0, waterProduced: 0, isInjecting: false, isProducing: false, phase: 'inactive' };
      const ageYears = ageMonths / 12;
      
      // Base injection per pattern per month
      const baseInjPerMonth = injRatePerWell / 12;
      // Peak production = injection / ratio (at steady state for continuous)
      const peakProdPerMonth = baseInjPerMonth / p.co2OilRatio;
      
      // EOR METHOD SPECIFIC PHYSICS
      if (eorMethod === 'huffpuff') {
        // Huff-and-Puff: cyclic injection/soak/production from same well
        // Literature: typical cycle is 1-2 weeks injection, 1-2 weeks soak, 2-6 months production
        const cycleDays = hpInjectionDays + hpSoakDays + hpProductionDays;
        const cycleMonths = cycleDays / 30;
        const totalCycles = hpCycles;
        const totalHPDuration = cycleMonths * totalCycles;
        
        // Determine which cycle we're in and phase within cycle
        const cycleNum = Math.floor(ageMonths / cycleMonths);
        const monthInCycle = ageMonths % cycleMonths;
        const injPhaseEnd = hpInjectionDays / 30;
        const soakPhaseEnd = (hpInjectionDays + hpSoakDays) / 30;
        
        // H&P injection volume per cycle (not continuous rate)
        // Typical: 500-3000 tonnes CO2 per cycle per well
        // We inject at high rate during short injection phase
        const co2PerCycle = (injRatePerWell / 12) * (hpInjectionDays / 30); // tonnes injected per cycle
        
        // H&P production response - literature shows:
        // - Peak incremental: 50-200 bbl/day (1500-6000 bbl/month)
        // - Response depends on CO2 injected and reservoir properties
        // - Rule of thumb: 1-3 bbl oil per tonne CO2 injected (much better than flood due to miscibility)
        const hpOilPerTonneCO2 = 2.0; // bbl oil per tonne CO2 (H&P efficiency)
        const cycleOilPotential = co2PerCycle * hpOilPerTonneCO2; // total oil from this cycle
        
        // Production efficiency decreases with each cycle (diminishing returns)
        // Literature: 1st cycle ~50% of potential, declining each cycle
        const cycleEfficiency = cycleNum < totalCycles ? Math.pow(0.65, cycleNum) : 0;
        
        // Peak daily rate during production phase (declines within cycle)
        const productionDays = hpProductionDays;
        const peakDailyRate = (cycleOilPotential * cycleEfficiency) / (productionDays * 0.6); // 0.6 accounts for decline within cycle
        const peakMonthlyRate = peakDailyRate * 30;
        
        if (cycleNum >= totalCycles) {
          // All H&P cycles complete - transition to blowdown/conventional production
          const postHPAge = ageMonths - totalHPDuration;
          const blowdownProd = peakMonthlyRate * 0.15 * Math.pow(0.90, postHPAge / 12);
          // CO2 still comes out during blowdown
          const co2Produced = blowdownProd * p.co2OilRatio * 0.4;
          return { 
            oil: Math.max(blowdownProd, 100), // minimum 100 bbl/month 
            co2Inj: 0, waterInj: 0, co2Produced,
            waterProduced: blowdownProd * 0.3,
            isInjecting: false, isProducing: true, phase: 'blowdown' 
          };
        }
        
        if (monthInCycle < injPhaseEnd) {
          // Injection phase - no production, high rate injection
          const injThisMonth = co2PerCycle / (hpInjectionDays / 30); // Spread over injection period
          return { 
            oil: 0, 
            co2Inj: injThisMonth, waterInj: 0, co2Produced: 0,
            waterProduced: 0,
            isInjecting: true, isProducing: false, phase: 'huff' 
          };
        } else if (monthInCycle < soakPhaseEnd) {
          // Soak phase - no injection, no production
          return { 
            oil: 0, 
            co2Inj: 0, waterInj: 0, co2Produced: 0,
            waterProduced: 0,
            isInjecting: false, isProducing: false, phase: 'soak' 
          };
        } else {
          // Production phase - high initial rate declining within cycle
          const prodPhaseStart = soakPhaseEnd;
          const prodPhaseDuration = cycleMonths - soakPhaseEnd;
          const prodProgress = (monthInCycle - prodPhaseStart) / prodPhaseDuration;
          
          // Production declines within cycle (hyperbolic-ish)
          const declineWithinCycle = Math.pow(1 - prodProgress, 0.5); // Square root decline
          const cycleProd = peakMonthlyRate * cycleEfficiency * declineWithinCycle;
          
          // CO2 produced increases with cycle number (more CO2 in reservoir over time)
          const co2ReturnFrac = 0.25 + cycleNum * 0.12; // 25% first cycle, 37% second, etc.
          const co2Produced = co2PerCycle * co2ReturnFrac * (1 - prodProgress * 0.3) / prodPhaseDuration;
          return { 
            oil: cycleProd, 
            co2Inj: 0, waterInj: 0, 
            co2Produced,
            waterProduced: cycleProd * 0.2, // Some formation water
            isInjecting: false, isProducing: true, phase: 'puff' 
          };
        }
      } else if (eorMethod === 'wag') {
        // WAG: alternating water and CO2 injection
        // Key insight: WAG improves sweep efficiency, so we need LESS CO2 per barrel
        // The user's p.co2OilRatio is for continuous injection
        // The user's co2OilRatio is for continuous injection
        // WAG achieves the same production with less CO2 (water does some displacement work)
        
        const fullCycleMonths = wagCycleMonths * (1 + wagRatio); // CO2 phase + water phase
        const monthInCycle = ageMonths % fullCycleMonths;
        const co2PhaseEnd = wagCycleMonths;
        const declineStart = patternFillYears + patternRampYears + patternPeakYears;
        
        // WAG efficiency: achieves same oil with less CO2
        // Literature shows WAG can reduce CO2 requirements by 15-30% for same recovery
        const wagEfficiencyBoost = 1.20; // 20% less CO2 needed per barrel
        const wagCO2OilRatio = p.co2OilRatio / wagEfficiencyBoost; // e.g., 1.0 becomes 0.83
        
        // CO2 fraction of cycle (time-based)
        const co2FractionOfCycle = wagCycleMonths / fullCycleMonths; // e.g., 0.5 for 1:1 ratio
        
        // During CO2 phase, inject at full rate; during water phase, no CO2
        // Cycle-averaged CO2 injection = full rate * fraction of time in CO2 phase
        // But we inject at full intensity during CO2 phase, just less often
        const avgCo2InjPerMonth = baseInjPerMonth * co2FractionOfCycle;
        
        // Production based on WAG-adjusted ratio and the cycle-averaged CO2 injection
        // More CO2 efficiency means same injection gives more oil
        const wagPeakProdPerMonth = avgCo2InjPerMonth / wagCO2OilRatio;
        
        // This should give SIMILAR production to continuous:
        // Continuous: baseInjPerMonth / p.co2OilRatio
        // WAG: (baseInjPerMonth * 0.5) / (p.co2OilRatio / 1.2) = baseInjPerMonth * 0.5 * 1.2 / p.co2OilRatio
        //    = baseInjPerMonth * 0.6 / p.co2OilRatio (about 60% of continuous with 1:1 WAG)
        // 
        // But WAG can run MORE patterns (2x for 1:1), so total field production is similar
        // And total CO2 used is less (better efficiency + staggering)
        
        // Phase-based production with WAG modifications
        let baseProd;
        if (ageYears < patternFillYears) {
          const fillProgress = ageYears / patternFillYears;
          baseProd = wagPeakProdPerMonth * (0.05 + 0.25 * fillProgress);
        } else if (ageYears < patternFillYears + patternRampYears) {
          const rampProgress = (ageYears - patternFillYears) / patternRampYears;
          baseProd = wagPeakProdPerMonth * (0.30 + 0.70 * rampProgress);
        } else if (ageYears < declineStart) {
          baseProd = wagPeakProdPerMonth;
        } else {
          const declineYears = ageYears - declineStart;
          // WAG has slower decline due to better sweep
          const wagDeclineRate = patternDeclineRate * 0.85;
          const declineFactor = Math.pow(1 - wagDeclineRate / 100, declineYears);
          baseProd = wagPeakProdPerMonth * Math.max(declineFactor, 0.05);
        }
        
        // Check if pattern should stop injecting (blowdown)
        const declineYears = Math.max(0, ageYears - declineStart);
        const wagDeclineRate = patternDeclineRate * 0.85;
        const currentDeclineFactor = Math.pow(1 - wagDeclineRate / 100, declineYears);
        const inBlowdown = ageYears >= declineStart && currentDeclineFactor < patternAbandonmentPct / 100;
        
        if (inBlowdown) {
          // Blowdown: still producing but no injection
          const co2Produced = baseProd * wagCO2OilRatio * getPatternRecycleFraction(ageMonths);
          const waterProduced = baseProd * 0.6;
          return {
            oil: baseProd,
            co2Inj: 0,
            waterInj: 0,
            co2Produced,
            waterProduced,
            isInjecting: false,
            isProducing: true,
            phase: 'blowdown'
          };
        }
        
        // Water injection during water phase (cycle-averaged)
        const waterFractionOfCycle = 1 - co2FractionOfCycle;
        const avgWaterInj = baseInjPerMonth * wagRatio * waterFractionOfCycle;
        
        // CO2 produced comes back with oil production
        const co2Produced = baseProd * wagCO2OilRatio * getPatternRecycleFraction(ageMonths);
        
        // Water produced - formation water + fraction of injected water returning
        const waterBreakthroughFrac = Math.min(0.8, ageYears * 0.05);
        const waterProduced = (baseProd * 0.5) + (avgWaterInj * waterBreakthroughFrac * 0.5);
        
        // Determine current phase for display
        const isWaterPhase = monthInCycle >= co2PhaseEnd;
        
        return {
          oil: baseProd,
          co2Inj: avgCo2InjPerMonth,
          waterInj: avgWaterInj,
          co2Produced,
          waterProduced,
          isInjecting: true,
          isProducing: true,
          phase: isWaterPhase ? 'water' : 'co2'
        };
      } else {
        // Continuous CO2 injection (original model)
        let baseProd;
        const declineStart = patternFillYears + patternRampYears + patternPeakYears;
        
        if (ageYears < patternFillYears) {
          const fillProgress = ageYears / patternFillYears;
          baseProd = peakProdPerMonth * (0.05 + 0.25 * fillProgress);
        } else if (ageYears < patternFillYears + patternRampYears) {
          const rampProgress = (ageYears - patternFillYears) / patternRampYears;
          baseProd = peakProdPerMonth * (0.30 + 0.70 * rampProgress);
        } else if (ageYears < declineStart) {
          baseProd = peakProdPerMonth;
        } else {
          const declineYears = ageYears - declineStart;
          const declineFactor = Math.pow(1 - patternDeclineRate / 100, declineYears);
          baseProd = peakProdPerMonth * Math.max(declineFactor, 0.05);
        }
        
        // Check if pattern should stop injecting (production dropped to abandonment %)
        // Pattern continues producing in "blowdown" but no longer injects CO2
        const declineYears = Math.max(0, ageYears - declineStart);
        const currentDeclineFactor = Math.pow(1 - patternDeclineRate / 100, declineYears);
        const inBlowdown = ageYears >= declineStart && currentDeclineFactor < patternAbandonmentPct / 100;
        
        if (inBlowdown) {
          // Blowdown: still producing but no injection
          // CO2 still comes out during blowdown - based on production rate
          const co2Produced = baseProd * p.co2OilRatio * getPatternRecycleFraction(ageMonths);
          return {
            oil: baseProd,
            co2Inj: 0,
            waterInj: 0,
            co2Produced,
            waterProduced: baseProd * 0.3, // Some formation water
            isInjecting: false,
            isProducing: true,
            phase: 'blowdown'
          };
        }
        
        // CO2 produced continuously with oil - based on recycle fraction
        const co2Produced = baseProd * p.co2OilRatio * getPatternRecycleFraction(ageMonths);
        
        return {
          oil: baseProd,
          co2Inj: baseInjPerMonth,
          waterInj: 0,
          co2Produced,
          waterProduced: baseProd * 0.3, // Formation water cut
          isInjecting: true,
          isProducing: true,
          phase: 'continuous'
        };
      }
    };
    
    // Check if pattern should stop INJECTING (but may continue producing in blowdown)
    const shouldStopInjecting = (ageMonths) => {
      if (ageMonths < 0) return false;
      const ageYears = ageMonths / 12;
      const declineStart = patternFillYears + patternRampYears + patternPeakYears;
      if (ageYears < declineStart) return false;
      const declineYears = ageYears - declineStart;
      const declineFactor = Math.pow(1 - patternDeclineRate / 100, declineYears);
      return declineFactor < patternAbandonmentPct / 100;
    };
    
    // Check if pattern is fully abandoned (no more production)
    const isPatternAbandoned = (ageMonths) => {
      if (ageMonths < 0) return false;
      const ageYears = ageMonths / 12;
      const declineStart = patternFillYears + patternRampYears + patternPeakYears;
      if (ageYears < declineStart) return false;
      const declineYears = ageYears - declineStart;
      const declineFactor = Math.pow(1 - patternDeclineRate / 100, declineYears);
      // Fully abandoned when production drops below 2% of peak
      return declineFactor < 0.02;
    };
    
    // Monthly simulation
    let totalOilRevenue = 0, totalCO2CreditRevenue = 0, totalCO2ReceiptRevenue = 0;
    let totalOilOpex = 0, totalOilTransportCost = 0, totalSeveranceTaxCost = 0;
    let totalCO2PurchaseCost = 0, totalRecycleOpexCost = 0;
    let totalCaptureOpexCost = 0, totalStorageOpexCost = 0, totalTransportOpexCost = 0;
    let npvCashFlows = 0;
    let totalProduction = 0, totalCO2Injected = 0, totalCO2Stored = 0;
    let cumulativeCO2Stored = 0; // Running cumulative for chart
    const monthlyData = [];
    let cumulativeCF = 0;
    let paybackMonth = null;
    let actualProjectMonths = 0;
    
    // Development timeline tracking
    const developmentEvents = []; // { month, type, description, cost }
    let totalFeederPipeCost = 0;
    let cumulativeInjectors = 0;
    let cumulativeProducers = 0;
    
    // Track which patterns are new this project (vs. existing)
    const patternsStartedThisProject = [];
    
    // CAPEX calculation
    // For existing floods: existing patterns have NO CAPEX (wells and feeders are sunk costs)
    // Only expansion into NEW patterns requires retrofit + feeder CAPEX
    const retrofitCost = wellDepth * retrofitCostPerFt;
    const newWellCost = wellDepth * newWellCostPerFt;
    // Blended well cost based on new wells percentage
    const blendedWellCost = (newWellsPct / 100) * newWellCost + (1 - newWellsPct / 100) * retrofitCost;
    const feederCostPerPattern = feederPipePerPattern * feederPipeCostPerMile;
    
    // For new patterns beyond existing development
    let expansionWellCapex = 0;
    let expansionFeederCapex = 0;
    
    // Initial CAPEX: CCUS infrastructure (capture, recycle, storage, transport)
    // For existing flood EOR only: CCUS infrastructure already exists (sunk cost)
    // For existing flood Full Value Chain: need capture and transport CAPEX
    // For new flood: need recycle plant, storage, and optionally capture/transport
    let ccusCapexVal = 0;
    let recycleCapexVal = 0;
    let storageCapexVal = 0;
    let captureCapexVal = 0;
    let pipelineCapexVal = 0;
    
    // Cap effective facility size to what field can actually absorb
    // maxPatterns * injRatePerWell = max CO2 the field can use at peak (before recycling kicks in)
    const maxFieldCO2Demand = pd.maxPatterns * injRatePerWell;
    const effectiveFacilitySize = Math.min(p.facilitySize, maxFieldCO2Demand);
    
    const facilityMtYr = effectiveFacilitySize / 1e6;
    const facilityDailyInj = effectiveFacilitySize / 365;
    const facilityMcfd = facilityDailyInj * 19;
    
    if (scenarioType === 'New' || (scenarioType === 'Existing' && !recycleExists)) {
      // Recycle CAPEX (only if recycle plant doesn't exist)
      if (!recycleExists) {
        if (effectiveFacilitySize < 579000) {
          recycleCapexVal = (1200 * facilityMcfd / 1e6) * 1.5;
        } else {
          recycleCapexVal = ((36000 + (((facilityMcfd / 1000) - 30) * 750)) / 1000) * 1.5;
        }
      }
      
      // Storage CAPEX - minimal, mainly MMV equipment (only for new flood or if not existing)
      if (scenarioType === 'New') {
        storageCapexVal = 0.5; // $0.5MM
      }
      
      ccusCapexVal = (recycleCapexVal + storageCapexVal) * 1e6;
    }
    // Existing flood with recycle plant: no recycle/storage CAPEX (sunk cost)
    
    // For Full Value Chain (both new and existing): add capture and transport CAPEX
    if (fullValueChain) {
      // Capture CAPEX: scale based on EFFECTIVE facility size (capped by field capacity)
      const source = CO2_SOURCES[co2SourceType] || CO2_SOURCES.ngp;
      const baseCapexPerTpa = co2SourceType === 'custom'
        ? capexFromConcentration(co2Concentration)
        : source.capexPerTpa;
      const capacityScaleFactor = Math.pow(Math.max(facilityMtYr, 0.01) / 1.0, -0.3);
      const scaledCapexPerTpa = baseCapexPerTpa * Math.min(capacityScaleFactor, 3.0);
      captureCapexVal = (scaledCapexPerTpa * effectiveFacilitySize) / 1e6; // $MM
      
      // Transport CAPEX: pipeline sized for effective facility throughput
      const pipeDiameterIn = Math.max(4, Math.min(36, 5.35 * Math.pow(Math.max(facilityMtYr, 0.01), 0.45)));
      const nominalDiameter = Math.ceil(pipeDiameterIn / 2) * 2;
      const dist = Math.max(pipelineDistance, 1);
      pipelineCapexVal = (nominalDiameter * dist * pipelineCostPerInchMile * 1.15) / 1e6; // $MM
      
      ccusCapexVal += (captureCapexVal + pipelineCapexVal) * 1e6;
    }
    
    if (scenarioType === 'New') {
      // New flood: retrofit existing wells for CO2 service (not drilling new wells)
      // The field already exists - we're converting it to CO2 EOR
      // If ramp is enabled, start with fewer patterns; otherwise start at full capacity
      const initialPatterns = usePatternRamp ? 
        Math.min(patternsPerMonth, pd.startingPatternsNew) : 
        pd.startingPatternsNew;
      const initialInjectors = initialPatterns;
      const initialProducers = Math.ceil(initialPatterns * pd.prodPerPattern);
      expansionWellCapex = (initialInjectors + initialProducers) * blendedWellCost; // Use blended cost
      expansionFeederCapex = initialPatterns * feederCostPerPattern;
      cumulativeInjectors = initialInjectors;
      cumulativeProducers = initialProducers;
      
      if (expansionWellCapex > 0) {
        const wellTypeDesc = newWellsPct === 0 ? 'Retrofit' : newWellsPct === 100 ? 'Drill' : `${newWellsPct}% new / ${100-newWellsPct}% retrofit`;
        developmentEvents.push({
          month: 0,
          type: 'wells',
          description: `${wellTypeDesc}: ${initialInjectors} injectors + ${initialProducers} producers`,
          cost: expansionWellCapex,
          injectors: initialInjectors,
          producers: initialProducers,
        });
      }
      if (expansionFeederCapex > 0) {
        developmentEvents.push({
          month: 0,
          type: 'feeder',
          description: `Install ${(initialPatterns * feederPipePerPattern).toFixed(1)} mi feeder pipeline`,
          cost: expansionFeederCapex,
          patterns: initialPatterns,
        });
      }
      
      for (let i = 0; i < initialPatterns; i++) {
        patternsStartedThisProject.push(0);
      }
    } else {
      // Existing flood: existing patterns have no CAPEX (sunk costs)
      // Track existing well counts for display purposes only
      cumulativeInjectors = pd.existingPatterns;
      cumulativeProducers = Math.ceil(pd.existingPatterns * pd.prodPerPattern);
      // No development events - infrastructure already exists
    }
    
    totalFeederPipeCost = expansionFeederCapex;
    const initialCapex = ccusCapexVal + expansionWellCapex + expansionFeederCapex;
    let totalCapex = initialCapex;
    
    cumulativeCF = -initialCapex;
    npvCashFlows = -initialCapex;
    
    // Store all monthly cash flows for accurate IRR calculation
    const allMonthlyCF = [];
    
    // For H&P, use half-month steps to capture short phases; otherwise monthly
    const stepSize = eorMethod === 'huffpuff' ? 0.5 : 1;
    const maxSteps = Math.ceil(maxSimulationMonths / stepSize);
    
    for (let step = 1; step <= maxSteps; step++) {
      const m = step * stepSize; // Current time in months
      if (m > maxSimulationMonths) break;
      
      const year = Math.ceil(m / 12);
      const discountFactor = Math.pow(1 + dr, -(m - 0.5 * stepSize) / 12);
      
      // Calculate total field injection and production this period
      let fieldInjection = 0;
      let fieldProduction = 0;
      let activePatternCount = 0;
      let fieldRecycledCO2 = 0; // Recycled portion of injection (based on pattern age)
      let fieldCO2Produced = 0; // CO2 produced (comes back with oil)
      let fieldNetNewCO2 = 0;
      let fieldCO2CapacityNeeded = 0; // For pattern activation - includes WAG water phase reservation
      
      // Track patterns in different states
      let injectingPatternCount = 0;
      let fieldWaterInjection = 0; // For WAG tracking
      let fieldWaterProduced = 0; // For WAG tracking
      let patternsInHuff = 0, patternsInSoak = 0, patternsInPuff = 0; // For H&P tracking
      
      for (let i = 0; i < patterns.length; i++) {
        const pat = patterns[i];
        if (!pat.active) continue;
        const ageMonths = m - pat.startMonth;
        
        // Check for full abandonment (no more production) - only for continuous/WAG
        // H&P has its own lifecycle
        if (eorMethod !== 'huffpuff' && isPatternAbandoned(ageMonths)) {
          pat.active = false;
          continue;
        }
        
        // For H&P, check if all cycles complete and blowdown finished
        if (eorMethod === 'huffpuff') {
          const cycleDays = hpInjectionDays + hpSoakDays + hpProductionDays;
          const cycleMonths = cycleDays / 30;
          const totalHPDuration = cycleMonths * hpCycles;
          const postHPAge = ageMonths - totalHPDuration;
          if (postHPAge > 24) { // 2 years of blowdown max
            pat.active = false;
            continue;
          }
        }
        
        activePatternCount++;
        
        // Get production/injection for this pattern based on EOR method
        const patResult = getPatternProduction(ageMonths, m);
        fieldProduction += patResult.oil;
        
        // Track CO2 produced (comes back with oil) - for CO2 balance chart
        if (patResult.co2Produced > 0) {
          fieldCO2Produced += patResult.co2Produced;
        }
        
        // Track water produced
        if (patResult.waterProduced > 0) {
          fieldWaterProduced += patResult.waterProduced;
        }
        
        // Track injection
        if (patResult.isInjecting) {
          injectingPatternCount++;
          const patRecycleFrac = getPatternRecycleFraction(ageMonths);
          
          // CO2 injection - for continuous/WAG, recycle is based on pattern age
          if (patResult.co2Inj > 0) {
            const patRecycled = patResult.co2Inj * patRecycleFrac;
            const patNetNew = patResult.co2Inj * (1 - patRecycleFrac);
            fieldInjection += patResult.co2Inj;
            fieldRecycledCO2 += patRecycled; // Recycled portion of injection (for recycle fraction calc)
            fieldNetNewCO2 += patNetNew;
            
            // For capacity planning with staggered WAG:
            // Patterns are staggered so only 1/(1+wagRatio) are in CO2 phase at once
            // But we use cycle-averaged injection, so capacity = averaged demand
            // The stagger multiplier is already applied in startingPatternsNew
            fieldCO2CapacityNeeded += patNetNew;
          }
          
          // Water injection (WAG)
          if (patResult.waterInj > 0) {
            fieldWaterInjection += patResult.waterInj;
          }
        }
        
        // Track H&P phases
        if (patResult.phase === 'huff') patternsInHuff++;
        if (patResult.phase === 'soak') patternsInSoak++;
        if (patResult.phase === 'puff') patternsInPuff++;
      }
      
      // Facility supplies FRESH CO2, capped at facility size
      // But total injection = fresh + recycled, which can exceed facility capacity!
      const facilityFreshCap = p.facilitySize / 12; // Monthly fresh CO2 from facility
      
      // Fresh CO2 needed = total demand - what can be recycled
      // If fresh demand exceeds facility capacity, we're constrained
      const freshCO2Needed = fieldNetNewCO2;
      const freshCO2Supplied = Math.min(freshCO2Needed, facilityFreshCap);
      
      // If we can't get enough fresh CO2, scale down operations
      const freshScale = freshCO2Needed > 0 ? freshCO2Supplied / freshCO2Needed : 1;
      
      // Actual injection = (recycled + fresh supplied), scaled if constrained
      // When fresh is constrained, recycle is also proportionally reduced
      const actualRecycled = fieldRecycledCO2 * freshScale;
      const actualInjection = freshCO2Supplied + actualRecycled;
      
      // Net new CO2 (stored) = fresh supplied
      const netNewCO2 = freshCO2Supplied;
      const co2Stored = netNewCO2;
      
      // Scale production proportionally if constrained
      const scaledProduction = fieldProduction * freshScale;
      
      // For spare capacity calculation (pattern activation)
      const spareCapacity = (facilityFreshCap - freshCO2Supplied) * 12; // annualized
      
      // Field-average recycle fraction for display
      const avgRecycleFrac = actualInjection > 0 ? actualRecycled / actualInjection : 0;
      
      // Check if we should activate new patterns
      // Key constraint: facility CO2 capacity limits fresh CO2 supply
      // As patterns mature and recycle more, they need less fresh CO2, freeing capacity
      let monthlyCapex = 0;
      
      // Fresh CO2 capacity check:
      // - facilityFreshCap = fresh CO2 facility can supply per month
      // - fieldCO2CapacityNeeded = CO2 capacity needed (including WAG water phase reservations)
      // - A new pattern in fill phase needs ~100% fresh CO2 at injRatePerWell/12 per month
      const availableFreshCO2Annual = (facilityFreshCap - fieldCO2CapacityNeeded) * 12; // Annualize for threshold comparison
      
      // Pattern ramp control: limit how fast we can add NEW patterns during initial build-up
      // This only applies during the ramp-up phase (before reaching facility capacity)
      // Once at capacity, normal capacity-based activation takes over
      let canAddByRamp = true;
      if (usePatternRamp) {
        // Calculate how many patterns we SHOULD have by now based on ramp rate
        const targetPatternsByNow = Math.floor(m / rampIntervalMonths) * patternsPerMonth + patternsPerMonth;
        // Only allow adding if we haven't reached the ramp target yet
        canAddByRamp = patternsStartedThisProject.length < targetPatternsByNow;
      }
      
      // Add pattern if:
      // 1. Spare capacity exceeds threshold (capacity allows)
      // 2. Field has room (haven't hit max patterns)
      // 3. Ramp timing allows (if ramp is enabled)
      const canAddPattern = availableFreshCO2Annual >= activationThreshold && 
                           patterns.length < pd.maxPatterns && 
                           canAddByRamp;
      
      if (canAddPattern) {
        patterns.push({ startMonth: m, active: true });
        patternsStartedThisProject.push(m);
        lastPatternStartMonth = m; // Track for determining project end
        
        // Both existing and new floods use retrofit costs - we're always converting existing wells
        // Expansion only happens if there are undeveloped patterns in the field
        const isExpansion = scenarioType === 'Existing' && patterns.length > pd.existingPatterns;
        const isNewFloodGrowth = scenarioType === 'New';
        
        if (isExpansion || isNewFloodGrowth) {
          const newInjectors = 1;
          const newProducers = Math.ceil(pd.prodPerPattern);
          const patternWellCost = (newInjectors + newProducers) * blendedWellCost;
          const patternFeederCost = feederCostPerPattern;
          
          expansionWellCapex += patternWellCost;
          expansionFeederCapex += patternFeederCost;
          totalFeederPipeCost += patternFeederCost;
          totalCapex += patternWellCost + patternFeederCost;
          monthlyCapex += patternWellCost + patternFeederCost;
          
          cumulativeInjectors += newInjectors;
          cumulativeProducers += newProducers;
          
          const wellTypeDesc = newWellsPct === 0 ? 'Retrofit' : newWellsPct === 100 ? 'Drill' : 'Convert';
          developmentEvents.push({
            month: m,
            type: 'wells',
            description: `${wellTypeDesc} ${newInjectors} inj + ${newProducers} prod`,
            cost: patternWellCost,
            injectors: newInjectors,
            producers: newProducers,
          });
          developmentEvents.push({
            month: m,
            type: 'feeder',
            description: `Install ${feederPipePerPattern.toFixed(1)} mi feeder`,
            cost: patternFeederCost,
            patterns: 1,
          });
        }
      }
      
      // Project ends when:
      // 1. All patterns have been developed (patterns.length >= pd.maxPatterns), AND
      // 2. All patterns are abandoned (activePatternCount === 0)
      // OR if we've run for a very long time with no activity
      // UNLESS fixed project life is set - then we run for exactly that duration
      const allPatternsDeveloped = patterns.length >= pd.maxPatterns;
      const allPatternsAbandoned = activePatternCount === 0 && m > 12;
      
      if (!p.useFixedProjectLife && allPatternsDeveloped && allPatternsAbandoned) {
        actualProjectMonths = m;
        break;
      }
      
      // Safety exit: if no patterns active and none can be added, we're done (unless fixed life)
      if (!p.useFixedProjectLife && activePatternCount === 0 && !canAddPattern && m > 24) {
        actualProjectMonths = m;
        break;
      }
      
      actualProjectMonths = m;
      
      totalProduction += scaledProduction;
      totalCO2Injected += actualInjection;
      totalCO2Stored += co2Stored;
      
      // Revenue
      const oilRev = scaledProduction * netOilPrice;
      totalOilRevenue += oilRev;
      
      // 45Q Credit (facility-level clock)
      let creditRev = 0;
      if (p.creditEnabled && year <= creditYears) {
        const inflationFactor = creditInflation ? Math.pow(1 + creditInflationRate / 100, year - 1) : 1;
        creditRev = co2Stored * p.creditTotal * inflationFactor;
      }
      totalCO2CreditRevenue += creditRev;
      
      // CO2 costs/revenue
      let co2PurchaseCost = 0, co2ReceiptRevenue = 0;
      if (p.co2Price > 0) {
        co2ReceiptRevenue = netNewCO2 * p.co2Price;
        totalCO2ReceiptRevenue += co2ReceiptRevenue;
      } else {
        co2PurchaseCost = netNewCO2 * Math.abs(p.co2Price);
        totalCO2PurchaseCost += co2PurchaseCost;
      }
      
      // OPEX - based on scaled production (what we actually produce)
      const oilOpexCost = scaledProduction * p.prodOpex;
      const oilTransCost = scaledProduction * p.oilTransport;
      const sevTaxCost = oilRev * sevTaxRate;
      const recycleOpexCost = actualRecycled * p.recycleOpex;
      const captureOpexCost = fullValueChain ? netNewCO2 * p.captureOpex : 0;
      const storageOpexCost = co2Stored * p.storageOpex;
      const transportOpexCost = fullValueChain ? netNewCO2 * p.transportOpex : 0;
      
      totalOilOpex += oilOpexCost;
      totalOilTransportCost += oilTransCost;
      totalSeveranceTaxCost += sevTaxCost;
      totalRecycleOpexCost += recycleOpexCost;
      totalCaptureOpexCost += captureOpexCost;
      totalStorageOpexCost += storageOpexCost;
      totalTransportOpexCost += transportOpexCost;
      
      // Track cumulative CO2 stored
      cumulativeCO2Stored += co2Stored;
      
      const monthlyCF = oilRev + creditRev + co2ReceiptRevenue
        - co2PurchaseCost - oilOpexCost - oilTransCost - sevTaxCost
        - recycleOpexCost - captureOpexCost - storageOpexCost - transportOpexCost
        - monthlyCapex; // Include expansion CAPEX (wells + feeders) in cash flow
      
      npvCashFlows += monthlyCF * discountFactor;
      cumulativeCF += monthlyCF;
      allMonthlyCF.push(monthlyCF); // Store for IRR calculation
      
      if (paybackMonth === null && cumulativeCF >= 0) {
        paybackMonth = m;
      }
      
      // Record data - every step for H&P (bi-weekly), quarterly for continuous/WAG
      const isQuarterlyPoint = Math.abs(m % 3) < 0.01 || Math.abs(m % 3 - 3) < 0.01;
      const isFirstOrLast = m <= stepSize || m >= actualProjectMonths - stepSize;
      const shouldRecord = isQuarterlyPoint || isFirstOrLast || eorMethod === 'huffpuff';
      if (shouldRecord) {
        // Calculate instantaneous CO2/Oil ratio (t/bbl) - capped for display
        const instantRatio = scaledProduction > 0 ? actualInjection / scaledProduction : p.co2OilRatio;
        const displayRatio = Math.min(instantRatio, p.co2OilRatio * 10); // cap at 10x base for display
        
        // Scale to monthly equivalent for display consistency
        const displayScale = 1 / stepSize;
        
        monthlyData.push({
          month: m,
          year,
          label: eorMethod === 'huffpuff' ? `M${m.toFixed(1)}` : `Y${year}`,
          eorProd: scaledProduction * displayScale,
          prodMultiplier: 100, // not used in pattern mode
          effectiveRatio: displayRatio,
          co2OilRatioMCF: displayRatio * 19.25,
          oilRevenue: oilRev / 1e6 * displayScale,
          creditRevenue: creditRev / 1e6 * displayScale,
          co2ReceiptRevenue: co2ReceiptRevenue / 1e6 * displayScale,
          totalRevenue: (oilRev + creditRev + co2ReceiptRevenue) / 1e6 * displayScale,
          totalCosts: (co2PurchaseCost + oilOpexCost + oilTransCost + sevTaxCost + recycleOpexCost + captureOpexCost + storageOpexCost + transportOpexCost) / 1e6 * displayScale,
          netCashFlow: monthlyCF / 1e6 * displayScale,
          cumulativeCF: cumulativeCF / 1e6,
          co2Stored: co2Stored * displayScale,
          co2StoredCumulative: cumulativeCO2Stored,
          co2Injection: actualInjection * displayScale,
          co2Fresh: freshCO2Supplied * displayScale, // Fresh CO2 from facility
          co2Recycled: actualRecycled * displayScale, // Recycled CO2 (portion of injection)
          co2Produced: fieldCO2Produced * displayScale, // CO2 produced (comes back with oil)
          waterInjection: fieldWaterInjection * displayScale, // For WAG
          waterProduced: fieldWaterProduced * displayScale, // For WAG
          recycleFraction: avgRecycleFrac * 100,
          activePatterns: patterns.filter(p => p.active).length,
          totalPatterns: patterns.length,
          cumulativeInjectors,
          cumulativeProducers,
          monthlyCapex: monthlyCapex / 1e6 * displayScale,
          // EOR method phase tracking
          eorMethod,
          patternsInHuff,
          patternsInSoak,
          patternsInPuff,
          injectingPatterns: injectingPatternCount,
        });
      }
    }
    
    const actualYears = actualProjectMonths / 12;
    const totalOpex = totalOilOpex + totalOilTransportCost + totalSeveranceTaxCost + totalCO2PurchaseCost + totalRecycleOpexCost + totalCaptureOpexCost + totalStorageOpexCost + totalTransportOpexCost;
    const totalRevenue = totalOilRevenue + totalCO2CreditRevenue + totalCO2ReceiptRevenue;
    const projectNpv = npvCashFlows / 1e6;
    const pir = totalCapex > 0 ? projectNpv / (totalCapex / 1e6) : Infinity;
    
    // IRR calculation using all monthly cash flows - allow negative IRR
    let irr = 0;
    let irrConverged = false;
    
    // For IRR, we need some initial investment. If initialCapex is 0 (existing flood),
    // use totalCapex which includes any expansion costs, or treat as infinite return
    const irrCapex = initialCapex > 0 ? initialCapex : totalCapex;
    
    // Check for zero/near-zero CAPEX first (existing flood with no expansion)
    // Threshold: $0.1MM = $100,000 - below this is effectively zero for display purposes
    const effectivelyZeroCapex = irrCapex < 100000;
    
    if (effectivelyZeroCapex && allMonthlyCF.length > 0) {
      const totalCF = allMonthlyCF.reduce((sum, cf) => sum + cf, 0);
      if (totalCF > 0) {
        irr = Infinity; // Positive cash flow with no investment = infinite return
      } else {
        irr = 0; // No investment, no return
      }
    } else if (!effectivelyZeroCapex && allMonthlyCF.length > 0) {
      // Check if project ever generates positive cash flow
      const totalCF = allMonthlyCF.reduce((sum, cf) => sum + cf, 0);
      
      if (totalCF <= 0) {
        // Project never generates positive cash flow - IRR is undefined/very negative
        // This means cumulative cash flow never goes positive, so there's no rate where NPV=0
        irr = -1; // Will display as "< -99%"
      } else {
        // Binary search for IRR - search range includes negative rates
        // IRR is bounded: can't be below -100% (mathematically undefined)
        let low = -0.99, high = 10.0; // -99% to 1000%
        
        // First check if IRR is even in our range
        // At low=-0.99, what's the NPV?
        let testNpvLow = -irrCapex;
        for (let m = 0; m < allMonthlyCF.length; m++) {
          testNpvLow += allMonthlyCF[m] / Math.pow(1 + low, (m + 1) / 12);
        }
        
        if (testNpvLow < 0) {
          // Even at -99% discount rate, NPV is still negative
          // This means project doesn't recover CAPEX even in nominal terms
          irr = -1; // Display as "< -99%"
        } else {
          // Normal binary search
          for (let i = 0; i < 100; i++) {
            const mid = (low + high) / 2;
            let testNpv = -irrCapex;
            for (let m = 0; m < allMonthlyCF.length; m++) {
              const cf = allMonthlyCF[m];
              const discountFactor = mid > -1 ? Math.pow(1 + mid, (m + 1) / 12) : 1;
              testNpv += cf / discountFactor;
            }
            if (testNpv > 0) low = mid;
            else high = mid;
          }
          irr = (low + high) / 2;
          irrConverged = Math.abs(high - low) < 0.001;
        }
      }
    }
    
    // Breakeven oil price
    let bePrice = netOilPrice;
    if (totalProduction > 0) {
      const nonOilRevenue = totalCO2CreditRevenue + totalCO2ReceiptRevenue;
      const netCosts = totalCapex + totalOpex - nonOilRevenue;
      bePrice = netCosts / totalProduction + oilDiff;
    }
    
    // LCOO
    const totalNonOilRevenue = totalCO2CreditRevenue + totalCO2ReceiptRevenue;
    const lcoo = totalProduction > 0 ? (totalCapex + totalOpex - totalNonOilRevenue) / totalProduction : 0;
    const margin = netOilPrice - lcoo;
    
    // After-tax LCOO calculation (same logic as simple mode)
    let afterTaxLcoo = lcoo;
    let afterTaxMargin = margin;
    let taxShieldTotal = 0;
    let section43CreditTotal = 0;
    
    if (enableTaxCalc && totalProduction > 0) {
      const combinedTaxRate = computedFinancing.combinedTaxRate;
      const wellCapex = expansionWellCapex;
      const grossOilRevenue = totalOilRevenue;
      
      // IDC deduction shield (Year 1 expense)
      const idcShield = idcPct / 100 * wellCapex * combinedTaxRate;
      
      // TDC depreciation shield (PV of MACRS schedule, simplified to ~85% of value)
      const tdcShield = (1 - idcPct / 100) * wellCapex * combinedTaxRate * 0.85;
      
      // Depletion allowance shield
      const depletionShield = depletionAllowance / 100 * grossOilRevenue * combinedTaxRate;
      
      // Section 43 EOR Credit (if enabled and oil price below threshold)
      if (section43Enabled && netOilPrice < section43PriceThreshold) {
        const qualifiedCosts = wellCapex * 0.8; // ~80% of well CAPEX qualifies
        const phaseOutStart = section43PriceThreshold - 6;
        const phaseOutRatio = netOilPrice <= phaseOutStart ? 1 :
          Math.max(0, 1 - (netOilPrice - phaseOutStart) / 6);
        section43CreditTotal = 0.15 * qualifiedCosts * phaseOutRatio;
      }
      
      taxShieldTotal = idcShield + tdcShield + depletionShield + section43CreditTotal;
      afterTaxLcoo = (totalCapex + totalOpex - totalNonOilRevenue - taxShieldTotal) / totalProduction;
      afterTaxMargin = netOilPrice - afterTaxLcoo;
    }
    
    // Lifetime average CO2/oil ratio
    const lifetimeCo2OilRatio = totalProduction > 0 ? totalCO2Injected / totalProduction : co2OilRatio;
    
    // Calculate well CAPEX breakdown for display
    // For New Flood: split expansion well capex by injector/producer ratio
    // For Existing Flood: all well costs are retrofit (expansion only)
    const totalWellCount = cumulativeInjectors + cumulativeProducers;
    const injWellCapexTotal = scenarioType === 'New' && totalWellCount > 0 
      ? expansionWellCapex * (cumulativeInjectors / totalWellCount) 
      : 0;
    const prodWellCapexTotal = scenarioType === 'New' && totalWellCount > 0 
      ? expansionWellCapex * (cumulativeProducers / totalWellCount) 
      : 0;
    const retrofitCapexTotal = scenarioType === 'Existing' ? expansionWellCapex : 0;
    
    // Final IRR determination:
    // If CAPEX is effectively zero (< $100k) and cash flows are positive, IRR is infinite
    const totalCashFlow = allMonthlyCF.reduce((s,c) => s+c, 0);
    let finalIrr;
    if (totalCapex < 100000) {
      // Effectively zero CAPEX
      finalIrr = totalCashFlow > 0 ? Infinity : (totalCashFlow < 0 ? -Infinity : 0);
    } else {
      finalIrr = irr * 100;
    }
    
    return {
      projectNpv,
      pir,
      projectIrr: finalIrr,
      breakevenOil: bePrice,
      totalCapex: totalCapex / 1e6,
      totalOpex: totalOpex / 1e6,
      annualOpex: actualYears > 0 ? totalOpex / actualYears / 1e6 : 0,
      totalRevenue: totalRevenue / 1e6,
      totalProduction,
      annualProduction: actualYears > 0 ? totalProduction / actualYears : 0,
      totalCO2Injected,
      totalCO2Stored,
      annualCO2Stored: actualYears > 0 ? totalCO2Stored / actualYears / 1e6 : 0,
      lcoo,
      margin,
      afterTaxLcoo,
      afterTaxMargin,
      taxShieldTotal: taxShieldTotal / 1e6,
      section43CreditTotal: section43CreditTotal / 1e6,
      paybackYears: paybackMonth ? (paybackMonth / 12).toFixed(1) : 'N/A',
      monthlyData,
      lifetimeCo2OilRatio,
      // Pattern-specific outputs
      actualProjectYears: Math.round(actualYears * 10) / 10,
      totalPatternsDeveloped: patterns.length,
      finalActivePatterns: patterns.filter(p => p.active).length,
      // Development timeline
      developmentEvents,
      patternsStartedThisProject,
      totalFeederPipeCost: totalFeederPipeCost / 1e6,
      cumulativeInjectors,
      cumulativeProducers,
      // For revenue display
      totalOilRevenue: totalOilRevenue / 1e6,
      totalCO2CreditRevenue: totalCO2CreditRevenue / 1e6,
      // OPEX breakdown
      oilOpex: totalOilOpex / 1e6,
      oilTransportCost: totalOilTransportCost / 1e6,
      severanceTaxCost: totalSeveranceTaxCost / 1e6,
      co2PurchaseCost: totalCO2PurchaseCost / 1e6,
      recycleOpexCost: totalRecycleOpexCost / 1e6,
      captureOpexCost: totalCaptureOpexCost / 1e6,
      storageOpexCost: totalStorageOpexCost / 1e6,
      transportOpexCost: totalTransportOpexCost / 1e6,
      // CAPEX breakdown
      injWellCapex: injWellCapexTotal / 1e6,
      prodWellCapexTotal: prodWellCapexTotal / 1e6,
      wellRetrofitCapex: retrofitCapexTotal / 1e6,
      feederPipeCapex: expansionFeederCapex / 1e6,
      ccusCapex: ccusCapexVal / 1e6,
      // Detailed CCUS CAPEX breakdown
      recycleCapex: recycleCapexVal,
      storageCapex: storageCapexVal,
      captureCapex: captureCapexVal,
      pipelineCapex: pipelineCapexVal,
    };
  }, [patternDerived, calcPatternDerivedForSize, wtiPrice, oilDiff, severanceTax, discountRate, scenarioType,
      avgPatternAge, injRatePerWell, co2OilRatio, patternFillYears, patternRampYears,
      patternPeakYears, patternDeclineRate, patternAbandonmentPct, facilitySize, fieldSize,
      activationThreshold, recycleMode, fixedRecycleRate, creditEnabled, creditYears, creditTotal,
      creditInflation, creditInflationRate, co2Price, prodOpex, oilTransport,
      recycleOpex, captureOpex, storageOpex, transportOpex, fullValueChain,
      captureCapex, recycleCapex, storageCapex, transportCapex, recycleExists,
      co2SourceType, co2Concentration, pipelineDistance, pipelineCostPerInchMile,
      wellDepth, newWellCostPerFt, retrofitCostPerFt, newWellsPct, feederPipePerPattern, feederPipeCostPerMile,
      eorMethod, wagRatio, wagCycleMonths, hpInjectionDays, hpSoakDays, hpProductionDays, hpCycles,
      computedFinancing, enableTaxCalc, idcPct, depletionAllowance, section43Enabled, section43PriceThreshold,
      usePatternRamp, patternsPerMonth, rampIntervalMonths,
      eorStartYear, eorStartMonth, captureConstructionMonths, recycleConstructionMonths, pipelineConstructionMonths,
      useFixedProjectLife, fixedProjectLife]);

  // Select calculation based on model mode
  const calcs = useMemo(() => {
    if (modelMode === 'pattern') {
      return calculatePatternMetrics();
    }
    return calculateProjectMetrics();
  }, [modelMode, calculateProjectMetrics, calculatePatternMetrics]);

  // Track previous metrics
  useEffect(() => {
    if (prevMetricsRef.current) {
      setPrevMetrics(prevMetricsRef.current);
    }
    prevMetricsRef.current = {
      totalCapex: calcs.totalCapex,
      annualOpex: calcs.annualOpex,
      projectIrr: calcs.projectIrr,
      npv: calcs.projectNpv,
      lcoo: calcs.lcoo,
      margin: calcs.margin,
      annualProduction: calcs.annualProduction,
      totalProduction: calcs.totalProduction,
      annualCO2Stored: calcs.annualCO2Stored,
      totalCO2Stored: calcs.totalCO2Stored,
    };
  }, [calcs]);

  // Animation effect for development visualization
  useEffect(() => {
    if (!isAnimating) return;
    const maxMonth = calcs.monthlyData?.length > 0 ? calcs.monthlyData[calcs.monthlyData.length - 1]?.month : 120;
    if (animationMonth >= maxMonth) {
      setIsAnimating(false);
      return;
    }
    const timer = setTimeout(() => {
      setAnimationMonth(prev => Math.min(prev + 3, maxMonth)); // Advance 3 months per tick
    }, 200); // 200ms per tick
    return () => clearTimeout(timer);
  }, [isAnimating, animationMonth, calcs.monthlyData]);

  // Stop animation when leaving Development tab
  useEffect(() => {
    if (activeTab !== 'development' && isAnimating) {
      setIsAnimating(false);
    }
  }, [activeTab, isAnimating]);

  // All sensitivities now use pattern mode with overrides for accurate results

  const oilPriceSensitivity = useMemo(() => {
    const prices = [20, 30, 40, 50, 55, 60, 65, 70, 75, 80, 85, 90, 100, 110, 120];
    return prices.map(price => {
      const result = calculatePatternMetrics({ wtiPrice: price });
      return {
        price,
        npv: result.projectNpv,
      };
    });
  }, [calculatePatternMetrics]);

  const co2PriceSensitivity = useMemo(() => {
    const prices = [-30, -20, -10, 0, 10, 20, 30, 40, 50, 60, 85];
    return prices.map(price => {
      const result = calculatePatternMetrics({ co2Price: price });
      return {
        price,
        npv: result.projectNpv,
        label: price < 0 ? `Buy $${Math.abs(price)}` : price === 0 ? 'Free' : `Receive $${price}`,
      };
    });
  }, [calculatePatternMetrics]);

  // CO2/Oil Ratio sensitivity - wide range up to 2.0
  const co2RatioSensitivity = useMemo(() => {
    const ratios = [0.10, 0.15, 0.20, 0.25, 0.30, 0.40, 0.50, 0.60, 0.80, 1.00, 1.25, 1.50, 1.75, 2.00];
    return ratios.map(ratio => {
      const result = calculatePatternMetrics({ co2OilRatio: ratio });
      return {
        ratio,
        npv: result.projectNpv,
      };
    });
  }, [calculatePatternMetrics]);

  // Facility Capacity sensitivity - wide range up to 10M
  // Now uses pattern mode with facilitySize override for accurate results
  const facilityCapacitySensitivity = useMemo(() => {
    const capacities = [25000, 50000, 100000, 250000, 500000, 1000000, 2000000, 3000000, 5000000, 7500000, 10000000];
    
    return capacities.map(cap => {
      // Calculate optimal field size for this facility capacity (matching auto-update logic)
      const injPerPattern = PATTERN_TYPES[patternType]?.inj || 1;
      const patternsNeededForFacility = Math.ceil(cap / (injRatePerWell * injPerPattern));
      const sustainabilityMultiplier = 2.5;
      const optimalPatternCount = Math.ceil(patternsNeededForFacility * sustainabilityMultiplier);
      const effectiveSpacing = wellSpacing * (PATTERN_TYPES[patternType]?.acresPerPattern || 1);
      const rawOptimalFieldSize = Math.ceil((optimalPatternCount * effectiveSpacing) / fieldShapeFactor);
      
      // Round to nearest reasonable value (matching auto-update effect)
      const optimalFieldSize = rawOptimalFieldSize < 1000 
        ? Math.round(rawOptimalFieldSize / 10) * 10 
        : Math.round(rawOptimalFieldSize / 100) * 100;
      
      // Run full pattern simulation with this facility size and optimal field size
      const result = calculatePatternMetrics({ 
        facilitySize: cap,
        fieldSize: optimalFieldSize 
      });
      
      return {
        capacity: cap,
        capacityLabel: cap >= 1000000 ? `${(cap / 1000000).toFixed(1)}M` : `${(cap / 1000).toFixed(0)}k`,
        optimalFieldSize,
        npv: result.projectNpv,
        lcoo: result.lcoo,
        afterTaxLcoo: result.afterTaxLcoo,
        irr: result.projectIrr,
      };
    });
  }, [calculatePatternMetrics, injRatePerWell, patternType, wellSpacing, fieldShapeFactor]);

  // LCOO sensitivity to recycle rate
  const recycleRateSensitivity = useMemo(() => {
    const rates = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90];
    return rates.map(rate => {
      // Override to fixed recycle mode with this rate
      const result = calculatePatternMetrics({ 
        recycleMode: 'fixed',
        fixedRecycleRate: rate 
      });
      return {
        rate,
        rateLabel: `${rate}%`,
        storageRate: 100 - rate,
        lcoo: result.lcoo,
        afterTaxLcoo: result.afterTaxLcoo,
        npv: result.projectNpv,
        irr: result.projectIrr,
        totalOil: result.totalProduction / 1e6, // MMbbl
        totalCO2Injected: result.totalCO2Injected, // Mt
        totalCO2Stored: result.totalCO2Stored, // Mt
        patternsDeveloped: result.totalPatternsDeveloped,
        projectYears: result.actualProjectYears,
      };
    });
  }, [calculatePatternMetrics]);

  // Sensitivity tornado data - NPV impact of ±25% change in each variable
  // Uses pattern mode for accurate results
  const tornadoData = useMemo(() => {
    const baseNpv = calcs.projectNpv;
    const params = [
      { name: 'Oil Price', key: 'wtiPrice', base: wtiPrice },
      { name: '45Q Credit', key: 'creditTotal', base: creditTotal },
      { name: 'CO₂/Oil Ratio', key: 'co2OilRatio', base: co2OilRatio },
      { name: 'CO₂ Price', key: 'co2Price', base: co2Price },
      { name: 'Production OPEX', key: 'prodOpex', base: prodOpex },
      { name: 'Capture OPEX', key: 'captureOpex', base: captureOpex },
      { name: 'Recycle OPEX', key: 'recycleOpex', base: recycleOpex },
      { name: 'Oil Transport', key: 'oilTransport', base: oilTransport },
      { name: 'Severance Tax', key: 'severanceTax', base: severanceTax },
    ];
    return params.map(param => {
      const npvLow = calculatePatternMetrics({ [param.key]: param.base * 0.75 }).projectNpv;
      const npvHigh = calculatePatternMetrics({ [param.key]: param.base * 1.25 }).projectNpv;
      
      return { 
        name: param.name, 
        low: Math.min(npvLow, npvHigh),
        high: Math.max(npvLow, npvHigh),
        baseNpv,
        impact: Math.abs(npvHigh - npvLow)
      };
    }).sort((a, b) => b.impact - a.impact);
  }, [calcs.projectNpv, wtiPrice, creditTotal, co2OilRatio, co2Price, 
      prodOpex, captureOpex, recycleOpex, oilTransport, severanceTax, calculatePatternMetrics]);

  // CAPEX breakdown for pie chart
  const capexBreakdown = useMemo(() => {
    const items = [];
    if (calcs.injWellCapex > 0) items.push({ name: 'Injection Wells', value: calcs.injWellCapex });
    if (calcs.prodWellCapexTotal > 0) items.push({ name: 'Production Wells', value: calcs.prodWellCapexTotal });
    if (calcs.wellRetrofitCapex > 0) items.push({ name: 'Well Retrofit', value: calcs.wellRetrofitCapex });
    if (calcs.feederPipeCapex > 0) items.push({ name: 'Feeder Pipelines', value: calcs.feederPipeCapex });
    // CCUS Infrastructure breakdown (from pattern calculation)
    if (calcs.captureCapex > 0) items.push({ name: 'Capture Facility', value: calcs.captureCapex });
    if (calcs.recycleCapex > 0) items.push({ name: 'Recycle Facility', value: calcs.recycleCapex });
    if (calcs.storageCapex > 0) items.push({ name: 'Storage (MMV)', value: calcs.storageCapex });
    if (calcs.pipelineCapex > 0) items.push({ name: 'Trunk Pipeline', value: calcs.pipelineCapex });
    return items;
  }, [calcs]);

  const opexBreakdown = useMemo(() => {
    const items = [];
    if (calcs.oilOpex > 0) items.push({ name: 'Oil Production', value: calcs.oilOpex });
    if (calcs.oilTransportCost > 0) items.push({ name: 'Oil Transport', value: calcs.oilTransportCost });
    if (calcs.severanceTaxCost > 0) items.push({ name: 'Severance Tax', value: calcs.severanceTaxCost });
    if (calcs.co2PurchaseCost > 0) items.push({ name: 'CO₂ Purchase', value: calcs.co2PurchaseCost });
    if (calcs.recycleOpexCost > 0) items.push({ name: 'CO₂ Recycle', value: calcs.recycleOpexCost });
    if (calcs.captureOpexCost > 0) items.push({ name: 'CO₂ Capture', value: calcs.captureOpexCost });
    if (calcs.storageOpexCost > 0) items.push({ name: 'CO₂ Storage', value: calcs.storageOpexCost });
    if (calcs.transportOpexCost > 0) items.push({ name: 'CO₂ Transport', value: calcs.transportOpexCost });
    return items;
  }, [calcs]);

  // Monte Carlo
  const runMonteCarlo = useCallback(() => {
    setMcRunning(true);
    setTimeout(() => {
      const results = [];
      const enabledParams = Object.entries(mcParams).filter(([_, config]) => config.enabled);
      const baseValues = {
        wtiPrice, co2Price, co2OilRatio, injPerWellPerYr, prodOpex,
        captureOpex, recycleOpex, discountRate, creditTotal,
      };

      for (let i = 0; i < mcIterations; i++) {
        const randomParams = {};
        enabledParams.forEach(([key, config]) => {
          randomParams[key] = generateRandomValue(config, baseValues[key]);
        });
        const result = calculateProjectMetrics(randomParams);
        results.push({
          iteration: i,
          npv: result.projectNpv,
          breakeven: result.breakevenOil,
          ...randomParams
        });
      }

      const metricKey = mcOutputMetric === 'breakeven' ? 'breakeven' : 'npv';
      results.sort((a, b) => metricKey === 'breakeven' ? a[metricKey] - b[metricKey] : b[metricKey] - a[metricKey]);

      const values = results.map(r => r[metricKey]);
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const sorted = [...values].sort((a, b) => a - b);
      const p10 = sorted[Math.floor(sorted.length * 0.1)];
      const p50 = sorted[Math.floor(sorted.length * 0.5)];
      const p90 = sorted[Math.floor(sorted.length * 0.9)];
      const min = sorted[0], max = sorted[sorted.length - 1];
      const stdDev = Math.sqrt(values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length);

      const binCount = 30, binWidth = (max - min) / binCount;
      const histogram = Array.from({ length: binCount }, (_, i) => {
        const binMin = min + i * binWidth;
        const count = values.filter(v => v >= binMin && v < binMin + binWidth).length;
        return { bin: binMin + binWidth / 2, count, frequency: count / values.length * 100 };
      });

      const cdfPoints = 50;
      const cdf = [];
      for (let i = 0; i <= cdfPoints; i++) {
        const value = min + (i / cdfPoints) * (max - min);
        const countBelow = sorted.filter(v => v <= value).length;
        cdf.push({ value, probability: (countBelow / sorted.length) * 100 });
      }

      setMcResults({ results, stats: { mean, p10, p50, p90, min, max, stdDev }, histogram, cdf, metric: mcOutputMetric });
      setMcRunning(false);
    }, 50);
  }, [mcIterations, mcParams, mcOutputMetric, calculateProjectMetrics,
    wtiPrice, co2Price, co2OilRatio, injPerWellPerYr, prodOpex,
    captureOpex, recycleOpex, discountRate, creditTotal]);

  // Download CSV
  const downloadCSV = (data, filename) => {
    const csv = data.map(row => row.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  };

  const exportResults = () => {
    const data = [
      ['Parameter', 'Value', 'Unit'],
      ['Model Mode', modelMode === 'pattern' ? 'Pattern-Based' : 'Simple', ''],
      ['Scenario Type', scenarioType, ''],
      ['Value Chain', fullValueChain ? 'Full Chain' : 'EOR Only', ''],
      // Pattern-based params
      ...(modelMode === 'pattern' ? [
        ['Facility Size', facilitySize, 't CO₂/yr'],
        ['Field Size', fieldSize, 'acres'],
        ['Well Spacing', wellSpacing, 'acres/pattern'],
        ['Shape Factor', fieldShapeFactor, ''],
        ['Max Patterns', patternDerived.maxPatterns, '5-spots'],
        ['Pattern Fill Phase', patternFillYears, 'yrs'],
        ['Pattern Ramp Phase', patternRampYears, 'yrs'],
        ['Pattern Peak Duration', patternPeakYears, 'yrs'],
        ['Pattern Decline Rate', patternDeclineRate, '%/yr'],
        ['Pattern Abandonment', patternAbandonmentPct, '% of peak'],
        ['Activation Threshold', activationThreshold, 't/yr'],
        ...(scenarioType === 'Existing' ? [
          ['% Developed', pctDeveloped, '%'],
          ['Avg Pattern Age', avgPatternAge, 'yrs'],
        ] : []),
        ['Actual Project Life', calcs.actualProjectYears, 'yrs'],
        ['Patterns Developed', calcs.totalPatternsDeveloped, ''],
      ] : []),
      // Simple mode params
      ...(modelMode === 'simple' ? [
        ['Auto-Calc CAPEX', fullValueChain && autoCalcCapex ? 'Yes' : 'No', ''],
        ['CO₂ Source Type', fullValueChain ? (CO2_SOURCES[co2SourceType]?.label || co2SourceType) : 'N/A', ''],
        ['CO₂ Concentration', fullValueChain ? (computedCapex.co2Concentration) : 'N/A', 'vol%'],
        ['Capture CAPEX/tpa', fullValueChain ? computedCapex.capexPerTpa : 'N/A', '$/tpa'],
        ['Pipeline Distance', fullValueChain ? pipelineDistance : 'N/A', 'mi'],
        ['Pipeline Diameter', fullValueChain ? computedCapex.pipeDiameterIn : 'N/A', 'in'],
        ['Pipeline $/inch-mi', fullValueChain ? pipelineCostPerInchMile.toLocaleString() : 'N/A', '$'],
        ['Ramp Profile', rampMode === 'custom' ? 'Custom' : (scenarioType === 'New' ? 'New Flood' : 'Existing Flood'), ''],
        ['Prod Profile', prodProfileFlat ? 'Flat' : 'Ramp+Decline', ''],
        ['Prod Ramp-Up', prodProfileFlat ? 'N/A' : prodRampUpYears, 'yrs'],
        ['Prod Peak Duration', prodProfileFlat ? 'N/A' : prodPeakYears, 'yrs'],
        ['Prod Decline Rate', prodProfileFlat ? 'N/A' : prodDeclineRate, '%/yr'],
        ['Wells Retrofitted', retrofitWellCount, 'wells'],
        ['Recycle Mode', recycleMode, ''],
      ] : []),
      // Common params
      ['WTI Price', wtiPrice, '$/bbl'],
      ['CO2 Price', co2Price, '$/tonne'],
      ['CO₂/Oil Ratio (input)', co2OilRatio, 't CO₂/bbl'],
      ['CO₂/Oil Ratio (lifetime avg)', calcs.lifetimeCo2OilRatio.toFixed(3), 't CO₂/bbl'],
      ['Field Depth', wellDepth.toLocaleString(), 'ft'],
      ['New Well Cost', computedWellCosts.newWellCostMM.toFixed(2), '$MM'],
      ['Retrofit Cost/Well', computedWellCosts.retrofitCostK.toFixed(0), '$k'],
      ['Fixed Recycle Rate', fixedRecycleRate, '%'],
      // Financing
      ['Discount Mode', useHurdleRate ? 'Fixed Rate' : 'WACC', ''],
      ['Effective Discount Rate', computedFinancing.effectiveDiscountRatePct.toFixed(1), '%'],
      ...(useHurdleRate ? [] : [
        ['Debt %', debtPct, '%'],
        ['Debt Interest Rate', debtInterestRate, '%'],
        ['Cost of Equity', costOfEquity, '%'],
        ['After-Tax Cost of Debt', computedFinancing.afterTaxCostOfDebtPct.toFixed(1), '%'],
      ]),
      // Tax
      ['State', STATE_TAX_CONFIG[selectedState]?.name || selectedState, ''],
      ['Severance Tax', severanceTax, '%'],
      ['EOR Severance Rate', computedEORSeverance.toFixed(1), '%'],
      ['Tax Calc Enabled', enableTaxCalc ? 'Yes' : 'No', ''],
      ...(enableTaxCalc ? [
        ['Federal Tax Rate', federalTaxRate, '%'],
        ['State Income Tax Rate', stateTaxRate, '%'],
        ['Combined Tax Rate', computedFinancing.combinedTaxRatePct.toFixed(1), '%'],
        ['IDC %', idcPct, '%'],
        ['Bonus Depreciation', bonusDepreciation, '%'],
        ['Depletion Allowance', depletionAllowance, '%'],
      ] : []),
      // 45Q
      ['45Q Enabled', creditEnabled ? 'Yes' : 'No', ''],
      ['45Q Credit', creditTotal, '$/t'],
      ['45Q Duration', creditYears, 'yrs'],
      ['45Q Inflation', creditInflation ? 'Yes' : 'No', ''],
      ['Inflation Rate', creditInflation ? creditInflationRate : 'N/A', '%/yr'],
      // Results
      ['Project NPV', calcs.projectNpv.toFixed(2), '$MM'],
      ['Project IRR', calcs.projectIrr === Infinity ? '∞' : calcs.projectIrr === -Infinity ? '-∞' : calcs.projectIrr <= -99 ? '< -99' : calcs.projectIrr.toFixed(2), '%'],
      ['Breakeven Oil', calcs.breakevenOil.toFixed(2), '$/bbl'],
      ['LCOO (Pre-Tax)', calcs.lcoo.toFixed(2), '$/bbl'],
      ['LCOO (After-Tax)', enableTaxCalc && calcs.afterTaxLcoo != null ? calcs.afterTaxLcoo.toFixed(2) : 'N/A', '$/bbl'],
      ['Margin (Pre-Tax)', calcs.margin.toFixed(2), '$/bbl'],
      ['Margin (After-Tax)', enableTaxCalc && calcs.afterTaxMargin != null ? calcs.afterTaxMargin.toFixed(2) : 'N/A', '$/bbl'],
      ['Total Tax Shield', enableTaxCalc && calcs.taxShieldTotal != null ? calcs.taxShieldTotal.toFixed(2) : 'N/A', '$MM'],
      ['§43 EOR Credit', enableTaxCalc && section43Enabled && calcs.section43CreditTotal != null ? calcs.section43CreditTotal.toFixed(2) : 'N/A', '$MM'],
      ['PIR', calcs.pir === Infinity ? 'N/A' : calcs.pir.toFixed(2), ''],
      ['Total CAPEX', calcs.totalCapex.toFixed(2), '$MM'],
      ['Total OPEX', calcs.totalOpex.toFixed(2), '$MM'],
      ['Annual OPEX', calcs.annualOpex.toFixed(2), '$MM/yr'],
      ['Total Revenue', calcs.totalRevenue.toFixed(2), '$MM'],
      ['Annual Oil Production', (calcs.annualProduction / 1e6).toFixed(2), 'MMbbl/yr'],
      ['Total Oil Production', (calcs.totalProduction / 1e6).toFixed(1), 'MMbbl'],
      ['Annual CO2 Stored', calcs.annualCO2Stored.toFixed(2), 'Mt/yr'],
      ['Total CO2 Stored', calcs.totalCO2Stored.toFixed(2), 'Mt'],
      ['Payback', calcs.paybackYears, 'years'],
    ];
    downloadCSV(data, 'eor_model_results.csv');
  };

  // Components
  const InputField = ({ label, value, onChange, unit, step = 1, disabled = false, tooltip }) => {
    const [localValue, setLocalValue] = useState(value);
    useEffect(() => { setLocalValue(value); }, [value]);
    const handleBlur = () => { const numVal = parseFloat(localValue); if (!isNaN(numVal)) onChange(numVal); };
    const handleKeyDown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleBlur();
        e.target.blur(); // Remove focus to prevent scroll issues
      }
    };
    return (
      <div className="flex items-center justify-between py-1 group relative">
        <label className={`text-gray-700 text-xs ${disabled ? 'text-gray-400' : ''} ${tooltip ? 'cursor-help border-b border-dotted border-gray-400' : ''}`} title={tooltip}>{label}</label>
        <div className="flex items-center gap-1">
          <input type="number" value={localValue} onChange={(e) => setLocalValue(e.target.value)}
            onBlur={handleBlur} onKeyDown={handleKeyDown} step={step} disabled={disabled}
            className={`border border-gray-300 rounded px-1.5 py-0.5 text-xs font-mono w-20 text-right focus:outline-none focus:border-green-600 ${disabled ? 'bg-gray-100 text-gray-400' : 'bg-white text-gray-800'}`} />
          {unit && <span className="text-gray-500 text-xs w-12 text-left">{unit}</span>}
        </div>
      </div>
    );
  };

  const OutputRow = ({ label, value, unit, highlight = false, tooltip, delta }) => (
    <div className={`flex items-center justify-between py-1 ${highlight ? 'bg-green-50 px-1 rounded' : ''}`}>
      <span className={`text-gray-600 text-xs ${tooltip ? 'cursor-help border-b border-dotted border-gray-400' : ''}`} title={tooltip}>{label}</span>
      <div className="flex items-center gap-1">
        <span className={`font-mono text-xs ${highlight ? 'text-green-700 font-semibold' : 'text-gray-800'}`}>{value}</span>
        {delta !== undefined && delta !== null && (
          <span className={`text-xs font-mono ${delta > 0 ? 'text-green-600' : delta < 0 ? 'text-red-600' : 'text-gray-400'}`}>
            {delta > 0 ? '▲' : delta < 0 ? '▼' : ''}
          </span>
        )}
        {unit && <span className="text-gray-400 text-xs" style={{ minWidth: '40px', textAlign: 'right' }}>{unit}</span>}
      </div>
    </div>
  );

  const Section = ({ title, children }) => (
    <div className="bg-white border border-gray-200 mb-2 max-w-md">
      <div className="bg-gray-100 px-2 py-1 border-b border-gray-200">
        <h3 className="text-gray-700 font-semibold text-xs uppercase">{title}</h3>
      </div>
      <div className="p-2">{children}</div>
    </div>
  );

  const COLORS = ['#f59e0b', '#14b8a6', '#8b5cf6', '#ef4444', '#3b82f6', '#22c55e', '#f97316', '#ec4899'];

  const tabs = [
    { id: 'inputs', label: 'Inputs' },
    { id: 'results', label: 'Results' },
    { id: 'charts', label: 'Charts' },
    { id: 'development', label: 'Development' },
    { id: 'sensitivity', label: 'Sensitivity' },
    { id: 'montecarlo', label: 'Monte Carlo' },
    { id: 'assumptions', label: 'Sources' },
  ];

  const mcMetricLabel = mcOutputMetric === 'breakeven' ? 'Breakeven Oil ($/bbl)' : 'Project NPV ($MM)';

  const mcParamLabels = {
    wtiPrice: 'WTI Price',
    co2Price: 'CO₂ Price',
    co2OilRatio: 'CO₂/Oil Ratio',
    injPerWellPerYr: 'Injection/Well/Yr',
    prodOpex: 'Production OPEX',
    captureOpex: 'Capture OPEX',
    recycleOpex: 'Recycle OPEX',
    discountRate: 'Discount Rate',
    creditTotal: '45Q Credit Rate',
  };

  return (
    <div className="h-screen bg-gray-100 text-gray-800 font-sans text-sm flex flex-col overflow-hidden">
      {/* Sticky Header Block */}
      <div className="flex-shrink-0">
        {/* Header */}
        <div style={{ background: 'linear-gradient(to right, #4a5568, #2d3748)' }} className="text-white px-2 sm:px-4 py-2 flex flex-col sm:flex-row sm:items-center sm:justify-between shadow-md gap-2">
          <div className="flex items-center gap-2 sm:gap-3">
            <svg className="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
            <span className="font-semibold text-sm">EOR Model</span>
            <span className="text-gray-400 text-xs hidden sm:inline">|</span>
            <span className="text-gray-400 text-xs hidden sm:inline">CO₂ Enhanced Oil Recovery</span>
          </div>
          <div className="flex items-center gap-2 flex-wrap">
            <select value={modelMode} onChange={(e) => setModelMode(e.target.value)} className="bg-gray-700 text-white text-xs px-2 py-1 rounded border border-gray-500"
              title="Simple: direct well counts & rates. Pattern: facility-sized, 5-spot pattern development">
              <option value="simple">Simple Mode</option>
              <option value="pattern">Pattern-Based</option>
            </select>
            <select value={scenarioType} onChange={(e) => setScenarioType(e.target.value)} className="bg-gray-600 text-white text-xs px-2 py-1 rounded border border-gray-500">
              <option value="Existing">Existing Flood</option>
              <option value="New">New Flood</option>
            </select>
            <select value={fullValueChain ? 'full' : 'eor'} onChange={e => setFullValueChain(e.target.value === 'full')}
              className="text-xs bg-gray-700 border border-gray-600 rounded px-2 py-1 text-gray-200 focus:outline-none focus:border-green-500"
              title={fullValueChain ? 'Full value chain: includes capture & transport economics' : 'EOR operator only: CO₂ purchased/received at field gate'}>
              <option value="eor">EOR Only</option>
              <option value="full">Full Value Chain</option>
            </select>
            <button onClick={resetToDefaults} className="px-2 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition-colors">Reset</button>
            <button onClick={exportResults} className="px-2 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition-colors">Export</button>
          </div>
        </div>

        {/* Tabs */}
        <div className="bg-white border-b border-gray-300 px-2 sm:px-4 overflow-x-auto">
          <div className="flex items-center gap-1 min-w-max">
            {tabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                className={`px-3 sm:px-4 py-2 text-xs font-medium border-b-2 transition-colors whitespace-nowrap ${activeTab === tab.id ? 'border-green-700 text-green-800 bg-green-50' : 'border-transparent text-gray-600 hover:text-gray-800 hover:bg-gray-50'}`}>
                {tab.label}
              </button>
            ))}
          </div>
        </div>

        {/* Key Metrics Bar */}
        <div className="bg-white border-b border-gray-200 px-2 sm:px-4 py-2 overflow-x-auto shadow-sm">
          <div className="flex items-center gap-2 sm:gap-4 text-xs min-w-max">
            <span className="text-gray-400 font-medium w-10">Live</span>
            <div className="flex items-center gap-1"><span className="text-gray-500">CAPEX:</span><span className="font-semibold text-gray-800">${calcs.totalCapex.toFixed(1)}MM</span></div>
            <div className="flex items-center gap-1"><span className="text-gray-500">OPEX:</span><span className="font-semibold text-gray-800">${calcs.annualOpex.toFixed(1)}MM/yr</span></div>
            <span className="text-gray-700 hidden sm:inline">|</span>
            <div className="flex items-center gap-1"><span className="text-gray-500">IRR:</span><span className={`font-semibold ${calcs.projectIrr >= computedFinancing.effectiveDiscountRatePct ? 'text-green-600' : 'text-red-600'}`}>{calcs.projectIrr === Infinity ? '∞' : calcs.projectIrr === -Infinity ? '-∞' : calcs.projectIrr <= -99 ? '< -99%' : `${calcs.projectIrr.toFixed(1)}%`}</span></div>
            <div className="flex items-center gap-1"><span className="text-gray-500">{useHurdleRate ? 'Hurdle:' : 'WACC:'}</span><span className="font-semibold text-gray-600">{computedFinancing.effectiveDiscountRatePct.toFixed(1)}%</span></div>
            <div className="flex items-center gap-1"><span className="text-gray-500">NPV:</span><span className={`font-semibold ${calcs.projectNpv >= 0 ? 'text-green-600' : 'text-red-600'}`}>${calcs.projectNpv.toFixed(1)}MM</span></div>
            <span className="text-gray-700 hidden sm:inline">|</span>
            <div className="flex items-center gap-1">
              <span className="text-gray-500">{enableTaxCalc ? 'LCOO (AT):' : 'LCOO:'}</span>
              <span className="font-semibold text-gray-800">${(enableTaxCalc && calcs.afterTaxLcoo != null ? calcs.afterTaxLcoo : calcs.lcoo).toFixed(2)}/bbl</span>
              {enableTaxCalc && calcs.afterTaxLcoo != null && calcs.lcoo !== calcs.afterTaxLcoo && (
                <span className="text-gray-400 text-[10px]">(pre: ${calcs.lcoo.toFixed(2)})</span>
              )}
            </div>
            <div className="flex items-center gap-1">
              <span className="text-gray-500">{enableTaxCalc ? 'Margin (AT):' : 'Margin:'}</span>
              <span className={`font-semibold ${(enableTaxCalc && calcs.afterTaxMargin != null ? calcs.afterTaxMargin : calcs.margin) >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                ${(enableTaxCalc && calcs.afterTaxMargin != null ? calcs.afterTaxMargin : calcs.margin).toFixed(2)}/bbl
              </span>
            </div>
            <span className="text-gray-700 hidden sm:inline">|</span>
            <div className="flex items-center gap-1"><span className="text-gray-500">Oil:</span><span className="font-semibold text-gray-800">{(calcs.annualProduction / 1e6).toFixed(2)}MM/yr</span><span className="text-gray-400 text-[10px]">({(calcs.totalProduction / 1e6).toFixed(1)}MM tot)</span></div>
            <div className="flex items-center gap-1"><span className="text-gray-500">CO₂:</span><span className="font-semibold text-gray-800">{(calcs.annualCO2Stored).toFixed(2)}Mt/yr</span><span className="text-gray-400 text-[10px]">({calcs.totalCO2Stored.toFixed(1)}Mt tot)</span></div>
            <div className="flex items-center gap-1"><span className="text-gray-500">Ratio:</span><span className="font-semibold text-gray-800">{calcs.lifetimeCo2OilRatio.toFixed(2)} t/bbl</span></div>
          </div>
          {prevMetrics && (
            <div className="flex items-center gap-2 sm:gap-4 text-xs min-w-max mt-1 opacity-60">
              <span className="text-gray-400 font-medium w-10">Saved</span>
              <div className="flex items-center gap-1"><span className="text-gray-400">CAPEX:</span><span className="text-gray-500">${prevMetrics.totalCapex.toFixed(1)}MM</span></div>
              <div className="flex items-center gap-1"><span className="text-gray-400">OPEX:</span><span className="text-gray-500">${prevMetrics.annualOpex.toFixed(1)}MM/yr</span></div>
              <span className="text-gray-700 hidden sm:inline">|</span>
              <div className="flex items-center gap-1"><span className="text-gray-400">IRR:</span><span className="text-gray-500">{prevMetrics.projectIrr === Infinity ? '∞' : prevMetrics.projectIrr === -Infinity ? '-∞' : prevMetrics.projectIrr <= -99 ? '< -99%' : `${prevMetrics.projectIrr.toFixed(1)}%`}</span></div>
              <div className="flex items-center gap-1"><span className="text-gray-400">NPV:</span><span className="text-gray-500">${prevMetrics.npv.toFixed(1)}MM</span></div>
              <span className="text-gray-700 hidden sm:inline">|</span>
              <div className="flex items-center gap-1"><span className="text-gray-400">LCOO:</span><span className="text-gray-500">${prevMetrics.lcoo.toFixed(2)}/bbl</span></div>
              <div className="flex items-center gap-1"><span className="text-gray-400">Margin:</span><span className="text-gray-500">${prevMetrics.margin.toFixed(2)}/bbl</span></div>
              <span className="text-gray-700 hidden sm:inline">|</span>
              <div className="flex items-center gap-1"><span className="text-gray-400">Oil:</span><span className="text-gray-500">{(prevMetrics.annualProduction / 1e6).toFixed(2)}MM/yr</span><span className="text-gray-400 text-[10px]">({(prevMetrics.totalProduction / 1e6).toFixed(1)}MM tot)</span></div>
              <div className="flex items-center gap-1"><span className="text-gray-400">CO₂:</span><span className="text-gray-500">{(prevMetrics.annualCO2Stored).toFixed(2)}Mt/yr</span><span className="text-gray-400 text-[10px]">({prevMetrics.totalCO2Stored.toFixed(1)}Mt tot)</span></div>
            </div>
          )}
        </div>
      </div>{/* End header block */}

      <div ref={scrollContainerRef} className="flex-1 overflow-y-auto p-2 sm:p-3">
        {activeTab === 'inputs' && (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
            
            {/* ============ PATTERN-BASED MODE INPUTS ============ */}
            {modelMode === 'pattern' && (
              <>
                <div>
                  <Section title="EOR Method">
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="CO₂ injection strategy">Injection Method</label>
                      <select value={eorMethod} onChange={e => setEorMethod(e.target.value)}
                        className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'110px'}}>
                        <option value="continuous">Continuous</option>
                        <option value="wag">WAG</option>
                        <option value="huffpuff">Huff & Puff</option>
                      </select>
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                      {eorMethod === 'continuous' && '💨 Continuous CO₂ injection with separate injectors and producers'}
                      {eorMethod === 'wag' && '💧 Water-Alternating-Gas: alternating water and CO₂ slugs for better sweep'}
                      {eorMethod === 'huffpuff' && '🔄 Cyclic: inject CO₂, soak, then produce from same well'}
                    </div>
                  </Section>

                  <Section title="Pattern Type">
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Well pattern is determined by EOR method">Well Pattern</label>
                      <div className="text-xs font-medium text-gray-800 bg-gray-100 px-2 py-0.5 rounded">
                        {PATTERN_TYPES[patternType]?.name || patternType}
                      </div>
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                      {PATTERN_TYPES[patternType]?.desc || ''}
                    </div>
                    <div className="text-xs text-blue-600 px-1 py-0.5 mb-1" style={{fontSize:'9px'}}>
                      ℹ️ Pattern auto-selected based on EOR method
                    </div>
                    {patternType !== 'single-well' && (
                      <div className="mt-1 pt-1 border-t border-gray-200">
                        <OutputRow label="Injectors/Pattern" value={PATTERN_TYPES[patternType]?.inj || 1} unit="wells" />
                        <OutputRow label="Producers/Pattern" value={PATTERN_TYPES[patternType]?.prod || 4} unit="wells" />
                      </div>
                    )}
                    {patternType === 'single-well' && (
                      <div className="mt-1 pt-1 border-t border-gray-200">
                        <OutputRow label="Wells/Pattern" value={1} unit="well" />
                        <div className="text-xs text-gray-500 mt-1" style={{fontSize:'9px'}}>
                          Each well alternates between injection and production
                        </div>
                      </div>
                    )}
                  </Section>

                  <Section title="Capture Facility">
                    <InputField label="Facility Capacity" value={facilitySize} onChange={setFacilitySize} unit="t CO₂/yr" step={10000}
                      tooltip="Annual CO₂ capture/handling capacity. This drives field development sizing." />
                    <InputField label="Injection Rate/Well" value={injRatePerWell} onChange={setInjRatePerWell} unit="t/yr" step={5000}
                      tooltip={eorMethod === 'continuous' 
                        ? "CO₂ injection rate per well. Continuous: 1 injector takes all pattern CO₂ (~30,000 t/yr typical)."
                        : eorMethod === 'wag'
                        ? "CO₂ injection rate per well. WAG: 4 injectors share load + water phases (~10,000 t/yr per well)."
                        : "CO₂ injection rate per well. H&P: High rate during injection phase (~50,000 t/yr equivalent)."} />
                    <div className="text-xs text-gray-500 px-1 py-0.5 mb-1" style={{fontSize:'9px'}}>
                      Default: {EOR_METHOD_CONFIG[eorMethod]?.defaultInjRate.toLocaleString()} t/yr ({EOR_METHOD_CONFIG[eorMethod]?.name})
                    </div>
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Max Active Injectors" value={patternDerived.patternsNeededForFacility} unit="wells"
                        tooltip={`Facility can supply CO₂ for ${patternDerived.patternsNeededForFacility} injectors at ${(injRatePerWell/1000).toFixed(0)}k t/yr each. Additional patterns will share the CO₂ supply.`} />
                      <OutputRow label="Patterns for Facility" value={patternDerived.patternsNeededForFacility} unit={patternType === 'single-well' ? 'wells' : 'patterns'}
                        tooltip="Patterns that can operate at full injection rate simultaneously" />
                    </div>
                  </Section>

                  <Section title="Field Geometry">
                    <InputField label="Field Size" value={fieldSize} onChange={setFieldSize} unit="acres" step={40}
                      tooltip="Total field area. 1 section = 640 acres." />
                    <InputField label="Pattern Spacing" value={wellSpacing} onChange={setWellSpacing} unit="acres" step={10}
                      tooltip="Acres per 5-spot pattern. Literature: 20-80 acres. Tighter spacing = more patterns but higher drilling cost." />
                    <InputField label="Shape Factor" value={fieldShapeFactor} onChange={setFieldShapeFactor} unit="" step={0.05}
                      tooltip="Field efficiency factor (0-1). Accounts for irregular boundaries, faults, excluded zones. 1.0 = perfect rectangle." />
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Max Patterns" value={patternDerived.maxPatterns} unit={patternType === 'single-well' ? 'wells' : 'patterns'}
                        tooltip={`Maximum ${PATTERN_TYPES[patternType]?.name || 'patterns'} field can support`} />
                      <OutputRow label="Max Injectors" value={patternDerived.maxInjectors} unit="wells"
                        tooltip="Limited by field size or facility capacity" />
                      {patternType !== 'single-well' && (
                        <OutputRow label="Max Producers" value={patternDerived.maxProducers} unit="wells"
                          tooltip="~1-1.5 producers per pattern (corner wells shared)" />
                      )}
                    </div>
                    <div className={`mt-1 pt-1 border-t ${patternDerived.fieldSizeAdequate ? 'border-gray-200' : 'border-amber-300'}`}>
                      <OutputRow 
                        label="Min Optimal Field" 
                        value={patternDerived.minOptimalFieldSize.toLocaleString()} 
                        unit="acres"
                        tooltip={`Minimum field size to sustain ${patternDerived.optimalPatternCount} patterns for full facility utilization over project life. Based on ${patternDerived.patternsNeededForFacility} patterns needed × 2.5 sustainability factor.`} />
                      {!patternDerived.fieldSizeAdequate && (
                        <div className="text-xs text-amber-600 px-1 py-1 bg-amber-50 rounded mt-1" style={{fontSize:'10px'}}>
                          ⚠️ Field undersized: CAPEX scaled to {((Math.min(facilitySize, patternDerived.maxPatterns * injRatePerWell))/1000).toFixed(0)}k t/yr effective capacity (field max).
                        </div>
                      )}
                      {patternDerived.fieldSizeAdequate && (
                        <div className="text-xs text-green-600 px-1 py-0.5" style={{fontSize:'10px'}}>
                          ✓ Field size adequate for facility capacity
                        </div>
                      )}
                    </div>
                  </Section>

                  <Section title={eorMethod === 'huffpuff' ? 'H&P Cycle Parameters' : 'Pattern Lifecycle'}>
                    {eorMethod === 'huffpuff' ? (
                      <>
                        <InputField label="Injection Days" value={hpInjectionDays} onChange={setHpInjectionDays} unit="days" step={5}
                          tooltip="Days of CO₂ injection per cycle (huff phase). Typical: 10-30 days." />
                        <InputField label="Soak Days" value={hpSoakDays} onChange={setHpSoakDays} unit="days" step={5}
                          tooltip="Days to let CO₂ dissolve into oil (soak phase). Typical: 5-15 days." />
                        <InputField label="Production Days" value={hpProductionDays} onChange={setHpProductionDays} unit="days" step={10}
                          tooltip="Days of production per cycle (puff phase). Typical: 30-90 days." />
                        <InputField label="Number of Cycles" value={hpCycles} onChange={setHpCycles} unit="cycles" step={1}
                          tooltip="Total H&P cycles before transitioning to blowdown. Typical: 3-6 cycles." />
                        <div className="mt-1 pt-1 border-t border-gray-200">
                          <OutputRow label="Cycle Length" value={((hpInjectionDays + hpSoakDays + hpProductionDays) / 30).toFixed(1)} unit="months"
                            tooltip="Total duration of one complete H&P cycle" />
                          <OutputRow label="Active H&P Duration" value={((hpInjectionDays + hpSoakDays + hpProductionDays) * hpCycles / 365).toFixed(1)} unit="yrs"
                            tooltip="Total years of active H&P cycling before blowdown" />
                        </div>
                      </>
                    ) : eorMethod === 'wag' ? (
                      <>
                        <InputField label="CO₂ Slug Duration" value={wagCycleMonths} onChange={setWagCycleMonths} unit="months" step={1}
                          tooltip="Duration of CO₂ injection phase in WAG cycle. Typical: 3-6 months." />
                        <InputField label="WAG Ratio" value={wagRatio} onChange={setWagRatio} unit=":1 water" step={0.5}
                          tooltip="Ratio of water slug to CO₂ slug duration. 1:1 means equal durations. Higher = more water." />
                        <div className="mt-1 pt-1 border-t border-gray-200">
                          <OutputRow label="Full Cycle" value={(wagCycleMonths * (1 + wagRatio)).toFixed(1)} unit="months"
                            tooltip="Complete WAG cycle (CO₂ + water phases)" />
                        </div>
                        <div className="mt-2 pt-2 border-t border-gray-200">
                          <div className="text-xs text-gray-500 mb-1">Pattern Lifecycle (WAG-adjusted)</div>
                          <InputField label="Fill Phase" value={patternFillYears} onChange={setPatternFillYears} unit="yrs" step={0.5}
                            tooltip="Years for CO₂ bank to develop. WAG may be slightly longer due to water slugs." />
                          <InputField label="Ramp Phase" value={patternRampYears} onChange={setPatternRampYears} unit="yrs" step={0.5} />
                          <InputField label="Peak Duration" value={patternPeakYears} onChange={setPatternPeakYears} unit="yrs" step={1} />
                          <InputField label="Decline Rate" value={patternDeclineRate} onChange={setPatternDeclineRate} unit="%/yr" step={1}
                            tooltip="Base decline rate. WAG typically has 15% slower decline due to better sweep." />
                          <InputField label="Abandonment" value={patternAbandonmentPct} onChange={setPatternAbandonmentPct} unit="% of peak" step={5} />
                        </div>
                      </>
                    ) : (
                      <>
                        <InputField label="Fill Phase" value={patternFillYears} onChange={setPatternFillYears} unit="yrs" step={0.5}
                          tooltip="Years for CO₂ bank to develop before significant oil response. Typical: 0.5-2 years." />
                        <InputField label="Ramp Phase" value={patternRampYears} onChange={setPatternRampYears} unit="yrs" step={0.5}
                          tooltip="Years from first response to peak production. Typical: 1-3 years." />
                        <InputField label="Peak Duration" value={patternPeakYears} onChange={setPatternPeakYears} unit="yrs" step={1}
                          tooltip="Years at peak production before decline. Typical: 2-5 years." />
                        <InputField label="Decline Rate" value={patternDeclineRate} onChange={setPatternDeclineRate} unit="%/yr" step={1}
                          tooltip="Annual decline after peak. Literature: 8-15%/yr for EOR patterns." />
                        <InputField label="Abandonment" value={patternAbandonmentPct} onChange={setPatternAbandonmentPct} unit="% of peak" step={5}
                          tooltip="Production level (% of peak) when injection stops and blowdown begins. Typical: 15-25%." />
                      </>
                    )}
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label={eorMethod === 'huffpuff' ? 'Well Life (est)' : 'Single Pattern Life'} value={patternDerived.patternLifeYears.toFixed(1)} unit="yrs"
                        tooltip={eorMethod === 'huffpuff' 
                          ? `Active H&P: ${((hpInjectionDays + hpSoakDays + hpProductionDays) * hpCycles / 365).toFixed(1)}yr + Blowdown: ~2yr`
                          : `Fill: ${patternFillYears}yr + Ramp: ${patternRampYears}yr + Peak: ${patternPeakYears}yr + Decline to ${patternAbandonmentPct}%: ${patternDerived.declineYearsToAbandonment.toFixed(1)}yr`} />
                      {eorMethod !== 'huffpuff' && (
                        <OutputRow label="Decline to Aband." value={patternDerived.declineYearsToAbandonment.toFixed(1)} unit="yrs"
                          tooltip={`Years of decline from peak until production reaches ${patternAbandonmentPct}% (injection stops)`} />
                      )}
                    </div>
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                          title="Override simulated project duration with a fixed number of years (e.g., 12 years for 45Q credit life)">Fixed Project Life</label>
                        <div className="flex items-center gap-2">
                          <input 
                            type="number" 
                            defaultValue={fixedProjectLife}
                            key={`fixed-life-${fixedProjectLife}`}
                            onBlur={(e) => setFixedProjectLife(Number(e.target.value) || 1)}
                            onKeyDown={(e) => { if (e.key === 'Enter') e.target.blur(); }}
                            className="border border-gray-300 rounded px-1.5 py-0.5 text-xs font-mono w-14 text-right focus:outline-none focus:border-blue-500"
                            style={{ display: useFixedProjectLife ? 'block' : 'none' }}
                            min={1}
                            max={100}
                          />
                          <span className="text-xs font-mono text-gray-500 w-14 text-right" style={{ display: useFixedProjectLife ? 'none' : 'block' }}>{calcs.actualProjectYears?.toFixed(1) || '--'}</span>
                          <span className="text-xs text-gray-500">yrs</span>
                          <button onClick={() => {
                            const container = scrollContainerRef.current;
                            const scrollPos = container ? container.scrollTop : 0;
                            setTimeout(() => {
                              setUseFixedProjectLife(prev => !prev);
                              setTimeout(() => {
                                if (container) container.scrollTop = scrollPos;
                              }, 0);
                            }, 0);
                          }}
                            className="w-10 h-5 rounded-full transition-colors relative"
                            style={{ backgroundColor: useFixedProjectLife ? '#16a34a' : '#d1d5db' }}>
                            <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                              style={{ left: useFixedProjectLife ? '22px' : '2px' }} />
                          </button>
                        </div>
                      </div>
                      <OutputRow label="Patterns Developed" value={`${calcs.totalPatternsDeveloped || 0} / ${patternDerived.maxPatterns}`}
                        tooltip={`${calcs.totalPatternsDeveloped || 0} patterns developed out of ${patternDerived.maxPatterns} maximum`} />
                      <OutputRow label="Final Active" value={calcs.finalActivePatterns || 0} unit="patterns"
                        tooltip="Number of patterns still producing at end of project" />
                    </div>
                  </Section>
                </div>

                <div>
                  {scenarioType === 'Existing' && (
                    <Section title="Existing Field Status">
                      <InputField label="% Developed" value={pctDeveloped} onChange={setPctDeveloped} unit="%" step={10}
                        tooltip="Percentage of maximum patterns already under flood" />
                      <InputField label="Avg Pattern Age" value={avgPatternAge} onChange={setAvgPatternAge} unit="yrs" step={1}
                        tooltip="Average age of existing patterns (affects their position on decline curve and remaining project life)" />
                      <div className="mt-1 pt-1 border-t border-gray-200">
                        <OutputRow label="Existing Patterns" value={patternDerived.existingPatterns} unit="active"
                          tooltip="Number of patterns already producing" />
                        <OutputRow label="Remaining to Dev" value={patternDerived.remainingPatterns} unit="patterns"
                          tooltip={`${patternDerived.remainingPatterns} patterns can still be developed at ~${patternDerived.patternsPerPhase}/phase`} />
                      </div>
                    </Section>
                  )}

                  <Section title="Existing Infrastructure">
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Does a CO₂ recycle plant already exist from previous operations? If yes, no recycle CAPEX is charged.">Recycle Plant Exists</label>
                      <button onClick={() => setRecycleExists(!recycleExists)}
                        className={`px-2 py-0.5 text-xs rounded ${recycleExists ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-600'}`}>
                        {recycleExists ? 'Yes' : 'No'}
                      </button>
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                      {recycleExists 
                        ? '✓ Recycle plant exists — no recycle CAPEX charged'
                        : '🏗️ Need to build recycle plant — CAPEX will be charged'}
                    </div>
                  </Section>

                  <Section title="Pattern Activation">
                    <InputField label="Activation Threshold" value={activationThreshold} onChange={setActivationThreshold} unit="t/yr spare" step={5000}
                      tooltip="Spare facility capacity that triggers new pattern activation. When facility has this much unused capacity and undeveloped patterns remain, a new pattern starts." />
                    <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded" style={{fontSize:'10px'}}>
                      💡 New patterns activate when facility has spare capacity ≥ {activationThreshold.toLocaleString()} t/yr and undeveloped patterns remain.
                    </div>
                  </Section>

                  <Section title="Schedule & Ramp">
                    {/* EOR Start Date */}
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Year EOR operations begin. For existing floods, this may be backdated.">EOR Start Year</label>
                      <input type="number" value={eorStartYear} onChange={(e) => setEorStartYear(parseInt(e.target.value) || 2025)}
                        className="w-20 text-xs border border-gray-300 rounded px-1.5 py-0.5 text-right" />
                    </div>
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Month (1-12) EOR operations begin">Start Month</label>
                      <select value={eorStartMonth} onChange={(e) => setEorStartMonth(parseInt(e.target.value))}
                        className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800" style={{maxWidth:'80px'}}>
                        {[1,2,3,4,5,6,7,8,9,10,11,12].map(m => (
                          <option key={m} value={m}>{['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][m-1]}</option>
                        ))}
                      </select>
                    </div>
                    
                    {/* Construction Periods - only show for full value chain */}
                    {fullValueChain && (
                      <div className="mt-2 pt-2 border-t border-gray-200">
                        <div className="text-xs font-medium text-gray-700 mb-1">Construction Periods</div>
                        <InputField label="Capture Facility" value={captureConstructionMonths} onChange={setCaptureConstructionMonths} unit="mo" step={3}
                          tooltip="Months to construct capture facility. Typical: 18-36 months for large capture plants." />
                        {!recycleExists && (
                          <InputField label="Recycle Facility" value={recycleConstructionMonths} onChange={setRecycleConstructionMonths} unit="mo" step={3}
                            tooltip="Months to construct CO₂ recycle/compression facility. Typical: 12-24 months." />
                        )}
                        <InputField label="Pipeline" value={pipelineConstructionMonths} onChange={setPipelineConstructionMonths} unit="mo" step={3}
                          tooltip="Months to construct trunk pipeline. Typical: 12-24 months depending on length and permitting." />
                        <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                          📅 Longest construction: {Math.max(captureConstructionMonths, recycleExists ? 0 : recycleConstructionMonths, pipelineConstructionMonths)} months before EOR start
                        </div>
                      </div>
                    )}
                    
                    {/* Pattern Ramp Control */}
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                          title="Enable gradual pattern ramp-up instead of activating all patterns at once when capacity allows">Pattern Ramp</label>
                        <button onClick={() => setUsePatternRamp(!usePatternRamp)}
                          className="w-10 h-5 rounded-full transition-colors relative"
                          style={{ backgroundColor: usePatternRamp ? '#16a34a' : '#d1d5db' }}>
                          <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                            style={{ left: usePatternRamp ? '22px' : '2px' }} />
                        </button>
                      </div>
                      {usePatternRamp && (
                        <>
                          <InputField label="Patterns per Interval" value={patternsPerMonth} onChange={setPatternsPerMonth} unit="patterns" step={1}
                            tooltip="Number of patterns to activate each interval during ramp-up. Capped by facility's fresh CO₂ capacity." />
                          <InputField label="Interval" value={rampIntervalMonths} onChange={setRampIntervalMonths} unit="months" step={1}
                            tooltip="Months between pattern activations during ramp-up phase. Set to 1 for monthly, 3 for quarterly, etc." />
                          <div className="text-xs text-gray-500 px-1 py-0.5 bg-blue-50 rounded mt-1" style={{fontSize:'10px'}}>
                            📈 Ramp rate: {Math.min(patternsPerMonth, patternDerived?.startingPatternsNew || patternsPerMonth)} pattern{Math.min(patternsPerMonth, patternDerived?.startingPatternsNew || patternsPerMonth) > 1 ? 's' : ''} every {rampIntervalMonths} month{rampIntervalMonths > 1 ? 's' : ''} 
                            (max {patternDerived?.startingPatternsNew || '?'} at facility capacity)
                          </div>
                          <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                            ⏱️ Ramp-up until facility reaches {patternDerived?.startingPatternsNew || '?'} patterns, then new patterns activate as recycling frees capacity
                          </div>
                        </>
                      )}
                      {!usePatternRamp && (
                        <div className="text-xs text-gray-500 px-1 py-0.5 bg-amber-50 rounded mt-1" style={{fontSize:'10px'}}>
                          ⚡ Instant activation: Start with {patternDerived?.startingPatternsNew || '?'} patterns (facility capacity), then add as recycling frees CO₂
                        </div>
                      )}
                    </div>
                  </Section>

                  <Section title="Feeder Pipelines">
                    <InputField label="Pipe per Pattern" value={feederPipePerPattern} onChange={setFeederPipePerPattern} unit="mi" step={0.1}
                      tooltip="Miles of small-diameter feeder pipeline per pattern. Connects injector and producers to trunk line. Typical 5-spot: 0.3-0.8 mi." />
                    <InputField label="Feeder Cost" value={feederPipeCostPerMile} onChange={setFeederPipeCostPerMile} unit="$/mi" step={10000}
                      tooltip="Cost per mile for 4-6 inch flowlines. Literature: $50k-150k/mi depending on terrain and materials." />
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Cost per Pattern" value={`$${((feederPipePerPattern * feederPipeCostPerMile) / 1000).toFixed(0)}k`}
                        tooltip="Feeder pipeline cost per pattern developed" />
                      <OutputRow label="Total Feeder CAPEX" value={`$${(calcs.feederPipeCapex || 0).toFixed(2)}MM`}
                        tooltip="Total feeder pipeline cost for all patterns developed" />
                    </div>
                  </Section>

                  <Section title="CO₂ / Oil Ratio">
                    <InputField label={eorMethod === 'continuous' ? "Steady-State Ratio" : "Base Ratio (Continuous)"} value={co2OilRatio} onChange={setCo2OilRatio} unit="t/bbl" step={0.1}
                      tooltip="Tonnes CO₂ per barrel for continuous injection. WAG and H&P methods auto-adjust based on their efficiency." />
                    {eorMethod === 'wag' && (
                      <div className="flex justify-between items-center py-0.5 bg-blue-50 px-1 rounded text-xs">
                        <span className="text-blue-700">WAG Effective Ratio:</span>
                        <span className="font-medium text-blue-800">{(co2OilRatio * wagCycleMonths / (wagCycleMonths * (1 + wagRatio)) / 1.20).toFixed(2)} t/bbl</span>
                      </div>
                    )}
                    {eorMethod === 'wag' && (
                      <div className="text-xs text-blue-600 px-1" style={{fontSize: '9px'}}>
                        {wagRatio === 1 ? '1:1' : `${wagRatio}:1`} WAG = {(wagCycleMonths / (wagCycleMonths * (1 + wagRatio)) * 100).toFixed(0)}% CO₂ time × 1.2 efficiency
                      </div>
                    )}
                    {eorMethod === 'huffpuff' && (
                      <div className="flex justify-between items-center py-0.5 bg-purple-50 px-1 rounded text-xs">
                        <span className="text-purple-700">H&P Effective Ratio:</span>
                        <span className="font-medium text-purple-800">{(co2OilRatio / 2.0).toFixed(2)} t/bbl <span className="text-purple-600 text-xs">(cyclic efficiency)</span></span>
                      </div>
                    )}
                    <OutputRow label="Ratio (MCF/bbl)" value={`${(co2OilRatio * 19.25).toFixed(1)}`} />
                    <OutputRow label="Lifetime Avg Ratio" value={`${calcs.lifetimeCo2OilRatio?.toFixed(3) || 'N/A'}`} unit="t/bbl" />
                  </Section>

                  <Section title="CO₂ Recycle">
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Fixed: constant recycle rate for all patterns. Ramping: each pattern's recycle rate increases with age as CO₂ breaks through.">Recycle Mode</label>
                      <select value={recycleMode} onChange={(e) => setRecycleMode(e.target.value)}
                        className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'100px'}}>
                        <option value="fixed">Fixed</option>
                        <option value="ramping">Ramping</option>
                      </select>
                    </div>
                    {recycleMode === 'fixed' ? (
                      <>
                        <InputField label="Recycle Rate" value={fixedRecycleRate} onChange={setFixedRecycleRate} unit="%" step={5}
                          tooltip="Fixed percentage of injected CO₂ that is recycled (vs. stored). Applied uniformly to all patterns." />
                        <OutputRow label="Net Storage Rate" value={`${100 - fixedRecycleRate}%`}
                          tooltip="Percentage of injection that is permanently stored" />
                      </>
                    ) : (
                      <>
                        <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                          🔄 Per-pattern ramping: Each pattern's recycle rate ramps based on its age. Young patterns store more CO₂, mature patterns recycle more.
                        </div>
                        <div className="text-xs text-gray-500 px-1 py-0.5" style={{fontSize:'10px'}}>
                          Yr 1: 0% → Yr 3: 10% → Yr 6: 30% → Yr 10: 55% → Yr 15: 70% → Yr 20+: 80-85%
                        </div>
                        <OutputRow label="Avg Recycle (final)" value={calcs.monthlyData?.length > 0 ? `${calcs.monthlyData[calcs.monthlyData.length - 1]?.recycleFraction?.toFixed(0) || 0}%` : 'N/A'}
                          tooltip="Field-average recycle rate at end of project (weighted by pattern injection)" />
                      </>
                    )}
                  </Section>
                </div>

                <div>
                  <Section title="Oil Pricing">
                    <InputField label="WTI Price" value={wtiPrice} onChange={setWtiPrice} unit="$/bbl" step={5} />
                    <InputField label="Oil Differential" value={oilDiff} onChange={setOilDiff} unit="$/bbl" step={1} />
                    <OutputRow label="Net Oil Price" value={`$${(wtiPrice - oilDiff).toFixed(2)}/bbl`} />
                  </Section>

                  <Section title="Financing & Discount Rate">
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Fixed: use a single discount rate. WACC: calculate weighted average cost of capital from debt/equity mix.">Discount Mode</label>
                      <select value={useHurdleRate ? 'fixed' : 'wacc'} onChange={(e) => setUseHurdleRate(e.target.value === 'fixed')}
                        className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'100px'}}>
                        <option value="fixed">Fixed Rate</option>
                        <option value="wacc">WACC</option>
                      </select>
                    </div>
                    {useHurdleRate ? (
                      <InputField label="Discount Rate" value={hurdleRate} onChange={setHurdleRate} unit="%" step={0.5} 
                        tooltip="Fixed discount rate for NPV calculations" />
                    ) : (
                      <>
                        <InputField label="Debt %" value={debtPct} onChange={setDebtPct} unit="%" step={5} 
                          tooltip="Percentage of CAPEX financed with debt (typical: 50-70%)" />
                        <InputField label="Debt Interest" value={debtInterestRate} onChange={setDebtInterestRate} unit="%" step={0.5} 
                          tooltip="Annual interest rate on project debt" />
                        <InputField label="Cost of Equity" value={costOfEquity} onChange={setCostOfEquity} unit="%" step={0.5} 
                          tooltip="Required return on equity (typical oil & gas: 12-20%)" />
                      </>
                    )}
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Effective Rate" value={`${computedFinancing.effectiveDiscountRatePct.toFixed(1)}%`}
                        tooltip={useHurdleRate ? 'Fixed hurdle rate' : `WACC: ${debtPct}% debt @ ${(debtInterestRate * (1 - computedFinancing.combinedTaxRate)).toFixed(1)}% (after-tax) + ${100-debtPct}% equity @ ${costOfEquity}%`} />
                    </div>
                  </Section>

                  <Section title="Tax & Credits">
                    {/* State Selection */}
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                        title="Select the state where the EOR project is located. This determines severance tax rates and any EOR-specific tax incentives.">State</label>
                      <select value={selectedState} onChange={(e) => setSelectedState(e.target.value)}
                        className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'100px'}}>
                        {Object.entries(STATE_TAX_CONFIG).map(([key, config]) => (
                          <option key={key} value={key}>{config.name}</option>
                        ))}
                      </select>
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded" style={{fontSize:'9px'}}>
                      Sev: {severanceTax}%{STATE_TAX_CONFIG[selectedState]?.eorSeverance < severanceTax ? ` → ${computedEORSeverance}% (EOR)` : ''} | Inc: {stateTaxRate}%
                    </div>
                    
                    <div className="flex items-center justify-between py-1 mt-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="Toggle tax calculations on/off. When enabled, calculates after-tax economics including federal/state income tax, severance tax, and applicable credits.">Enable Tax Calc</label>
                      <button onClick={() => setEnableTaxCalc(!enableTaxCalc)}
                        className={`px-2 py-0.5 text-xs rounded ${enableTaxCalc ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-600'}`}>
                        {enableTaxCalc ? 'Yes' : 'No'}
                      </button>
                    </div>
                    
                    {/* 45Q Tax Credit */}
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                          title="IRS Section 45Q provides tax credits for CO₂ sequestration. EOR projects qualify for $60/tonne (as of 2024). Credits are earned for 12 years from project start.">45Q CO₂ Credit</label>
                        <button onClick={() => setCreditEnabled(!creditEnabled)}
                          className="w-10 h-5 rounded-full transition-colors relative"
                          style={{ backgroundColor: creditEnabled ? '#16a34a' : '#d1d5db' }}>
                          <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                            style={{ left: creditEnabled ? '22px' : '2px' }} />
                        </button>
                      </div>
                      {creditEnabled && (
                        <>
                          <InputField label="Credit Rate" value={creditTotal} onChange={setCreditTotal} unit="$/t" step={5}
                            tooltip="45Q credit rate per tonne of CO₂. Current rate is $60/t for EOR, $85/t for saline storage." />
                          <InputField label="Duration" value={creditYears} onChange={setCreditYears} unit="yrs" step={1}
                            tooltip="Number of years 45Q credits can be claimed. Typically 12 years from when equipment is placed in service." />
                          <div className="flex items-center justify-between py-1">
                            <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                              title="Escalate 45Q credit value with inflation each year. The IRA allows for inflation adjustment of 45Q credit values.">Inflation Escalation</label>
                            <button onClick={() => setCreditInflation(!creditInflation)}
                              className="w-10 h-5 rounded-full transition-colors relative"
                              style={{ backgroundColor: creditInflation ? '#16a34a' : '#d1d5db' }}>
                              <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                                style={{ left: creditInflation ? '22px' : '2px' }} />
                            </button>
                          </div>
                          {creditInflation && (
                            <InputField label="Inflation Rate" value={creditInflationRate} onChange={setCreditInflationRate} unit="%/yr" step={0.5}
                              tooltip="Annual inflation rate applied to 45Q credit value. Default 2.5% based on historical CPI." />
                          )}
                        </>
                      )}
                      {STATE_TAX_CONFIG[selectedState]?.anthropogenicCO2Bonus && creditEnabled && (
                        <div className="text-xs text-green-600 px-1 py-0.5" style={{fontSize:'9px'}}>
                          ✓ {selectedState}: Extra severance reduction for anthropogenic CO₂!
                        </div>
                      )}
                    </div>
                    
                    {enableTaxCalc && (
                      <>
                        {/* Section 43 EOR Credit */}
                        <div className="mt-2 pt-2 border-t border-gray-200">
                          <div className="flex items-center justify-between py-1">
                            <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                              title="IRS Section 43 provides a 15% tax credit on qualified EOR costs. However, this credit phases out when oil prices exceed the reference price (~$59/bbl in 2024). Currently not available at typical oil prices.">§43 EOR Credit</label>
                            <button onClick={() => setSection43Enabled(!section43Enabled)}
                              className="w-10 h-5 rounded-full transition-colors relative"
                              style={{ backgroundColor: section43Enabled ? '#16a34a' : '#d1d5db' }}>
                              <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                                style={{ left: section43Enabled ? '22px' : '2px' }} />
                            </button>
                          </div>
                          <div className="text-xs text-gray-500 px-1 py-0.5 bg-amber-50 rounded" style={{fontSize:'10px'}}>
                            ⚠️ Currently phased out at oil &gt;$59/bbl
                          </div>
                        </div>
                        
                        {/* Tax Rates */}
                        <div className="mt-2 pt-2 border-t border-gray-200">
                          <InputField label="Federal Tax" value={federalTaxRate} onChange={setFederalTaxRate} unit="%" step={1}
                            tooltip="Federal corporate income tax rate. Current statutory rate is 21%." />
                          <div className="flex items-center justify-between py-1">
                            <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                              title="State corporate income tax rate. Varies by state; set automatically based on state selection.">State Income Tax</label>
                            <span className="text-xs font-medium text-gray-800">{stateTaxRate.toFixed(1)}%</span>
                          </div>
                          <div className="flex items-center justify-between py-1">
                            <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                              title="State severance tax on oil production. Many states offer reduced rates for EOR projects. Set automatically based on state selection.">Severance Tax</label>
                            <span className="text-xs font-medium text-gray-800">{severanceTax}%</span>
                          </div>
                          <InputField label="IDC %" value={idcPct} onChange={setIdcPct} unit="%" step={5}
                            tooltip="Intangible Drilling Costs as % of well costs. IDC can be expensed immediately (70%) or capitalized (30%). Typical range: 60-80%." />
                          <InputField label="Bonus Depr." value={bonusDepreciation} onChange={setBonusDepreciation} unit="%" step={20}
                            tooltip="Bonus depreciation allows immediate expensing of tangible equipment. Under current tax law, this phases down from 100% (2022) to 0% (2027)." />
                          <InputField label="Depletion" value={depletionAllowance} onChange={setDepletionAllowance} unit="%" step={1}
                            tooltip="Percentage depletion allowance for oil production. Independent producers can deduct 15% of gross revenue, limited to 65% of taxable income." />
                          <div className="mt-1 pt-1 border-t border-gray-200">
                            <div className="flex items-center justify-between py-1">
                              <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                                title="Combined effective tax rate = Federal + State × (1 - Federal). Accounts for state tax deductibility on federal returns.">Combined Tax Rate</label>
                              <span className="text-xs font-medium text-gray-800">{computedFinancing.combinedTaxRatePct.toFixed(1)}%</span>
                            </div>
                          </div>
                        </div>
                      </>
                    )}
                  </Section>

                  <Section title="Well Costs">
                    <InputField label="Field Depth" value={wellDepth} onChange={setWellDepth} unit="ft" step={500} 
                      tooltip="Average well depth. Used to calculate well costs." />
                    <InputField label="Retrofit $/ft" value={retrofitCostPerFt} onChange={setRetrofitCostPerFt} unit="$/ft" step={5}
                      tooltip="Cost per foot for well retrofit (CO₂-resistant tubing, cement squeeze, wellhead upgrade, packer). Literature: $15-50/ft." />
                    <InputField label="New Well $/ft" value={newWellCostPerFt} onChange={setNewWellCostPerFt} unit="$/ft" step={25}
                      tooltip="Cost per foot for new drill and complete. Literature: $150-400/ft depending on complexity." />
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <InputField label="% New Wells" value={newWellsPct} onChange={setNewWellsPct} unit="%" step={5}
                        tooltip="Percentage of wells that are new drills vs retrofits. 0% = all existing wells retrofitted, 100% = all new wells drilled." />
                    </div>
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Retrofit Cost/Well" value={`$${computedWellCosts.retrofitCostK.toFixed(0)}k`} 
                        tooltip={`${wellDepth.toLocaleString()} ft × $${retrofitCostPerFt}/ft`} />
                      <OutputRow label="New Well Cost" value={`$${computedWellCosts.newWellCostMM.toFixed(2)}MM`} 
                        tooltip={`${wellDepth.toLocaleString()} ft × $${newWellCostPerFt}/ft`} />
                      <OutputRow label="Blended Avg" value={`$${((newWellsPct/100 * computedWellCosts.newWellCost + (1 - newWellsPct/100) * computedWellCosts.retrofitCost) / 1000).toFixed(0)}k`} 
                        tooltip={`${newWellsPct}% new + ${100-newWellsPct}% retrofit`} />
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                      {newWellsPct === 0 
                        ? '💡 All wells are retrofits of existing conventional wells.'
                        : newWellsPct === 100
                        ? '💡 All wells are new drills (greenfield development).'
                        : `💡 ${newWellsPct}% new drills, ${100-newWellsPct}% retrofits.`}
                    </div>
                  </Section>

                  {fullValueChain && (
                    <Section title="CO₂ Capture Facility">
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                          title="Source of CO₂ determines capture difficulty and cost">CO₂ Source</label>
                        <select value={co2SourceType} onChange={e => {
                          setCo2SourceType(e.target.value);
                          if (e.target.value !== 'custom') {
                            const src = CO2_SOURCES[e.target.value];
                            if (src) setCo2Concentration(src.conc);
                          }
                        }}
                          className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'120px'}}>
                          {Object.entries(CO2_SOURCES).map(([key, src]) => (
                            <option key={key} value={key}>{src.label}</option>
                          ))}
                        </select>
                      </div>
                      <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                        {(CO2_SOURCES[co2SourceType] || CO2_SOURCES.ngp).desc}
                      </div>
                      {co2SourceType === 'custom' && (
                        <InputField label="CO₂ Concentration" value={co2Concentration} onChange={setCo2Concentration} unit="%" step={1}
                          tooltip="Flue gas CO₂ concentration. Higher = cheaper capture. Range 4-99%." />
                      )}
                      <InputField label="Pipeline Distance" value={pipelineDistance} onChange={setPipelineDistance} unit="mi" step={10}
                        tooltip="Distance from capture facility to injection site" />
                      <div className="mt-1 pt-1 border-t border-gray-200">
                        <OutputRow label="Capture CAPEX" value={`~$${((CO2_SOURCES[co2SourceType]?.capexPerTpa || 150) * facilitySize / 1e6).toFixed(1)}MM`}
                          tooltip="Estimated capture facility cost for this facility size" />
                        <OutputRow label="Capture OPEX" value={`$${(CO2_SOURCES[co2SourceType]?.opex || 30).toFixed(0)}/t`}
                          tooltip="Operating cost for capture" />
                      </div>
                    </Section>
                  )}

                  <Section title="CO₂ Pricing">
                    <InputField label="CO₂ Price" value={co2Price} onChange={setCo2Price} unit="$/t" step={5}
                      tooltip="Negative = purchasing CO₂. Positive = getting paid to take CO₂." />
                    <div className="text-xs text-gray-500 px-1 py-0.5" style={{fontSize:'10px'}}>
                      {co2Price < 0 ? `💰 Paying $${Math.abs(co2Price)}/t for CO₂` : co2Price > 0 ? `🎁 Receiving $${co2Price}/t for taking CO₂` : '⚖️ CO₂ is free'}
                    </div>
                  </Section>

                  <Section title="Production OPEX">
                    <InputField label="Prod OPEX" value={prodOpex} onChange={setProdOpex} unit="$/bbl" step={1} />
                    <InputField label="Oil Transport" value={oilTransport} onChange={setOilTransport} unit="$/bbl" step={1} />
                    <OutputRow label="Severance Tax" value={`${severanceTax}%`}
                      tooltip={`Set by state (${STATE_TAX_CONFIG[selectedState]?.name})`} />
                  </Section>

                  <Section title="CCUS OPEX">
                    <InputField label="Recycle OPEX" value={recycleOpex} onChange={setRecycleOpex} unit="$/t" step={1}
                      tooltip="Cost to compress and reinject recycled CO₃. Literature: $8-15/t" />
                    <InputField label="Storage OPEX" value={storageOpex} onChange={setStorageOpex} unit="$/t" step={0.5}
                      tooltip="Cost for MMV, well integrity monitoring. Literature: $2-5/t stored" />
                    {fullValueChain && (
                      <>
                        <InputField label="Capture OPEX" value={captureOpex} onChange={setCaptureOpex} unit="$/t" step={5}
                          tooltip={`Operating cost for capture. Auto: $${(CO2_SOURCES[co2SourceType]?.opex || 30).toFixed(0)}/t for ${(CO2_SOURCES[co2SourceType]?.label || 'selected source')}`} />
                        <InputField label="Transport OPEX" value={transportOpex} onChange={setTransportOpex} unit="$/t" step={0.5}
                          tooltip="Pipeline operations, compression. Literature: $1-3/t depending on distance" />
                      </>
                    )}
                  </Section>
                </div>
              </>
            )}

            {/* ============ SIMPLE MODE INPUTS ============ */}
            {modelMode === 'simple' && (
              <>
            <div>
              <Section title="Oil Pricing">
                <InputField label="WTI Price" value={wtiPrice} onChange={setWtiPrice} unit="$/bbl" step={5} tooltip="West Texas Intermediate crude oil price" />
                <InputField label="Oil Differential" value={oilDiff} onChange={setOilDiff} unit="$/bbl" step={1} tooltip="Discount from WTI for field-specific crude quality and location" />
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Net Oil Price" value={`$${(wtiPrice - oilDiff).toFixed(2)}`} unit="/bbl" />
                </div>
              </Section>

              <Section title="Financing & Discount Rate">
                <div className="flex items-center justify-between py-1">
                  <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                    title="Fixed: use a single discount rate. WACC: calculate weighted average cost of capital from debt/equity mix.">Discount Mode</label>
                  <select value={useHurdleRate ? 'fixed' : 'wacc'} onChange={(e) => setUseHurdleRate(e.target.value === 'fixed')}
                    className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'100px'}}>
                    <option value="fixed">Fixed Rate</option>
                    <option value="wacc">WACC</option>
                  </select>
                </div>
                {useHurdleRate ? (
                  <InputField label="Discount Rate" value={hurdleRate} onChange={setHurdleRate} unit="%" step={0.5} 
                    tooltip="Fixed discount rate for NPV calculations" />
                ) : (
                  <>
                    <InputField label="Debt %" value={debtPct} onChange={setDebtPct} unit="%" step={5} 
                      tooltip="Percentage of CAPEX financed with debt (typical: 50-70%)" />
                    <InputField label="Debt Interest" value={debtInterestRate} onChange={setDebtInterestRate} unit="%" step={0.5} 
                      tooltip="Annual interest rate on project debt" />
                    <InputField label="Cost of Equity" value={costOfEquity} onChange={setCostOfEquity} unit="%" step={0.5} 
                      tooltip="Required return on equity (typical oil & gas: 12-20%)" />
                  </>
                )}
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Effective Rate" value={`${computedFinancing.effectiveDiscountRatePct.toFixed(1)}%`}
                    tooltip={useHurdleRate ? 'Fixed hurdle rate' : `WACC: ${debtPct}% debt @ ${(debtInterestRate * (1 - computedFinancing.combinedTaxRate)).toFixed(1)}% (after-tax) + ${100-debtPct}% equity @ ${costOfEquity}%`} />
                  {!useHurdleRate && (
                    <OutputRow label="After-Tax Debt Cost" value={`${computedFinancing.afterTaxCostOfDebtPct.toFixed(1)}%`}
                      tooltip={`${debtInterestRate}% × (1 - ${computedFinancing.combinedTaxRatePct.toFixed(1)}% tax)`} />
                  )}
                </div>
              </Section>

              <Section title="Tax & Credits">
                {/* State Selection */}
                <div className="flex items-center justify-between py-1">
                  <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                    title="Select state for severance tax and state-specific EOR incentives">State</label>
                  <select value={selectedState} onChange={(e) => setSelectedState(e.target.value)}
                    className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'110px'}}>
                    {Object.entries(STATE_TAX_CONFIG).map(([key, config]) => (
                      <option key={key} value={key}>{config.name}</option>
                    ))}
                  </select>
                </div>
                
                {/* State Info */}
                <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                  📍 {STATE_TAX_CONFIG[selectedState]?.notes || ''}
                </div>
                
                {/* Severance Tax Display */}
                <div className="mt-2 pt-2 border-t border-gray-200">
                  <div className="flex items-center justify-between py-1">
                    <span className="text-gray-600 text-xs cursor-help border-b border-dotted border-gray-400" 
                      title="State severance/production tax on oil. EOR projects may qualify for reduced rates.">Severance Tax</span>
                    <div className="flex items-center gap-1">
                      {selectedState === 'CUSTOM' ? (
                        <input type="number" value={severanceTax} step={0.5}
                          onChange={(e) => setSeveranceTax(parseFloat(e.target.value) || 0)}
                          className="w-16 text-xs border border-gray-300 rounded px-1.5 py-0.5 text-right" />
                      ) : (
                        <span className="font-mono text-xs text-gray-800">{severanceTax.toFixed(1)}%</span>
                      )}
                      {STATE_TAX_CONFIG[selectedState]?.eorSeverance < severanceTax && (
                        <span className="text-green-600 text-xs">→ {computedEORSeverance.toFixed(1)}% (EOR)</span>
                      )}
                    </div>
                  </div>
                  {STATE_TAX_CONFIG[selectedState]?.adValorem && (
                    <OutputRow label="Ad Valorem Tax" value={`${STATE_TAX_CONFIG[selectedState].adValorem}%`}
                      tooltip="Property/ad valorem tax on production (in addition to severance)" />
                  )}
                </div>
                
                <div className="flex items-center justify-between py-1 mt-1">
                  <label className="text-gray-700 text-xs">Enable Tax Calc</label>
                  <button onClick={() => setEnableTaxCalc(!enableTaxCalc)}
                    className={`px-2 py-0.5 text-xs rounded ${enableTaxCalc ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-600'}`}>
                    {enableTaxCalc ? 'Yes' : 'No'}
                  </button>
                </div>
                
                {/* 45Q Tax Credit - always visible */}
                <div className="mt-2 pt-2 border-t border-gray-200">
                  <div className="flex items-center justify-between py-1">
                    <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                      title="IRS Section 45Q provides tax credits for CO₂ sequestration. EOR projects qualify for $60/tonne (as of 2024). Credits are earned for 12 years from project start.">45Q CO₂ Storage Credit</label>
                    <button onClick={() => setCreditEnabled(!creditEnabled)}
                      className="w-10 h-5 rounded-full transition-colors relative"
                      style={{ backgroundColor: creditEnabled ? '#16a34a' : '#d1d5db' }}>
                      <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                        style={{ left: creditEnabled ? '22px' : '2px' }} />
                    </button>
                  </div>
                  {creditEnabled && (
                    <>
                      <InputField label="Credit Rate" value={creditTotal} onChange={setCreditTotal} unit="$/t" step={5}
                        tooltip="45Q credit per tonne CO₂: $60/t for EOR, $85/t for saline storage" />
                      <InputField label="Credit Duration" value={creditYears} onChange={setCreditYears} unit="yrs" step={1}
                        tooltip="45Q credits available for 12 years from first injection" />
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                          title="Escalate 45Q credit rate annually with inflation. The IRA allows for inflation adjustment of 45Q credit values.">Inflation Escalation</label>
                        <button onClick={() => setCreditInflation(!creditInflation)}
                          className="w-10 h-5 rounded-full transition-colors relative"
                          style={{ backgroundColor: creditInflation ? '#16a34a' : '#d1d5db' }}>
                          <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                            style={{ left: creditInflation ? '22px' : '2px' }} />
                        </button>
                      </div>
                      {creditInflation && (
                        <InputField label="Inflation Rate" value={creditInflationRate} onChange={setCreditInflationRate} unit="%/yr" step={0.5}
                          tooltip="Annual inflation rate applied to 45Q credit value. Default 2.5% based on historical CPI." />
                      )}
                    </>
                  )}
                  <div className="text-xs text-gray-500 px-1 py-0.5 bg-blue-50 rounded mt-1" style={{fontSize:'10px'}}>
                    💡 45Q credits reduce tax liability directly (not taxable income). Transferable for cash.
                    {STATE_TAX_CONFIG[selectedState]?.anthropogenicCO2Bonus && creditEnabled && (
                      <span className="block text-green-600 mt-0.5">✓ {selectedState}: Additional severance reduction for anthropogenic CO₂ EOR!</span>
                    )}
                  </div>
                </div>
                
                {enableTaxCalc && (
                  <>
                    {/* Section 43 EOR Credit */}
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <div className="flex items-center justify-between py-1">
                        <label className="text-gray-700 text-xs font-medium cursor-help border-b border-dotted border-gray-400"
                          title="IRS Section 43 provides a 15% tax credit on qualified EOR costs. However, this credit phases out when oil prices exceed the reference price (~$59/bbl in 2024). Currently not available at typical oil prices.">§43 EOR Credit</label>
                        <button onClick={() => setSection43Enabled(!section43Enabled)}
                          className="w-10 h-5 rounded-full transition-colors relative"
                          style={{ backgroundColor: section43Enabled ? '#16a34a' : '#d1d5db' }}>
                          <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                            style={{ left: section43Enabled ? '22px' : '2px' }} />
                        </button>
                      </div>
                      {section43Enabled && (
                        <InputField label="Price Threshold" value={section43PriceThreshold} onChange={setSection43PriceThreshold} unit="$/bbl" step={1}
                          tooltip="Credit phases out when oil price exceeds this (2025: ~$59/bbl). Currently phased out at most prices." />
                      )}
                      <div className="text-xs text-gray-500 px-1 py-0.5 bg-amber-50 rounded mt-1" style={{fontSize:'10px'}}>
                        ⚠️ §43 credit currently phased out at oil prices above ~$59/bbl (2025). Only applies in low-price environments.
                      </div>
                    </div>
                    
                    {/* Tax Rates & Deductions */}
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <div className="text-xs font-medium text-gray-700 mb-1">Tax Rates & Deductions</div>
                      <InputField label="Federal Tax" value={federalTaxRate} onChange={setFederalTaxRate} unit="%" step={1} 
                        tooltip="Federal corporate income tax rate (current: 21%)" />
                      <div className="flex items-center justify-between py-1">
                        <span className="text-gray-600 text-xs cursor-help border-b border-dotted border-gray-400" 
                          title="State corporate income tax rate">State Income Tax</span>
                        <div className="flex items-center gap-1">
                          {selectedState === 'CUSTOM' ? (
                            <input type="number" value={stateTaxRate} step={0.5}
                              onChange={(e) => setStateTaxRate(parseFloat(e.target.value) || 0)}
                              className="w-16 text-xs border border-gray-300 rounded px-1.5 py-0.5 text-right" />
                          ) : (
                            <span className="font-mono text-xs text-gray-800">{stateTaxRate.toFixed(1)}%</span>
                          )}
                          <span className="text-gray-400 text-xs w-6"></span>
                        </div>
                      </div>
                      <InputField label="IDC %" value={idcPct} onChange={setIdcPct} unit="%" step={5} 
                        tooltip="Intangible Drilling Costs as % of well CAPEX. 100% deductible in Year 1. Literature: 60-80%." />
                      <InputField label="Bonus Depreciation" value={bonusDepreciation} onChange={setBonusDepreciation} unit="%" step={20} 
                        tooltip="Bonus depreciation for tangible equipment. Phasing out: 60% (2024), 40% (2025), 20% (2026), 0% (2027+)." />
                      <InputField label="Depletion Allowance" value={depletionAllowance} onChange={setDepletionAllowance} unit="%" step={1} 
                        tooltip="Percentage depletion of gross oil revenue (small producers only, max 15%)" />
                      <div className="mt-1 pt-1 border-t border-gray-200">
                        <OutputRow label="Combined Tax Rate" value={`${computedFinancing.combinedTaxRatePct.toFixed(1)}%`}
                          tooltip={`Federal ${federalTaxRate}% + State ${stateTaxRate}% (net of federal deduction)`} />
                        {calcs.taxShieldTotal != null && calcs.taxShieldTotal > 0 && (
                          <OutputRow label="Total Tax Shield" value={`$${calcs.taxShieldTotal.toFixed(2)}MM`}
                            tooltip="IDC deduction + Depreciation shield + Depletion allowance + §43 credit" />
                        )}
                      </div>
                    </div>
                  </>
                )}
              </Section>

              <Section title="Well Costs">
                <InputField label="Field Depth" value={wellDepth} onChange={setWellDepth} unit="ft" step={500}
                  tooltip="Average well depth for the field. Permian Basin: 7,000-10,000 ft; Gulf Coast: 8,000-12,000 ft" />
                <InputField label="New Well $/ft" value={newWellCostPerFt} onChange={setNewWellCostPerFt} unit="$/ft" step={25}
                  tooltip="Cost per foot for drilling and completing a new well. Literature: $150-400/ft depending on complexity, location, and depth. Permian avg ~$200/ft." />
                <InputField label="Retrofit $/ft" value={retrofitCostPerFt} onChange={setRetrofitCostPerFt} unit="$/ft" step={5}
                  tooltip="Cost per foot for well retrofit/workover. Includes integrity assessment, squeeze cement, CO₂-resistant tubing, packer, MIT. Literature: $15-50/ft." />
                <div className="mt-2 pt-2 border-t border-gray-200">
                  <InputField label="% New Wells" value={newWellsPct} onChange={setNewWellsPct} unit="%" step={5}
                    tooltip="Percentage of wells that are new drills vs retrofits. 0% = all existing wells retrofitted, 100% = all new wells drilled." />
                </div>
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="New Well Cost" value={`$${(computedWellCosts.newWellCostMM).toFixed(2)}`} unit="MM"
                    tooltip={`${wellDepth.toLocaleString()} ft × $${newWellCostPerFt}/ft`} />
                  <OutputRow label="Retrofit Cost" value={`$${computedWellCosts.retrofitCostK.toFixed(0)}`} unit="k"
                    tooltip={`${wellDepth.toLocaleString()} ft × $${retrofitCostPerFt}/ft`} />
                  <OutputRow label="Blended Avg" value={`$${((newWellsPct/100 * computedWellCosts.newWellCost + (1 - newWellsPct/100) * computedWellCosts.retrofitCost) / 1000).toFixed(0)}k`} 
                    tooltip={`${newWellsPct}% new + ${100-newWellsPct}% retrofit`} />
                </div>
                <div className="text-xs text-gray-500 px-1 py-1 bg-gray-50 rounded mt-1" style={{fontSize:'10px'}}>
                  {newWellsPct === 0 
                    ? '💡 All wells are retrofits of existing conventional wells.'
                    : newWellsPct === 100
                    ? '💡 All wells are new drills (greenfield development).'
                    : `💡 ${newWellsPct}% new drills, ${100-newWellsPct}% retrofits.`}
                </div>
              </Section>

              <Section title="Oil Production">
                <InputField label="Producing Years" value={producingYears} onChange={setProducingYears} unit="yrs" step={1} />
                <InputField label="Prod. Well Count" value={prodWellCount} onChange={setProdWellCount} unit="wells" step={10} />
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Steady-State Prod." value={((injPerWellPerYr * injWellCount / co2OilRatio) / 12).toLocaleString(undefined, {maximumFractionDigits:0})} unit="bbl/mo"
                    tooltip="Monthly oil production at steady-state CO₂/Oil ratio = Total injection / ratio" />
                  <OutputRow label="Per Well (steady)" value={(injPerWellPerYr * injWellCount / co2OilRatio / prodWellCount).toLocaleString(undefined, {maximumFractionDigits:0})} unit="bbl/yr"
                    tooltip="Annual per-well production at steady-state" />
                </div>
              </Section>

              <Section title="Production Profile">
                <div className="flex items-center justify-between py-1">
                  <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                    title="Flat: constant production rate. Ramp+Decline: realistic profile with ramp-up, peak, and decline phases.">Profile Type</label>
                  <select value={prodProfileFlat ? 'flat' : 'decline'} onChange={(e) => setProdProfileFlat(e.target.value === 'flat')}
                    className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'120px'}}>
                    <option value="flat">Flat</option>
                    <option value="decline">Ramp + Decline</option>
                  </select>
                </div>
                {!prodProfileFlat && (
                  <>
                    <InputField label="Ramp-Up Period" value={prodRampUpYears} onChange={setProdRampUpYears} unit="yrs" step={0.5}
                      tooltip="Years for production to ramp from ~10% to 100% of capacity. Typical EOR: 1-3 years as CO₂ bank develops and miscibility front reaches producers." />
                    <InputField label="Peak Duration" value={prodPeakYears} onChange={setProdPeakYears} unit="yrs" step={0.5}
                      tooltip="Years at peak/plateau production before decline begins. Typical: 2-5 years depending on reservoir size and pattern spacing." />
                    <InputField label="Decline Rate" value={prodDeclineRate} onChange={setProdDeclineRate} unit="%/yr" step={1}
                      tooltip="Annual production decline rate after peak. Typical EOR: 5-15%/yr. Mature fields may decline faster (10-15%), large fields slower (5-8%)." />
                    <div className="mt-1 pt-1 border-t border-gray-200">
                      <OutputRow label="Decline Start" value={`Year ${prodRampUpYears + prodPeakYears}`}
                        tooltip="Year when production decline begins (after ramp-up + peak)" />
                      <OutputRow label="Prod @ End" value={`${(Math.pow(1 - prodDeclineRate/100, Math.max(0, producingYears - prodRampUpYears - prodPeakYears)) * 100).toFixed(0)}%`}
                        tooltip={`Production rate at end of project (Year ${producingYears}) as % of peak`} />
                    </div>
                  </>
                )}
                {prodProfileFlat && (
                  <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded" style={{fontSize:'10px'}}>
                    📊 Flat profile: Production remains constant throughout project life. Use "Ramp + Decline" for more realistic EOR behavior.
                  </div>
                )}
              </Section>

              <Section title="CO₂ / Oil Ratio" >
                <InputField label={eorMethod === 'continuous' ? "Steady-State Ratio" : "Base Ratio (Continuous)"} value={co2OilRatio} onChange={setCo2OilRatio} unit="t/bbl" step={0.1}
                  tooltip="Tonnes of CO₂ injected per barrel of incremental oil at steady-state for continuous injection. WAG/H&P auto-adjust. Field data: median 5.4 t/bbl, weighted avg ~2 t/bbl." />
                {eorMethod === 'wag' && (
                  <>
                    <div className="flex justify-between items-center py-0.5 bg-blue-50 px-1 rounded text-xs">
                      <span className="text-blue-700">WAG Effective Ratio:</span>
                      <span className="font-medium text-blue-800">{(co2OilRatio * wagCycleMonths / (wagCycleMonths * (1 + wagRatio)) / 1.20).toFixed(2)} t/bbl</span>
                    </div>
                    <div className="text-xs text-blue-600 px-1" style={{fontSize: '9px'}}>
                      {wagRatio === 1 ? '1:1' : `${wagRatio}:1`} WAG = {(wagCycleMonths / (wagCycleMonths * (1 + wagRatio)) * 100).toFixed(0)}% CO₂ time × 1.2 efficiency
                    </div>
                  </>
                )}
                {eorMethod === 'huffpuff' && (
                  <div className="flex justify-between items-center py-0.5 bg-purple-50 px-1 rounded text-xs">
                    <span className="text-purple-700">H&P Effective Ratio:</span>
                    <span className="font-medium text-purple-800">{(co2OilRatio / 2.0).toFixed(2)} t/bbl <span className="text-purple-600">(cyclic)</span></span>
                  </div>
                )}
                <OutputRow label="Ratio (MCF/bbl)" value={`${(co2OilRatio * 19.25).toFixed(1)}`}
                  tooltip="Same ratio in MCF per barrel. 1 tonne CO₂ = 19.25 MCF at standard conditions." />
                <OutputRow label="Bbl per tonne" value={`${(1/co2OilRatio).toFixed(1)}`}
                  tooltip="Barrels of oil per tonne CO₂ at steady state" />
                <div className="flex items-center justify-between py-1">
                  <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                    title="Auto: ramp profile set by flood type. Custom: define your own year→multiplier breakpoints.">Ramp Profile</label>
                  <select value={rampMode} onChange={(e) => setRampMode(e.target.value)}
                    className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'120px'}}>
                    <option value="auto">{scenarioType === 'New' ? 'Auto (New Flood)' : 'Auto (Existing)'}</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                {rampMode === 'auto' ? (
                  <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                    {scenarioType === 'New'
                      ? '🔄 New flood: Yr 0-1 reservoir filling (ratio ~50× base, minimal oil) → Yr 1-3 ratio rapidly improves → Yr 3-5 approaches design → Yr 5-7 at steady-state → Yr 7+ slight degradation. Based on EERC/Bell Creek/OGJ data.'
                      : '📊 Existing flood: starts at ~1.1× base, reaches steady-state in year 1, slight degradation (~1.5%/yr) after 50% of project life.'}
                  </div>
                ) : (
                  <div className="mt-1 mb-1">
                    <div className="text-xs text-gray-500 mb-1" style={{fontSize:'10px'}}>
                      Define breakpoints: year → multiplier of base ratio. 1.0× = steady-state. Values interpolated linearly between points.
                    </div>
                    <div className="bg-gray-50 rounded p-1.5 space-y-1">
                      {customRamp.map((pt, idx) => (
                        <div key={idx} className="flex items-center gap-1.5">
                          <span className="text-xs text-gray-500 w-6">Yr</span>
                          <input type="number" value={pt.year} step={0.5} min={0}
                            onChange={(e) => { const v = parseFloat(e.target.value) || 0; setCustomRamp(prev => prev.map((p, i) => i === idx ? {...p, year: v} : p)); }}
                            className="w-14 text-xs border border-gray-300 rounded px-1 py-0.5 text-right" />
                          <span className="text-xs text-gray-500">→</span>
                          <input type="number" value={pt.mult} step={0.5} min={0.1}
                            onChange={(e) => { const v = parseFloat(e.target.value) || 1; setCustomRamp(prev => prev.map((p, i) => i === idx ? {...p, mult: v} : p)); }}
                            className="w-14 text-xs border border-gray-300 rounded px-1 py-0.5 text-right" />
                          <span className="text-xs text-gray-400">×</span>
                          {customRamp.length > 2 && (
                            <button onClick={() => setCustomRamp(prev => prev.filter((_, i) => i !== idx))}
                              className="text-red-400 hover:text-red-600 text-xs px-0.5" title="Remove breakpoint">✕</button>
                          )}
                        </div>
                      ))}
                      <button onClick={() => {
                        const lastYr = customRamp.length > 0 ? customRamp[customRamp.length - 1].year + 1 : 0;
                        setCustomRamp(prev => [...prev, { year: lastYr, mult: 1.0 }]);
                      }} className="text-xs text-green-700 hover:text-green-900 font-medium mt-0.5">+ Add Breakpoint</button>
                    </div>
                    <div className="mt-1">
                      <InputField label="Post-Ramp Degrade" value={customDegradation} onChange={setCustomDegradation} unit="%/yr" step={0.5}
                        tooltip="Annual degradation rate after last breakpoint. Ratio increases (less oil per CO₂) as CO₂ channels through swept zones." />
                    </div>
                    <div className="flex gap-1 mt-1">
                      <button onClick={() => setCustomRamp([{year:0,mult:50},{year:0.5,mult:15},{year:1,mult:5},{year:2,mult:2.5},{year:3,mult:1.5},{year:5,mult:1.0},{year:7,mult:1.0}])}
                        className="text-xs text-blue-600 hover:text-blue-800 border border-blue-200 rounded px-1.5 py-0.5">New Flood Preset</button>
                      <button onClick={() => setCustomRamp([{year:0,mult:1.1},{year:1,mult:1.0},{year:Math.max(6, producingYears/2),mult:1.0}])}
                        className="text-xs text-blue-600 hover:text-blue-800 border border-blue-200 rounded px-1.5 py-0.5">Existing Preset</button>
                    </div>
                  </div>
                )}
                <OutputRow label="Lifetime Avg Ratio" value={`${calcs.lifetimeCo2OilRatio.toFixed(3)}`} unit="t/bbl"
                  tooltip="Average tonnes CO₂ per barrel over project life (includes ramp and decline)" />
              </Section>
            </div>

            <div>
              <Section title="CO₂ Injection" >
                <InputField label="Inj. Well Count" value={injWellCount} onChange={setInjWellCount} unit="wells" step={5} />
                <InputField label="Injection/Well/Yr" value={injPerWellPerYr} onChange={setInjPerWellPerYr} unit="t CO₂" step={5000} />
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Total Annual Injection" value={(injPerWellPerYr * injWellCount / 1e6).toFixed(2)} unit="Mt CO₂" />
                  <OutputRow label="Producer:Injector" value={(prodWellCount / injWellCount).toFixed(2)} unit="ratio" />
                </div>
              </Section>

              <Section title="CO₂ Recycle" >
                <div className="flex items-center justify-between py-1">
                  <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                    title="Fixed: constant recycle rate throughout project. Ramping: CO₂ recycle increases over time as CO₂ breaks through to production wells (based on field data).">Recycle Mode</label>
                  <select value={recycleMode} onChange={(e) => setRecycleMode(e.target.value)}
                    className="text-xs bg-white border border-gray-300 rounded px-1.5 py-0.5 text-gray-800 focus:outline-none focus:border-green-600">
                    <option value="ramping">Ramping</option>
                    <option value="fixed">Fixed</option>
                  </select>
                </div>
                {recycleMode === 'fixed' ? (
                  <InputField label="Recycle Rate" value={fixedRecycleRate} onChange={setFixedRecycleRate} unit="%" step={5}
                    tooltip="Fixed percentage of injected CO₂ that is recycled (produced and re-injected)" />
                ) : (
                  <div className="text-xs text-gray-500 px-1 py-0.5 mt-0.5 bg-gray-50 rounded leading-relaxed">
                    S-curve ramp based on field data: 0% → 10% (yr 1–3) → 30% (yr 6) → 55% (yr 10) → 70% (yr 15) → 80%+ plateau
                  </div>
                )}
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Year 1 Recycle" value={`${(recycleMode === 'fixed' ? fixedRecycleRate : 0).toFixed(0)}%`}
                    tooltip="Recycle fraction at start of project" />
                  <OutputRow label={`Year ${producingYears} Recycle`}
                    value={`${(recycleMode === 'fixed' ? fixedRecycleRate : (() => {
                      const y = producingYears;
                      if (y <= 1) return 0; if (y <= 3) return Math.min(10, (y-1)*5);
                      if (y <= 6) return Math.min(30, 10+(y-3)*6.7); if (y <= 10) return Math.min(55, 30+(y-6)*6.25);
                      if (y <= 15) return Math.min(70, 55+(y-10)*3); if (y <= 20) return Math.min(80, 70+(y-15)*2);
                      return Math.min(85, 80+(y-20)*0.5);
                    })()).toFixed(0)}%`}
                    tooltip="Recycle fraction at end of project" />
                </div>
              </Section>

              <Section title="CO₂ Pricing" >
                <InputField label="CO₂ Price" value={co2Price} onChange={setCo2Price} unit="$/t" step={5}
                  tooltip="Negative = purchasing CO₂. Zero = free. Positive = receiving payment to take CO₂ (e.g. emitter paying you)" />
                <div className="text-xs text-gray-500 px-1 py-0.5 mt-0.5 bg-gray-50 rounded">
                  {co2Price < 0 ? `💰 Purchasing CO₂ at $${Math.abs(co2Price)}/t` :
                    co2Price === 0 ? '🆓 Receiving CO₂ for free' :
                      `📈 Receiving $${co2Price}/t for taking CO₂`}
                </div>
                <InputField label="Recycle CO₂ Cost 🔗" value={recycledCo2Cost} onChange={setRecycledCo2CostLinked} unit="$/t" step={1}
                  tooltip="Cost to process and recycle produced CO₂ back into injection stream. Linked to Recycle OPEX in CCUS section — changing either updates both." />
              </Section>
            </div>

            <div>
              <Section title="Production OPEX" >
                <InputField label="Oil Prod. OPEX" value={prodOpex} onChange={setProdOpex} unit="$/bbl" step={1} />
                <InputField label="Oil Transport" value={oilTransport} onChange={setOilTransport} unit="$/bbl" step={1} />
                <OutputRow label="Severance Tax" value={`${severanceTax}%`}
                  tooltip={`Set by state selection (${STATE_TAX_CONFIG[selectedState]?.name}). EOR rate: ${computedEORSeverance}%`} />
              </Section>

              <Section title="CCUS CAPEX" >
                {!fullValueChain && (
                  <div className="text-xs text-gray-500 px-1 py-0.5 mb-1 bg-gray-50 rounded">
                    ℹ️ Capture & Transport disabled — enable "Full Chain" to include upstream economics
                  </div>
                )}
                {fullValueChain && (
                  <div className="flex items-center justify-between py-1">
                    <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                      title="Auto-calculate Capture and Transport CAPEX from CO₂ source purity, injection rate, and pipeline engineering using NETL/IEA literature data">Auto-Calc from Literature</label>
                    <button onClick={() => setAutoCalcCapex(!autoCalcCapex)}
                      className="w-10 h-5 rounded-full transition-colors relative"
                      style={{ backgroundColor: autoCalcCapex ? '#16a34a' : '#d1d5db' }}>
                      <div className="w-4 h-4 rounded-full bg-white absolute top-0.5 transition-all shadow"
                        style={{ left: autoCalcCapex ? '22px' : '2px' }} />
                    </button>
                  </div>
                )}
                {fullValueChain && autoCalcCapex && (
                  <>
                    <div className="flex items-center justify-between py-1">
                      <label className="text-gray-700 text-xs cursor-help border-b border-dotted border-gray-400"
                        title="CO₂ source type determines flue gas concentration, which drives capture CAPEX and OPEX. High-purity sources (>90%) need only compression; low-purity (<15%) require full amine scrubbing.">CO₂ Source</label>
                      <select value={co2SourceType} onChange={e => {
                        setCo2SourceType(e.target.value);
                        if (e.target.value !== 'custom') setCo2Concentration(CO2_SOURCES[e.target.value].conc);
                      }} className="border border-gray-300 rounded px-1.5 py-0.5 text-xs bg-white text-gray-800 focus:outline-none focus:border-green-600" style={{maxWidth:'140px'}}>
                        {Object.entries(CO2_SOURCES).map(([k, v]) => (
                          <option key={k} value={k}>{v.label}</option>
                        ))}
                      </select>
                    </div>
                    <div className="text-xs text-gray-500 px-1 py-0.5 bg-gray-50 rounded mb-1" style={{fontSize:'10px'}}>
                      {(CO2_SOURCES[co2SourceType] || CO2_SOURCES.ngp).desc}
                    </div>
                    {co2SourceType === 'custom' && (
                      <InputField label="CO₂ Concentration" value={co2Concentration} onChange={setCo2Concentration} unit="vol%" step={1}
                        tooltip="Flue gas CO₂ concentration. Higher = cheaper capture. Range 4-99%. Drives CAPEX via piecewise NETL/IEA curve." />
                    )}
                    <InputField label="Pipeline Distance" value={pipelineDistance} onChange={setPipelineDistance} unit="mi" step={10}
                      tooltip="CO₂ pipeline length in miles. Drives transport CAPEX via inch-mile formula." />
                    <InputField label="Pipeline $/inch-mi" value={pipelineCostPerInchMile} onChange={setPipelineCostPerInchMile} unit="$" step={5000}
                      tooltip="Pipeline cost per inch-mile. Literature range: $51k-$228k (Trimeric: $51-119k mid-range; EPA Platform v6: $228k). Default $85k = mid-range 2024$." />
                  </>
                )}
                <InputField label="Capture CAPEX" value={captureCapex} onChange={setCaptureCapex} unit="$MM" step={5}
                  disabled={!fullValueChain || (fullValueChain && autoCalcCapex)}
                  tooltip={fullValueChain && autoCalcCapex
                    ? `Auto: ${computedCapex.capexPerTpa} $/tpa × ${(computedCapex.annualInjectionMt * 1e6).toLocaleString()} t/yr = $${computedCapex.captureCapex.toFixed(1)}MM (base: ${computedCapex.baseCapexPerTpa} $/tpa at ${computedCapex.co2Concentration}% CO₂, scaled for ${computedCapex.annualInjectionMt.toFixed(2)} Mt/yr)`
                    : 'Carbon capture facility capital cost (enable Full Chain + Auto-Calc)'} />
                <InputField label="Recycle CAPEX" value={recycleCapex} onChange={setRecycleCapex} unit="$MM" step={5}
                  tooltip="CO₂ recycle plant capital cost. Auto-set by flood type using OSTI gas processing formula" />
                <InputField label="Storage CAPEX" value={storageCapex} onChange={setStorageCapex} unit="$MM" step={5}
                  tooltip="Site characterization, monitoring wells, MRV systems." />
                <div className="ml-2 pl-2 border-l-2 border-gray-200">
                  <InputField label="Wells to Retrofit" value={retrofitWellCount} onChange={setRetrofitWellCount} unit="wells" step={5}
                    tooltip="Number of existing wells needing conversion for CO₂ service. May include injectors, producers, or WAG wells. Cost per well calculated from depth × $/ft in Well Costs section." />
                  {retrofitWellCount > 0 && (
                    <OutputRow label="Retrofit Total" value={`$${(retrofitCostPerWell * retrofitWellCount / 1e6).toFixed(1)}`} unit="MM"
                      tooltip={`${retrofitWellCount} wells × $${computedWellCosts.retrofitCostK.toFixed(0)}k/well (from ${wellDepth.toLocaleString()} ft × $${retrofitCostPerFt}/ft)`} />
                  )}
                </div>
                <InputField label="Transport CAPEX" value={transportCapex} onChange={setTransportCapex} unit="$MM" step={1}
                  disabled={!fullValueChain || (fullValueChain && autoCalcCapex)}
                  tooltip={fullValueChain && autoCalcCapex
                    ? `Auto: ${computedCapex.pipeDiameterIn}" × ${pipelineDistance} mi × $${(pipelineCostPerInchMile/1000).toFixed(0)}k/in-mi × 1.15 = $${computedCapex.transportCapex.toFixed(1)}MM`
                    : 'CO₂ pipeline/transport capital cost (enable Full Chain + Auto-Calc)'} />
                <div className="mt-1 pt-1 border-t border-gray-200">
                  <OutputRow label="Total CCUS CAPEX" value={`$${(
                    (fullValueChain ? captureCapex : 0) + recycleCapex + storageCapex + (retrofitCostPerWell * retrofitWellCount / 1e6) + (fullValueChain ? transportCapex : 0)
                  ).toFixed(1)}`} unit="MM" />
                  {fullValueChain && autoCalcCapex && (
                    <>
                      <OutputRow label="Capture $/tpa" value={`$${computedCapex.capexPerTpa}`}
                        tooltip={`Capture CAPEX per tonne-annual-capacity. Base: $${computedCapex.baseCapexPerTpa}/tpa at ${computedCapex.co2Concentration}% CO₂ (1 Mt/yr ref), scaled to $${computedCapex.capexPerTpa}/tpa at ${computedCapex.annualInjectionMt.toFixed(2)} Mt/yr`} />
                      <OutputRow label="Pipeline" value={`${computedCapex.pipeDiameterIn}" × ${pipelineDistance} mi`}
                        tooltip={`Nominal diameter: ${computedCapex.pipeDiameterIn}" (from D=5.35×Q^0.45). At $${(pipelineCostPerInchMile/1000).toFixed(0)}k/inch-mile`} />
                    </>
                  )}
                </div>
              </Section>

              <Section title="CCUS OPEX" >
                <InputField label="Capture OPEX" value={captureOpex} onChange={setCaptureOpex} unit="$/t" step={1}
                  disabled={!fullValueChain || (fullValueChain && autoCalcCapex && co2SourceType !== 'custom')}
                  tooltip={fullValueChain && autoCalcCapex
                    ? `Auto from source: $${computedCapex.captureOpexRef}/t for ${(CO2_SOURCES[co2SourceType] || CO2_SOURCES.ngp).label}. Covers energy, chemicals, maintenance.`
                    : 'Cost per tonne to capture CO₂ at source.'} />
                <InputField label="Recycle OPEX 🔗" value={recycleOpex} onChange={setRecycleOpexLinked} unit="$/t" step={1}
                  tooltip={`Energy-intensive gas processing. Model formula: WTI×0.01×19 = $${computedCapex.recycleOpex.toFixed(2)}/t at $${wtiPrice} WTI. Linked to Recycle CO₂ Cost in Pricing section — changing either updates both.`} />
                <InputField label="Storage OPEX" value={storageOpex} onChange={setStorageOpex} unit="$/t" step={0.5}
                  tooltip={`Well monitoring & maintenance. Model formula: (34k+4×5k)×1.5/inj_per_well = $${computedCapex.storageOpex.toFixed(2)}/t at ${injPerWellPerYr.toLocaleString()} t/well/yr`} />
                <InputField label="Transport OPEX" value={transportOpex} onChange={setTransportOpex} unit="$/t" step={0.5}
                  disabled={!fullValueChain}
                  tooltip="Pipeline operating cost per tonne. Reference: $1.00/t (Enverus model)" />
              </Section>
            </div>
              </>
            )}
          </div>
        )}

        {activeTab === 'results' && (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
            {/* Key Metrics */}
            <div>
              <Section title="Key Metrics" >
                <OutputRow label="Project NPV" value={`$${calcs.projectNpv.toFixed(1)}MM`} highlight tooltip="Net Present Value of EOR project including all cash flows (pre-tax)" />
                <OutputRow label="Project IRR" value={calcs.projectIrr === Infinity ? '∞' : calcs.projectIrr === -Infinity ? '-∞' : calcs.projectIrr <= -99 ? '< -99%' : `${calcs.projectIrr.toFixed(1)}%`} highlight
                  tooltip="Internal Rate of Return - discount rate at which NPV equals zero (pre-tax)" />
                <OutputRow label="Breakeven Oil" value={`$${calcs.breakevenOil.toFixed(1)}/bbl`}
                  tooltip="WTI price at which project NPV = 0" />
                <OutputRow label={enableTaxCalc ? "LCOO (After-Tax)" : "LCOO"} 
                  value={`$${(enableTaxCalc && calcs.afterTaxLcoo != null ? calcs.afterTaxLcoo : calcs.lcoo).toFixed(2)}/bbl`}
                  tooltip={enableTaxCalc 
                    ? `After-tax levelized cost: includes IDC, depreciation, and depletion shields. Pre-tax: $${calcs.lcoo.toFixed(2)}/bbl` 
                    : "Levelized Cost of Oil - total cost (CAPEX + OPEX) per barrel produced"} />
                <OutputRow label={enableTaxCalc ? "Margin (After-Tax)" : "Margin"} 
                  value={`$${(enableTaxCalc && calcs.afterTaxMargin != null ? calcs.afterTaxMargin : calcs.margin).toFixed(2)}/bbl`} highlight
                  tooltip="Net oil price minus LCOO - profit per barrel" />
                {enableTaxCalc && calcs.taxShieldTotal != null && calcs.taxShieldTotal > 0 && (
                  <OutputRow label="Tax Shield" value={`$${calcs.taxShieldTotal.toFixed(2)}MM`}
                    tooltip="Total tax benefits: IDC deduction + depreciation shield + depletion allowance + §43 credit" />
                )}
                <OutputRow label="PIR" value={calcs.pir === Infinity ? '∞' : calcs.pir.toFixed(2)}
                  tooltip="Profitability Index Ratio = NPV / CAPEX" />
                <OutputRow label="Payback" value={calcs.paybackYears} unit="yrs"
                  tooltip="Time to recover initial CAPEX from cash flows" />
                <OutputRow label="CO₂/Oil (lifetime)" value={`${calcs.lifetimeCo2OilRatio.toFixed(3)}`} unit="t/bbl"
                  tooltip="Average tonnes CO₂ per barrel over full project life (includes ramp)" />
              </Section>

              <Section title="Revenue Summary" >
                <OutputRow label="Total Oil Revenue" value={`$${calcs.totalOilRevenue.toFixed(1)}MM`} />
                <OutputRow label="Total 45Q Credits" value={`$${calcs.totalCO2CreditRevenue.toFixed(1)}MM`} />
                <OutputRow label="Total Revenue" value={`$${calcs.totalRevenue.toFixed(1)}MM`} highlight />
              </Section>
            </div>

            <div>
              <Section title="CAPEX Breakdown" >
                {(() => {
                  // Determine well label based on newWellsPct
                  const wellLabel = newWellsPct === 0 ? 'Retrofit' : newWellsPct === 100 ? 'New' : `${newWellsPct}% New`;
                  const totalWellCapex = (calcs.injWellCapex || 0) + (calcs.prodWellCapexTotal || 0) + (calcs.wellRetrofitCapex || 0);
                  
                  if (totalWellCapex > 0) {
                    return <OutputRow label={`${wellLabel} Wells`} value={`$${totalWellCapex.toFixed(1)}MM`}
                      tooltip={newWellsPct === 0 ? "Converting existing wells for CO₂ service" : 
                               newWellsPct === 100 ? "Drilling new wells" : 
                               `${newWellsPct}% new drilling, ${100-newWellsPct}% retrofit`} />;
                  }
                  return null;
                })()}
                {(calcs.feederPipeCapex || 0) > 0 && <OutputRow label="Feeder Pipelines" value={`$${calcs.feederPipeCapex.toFixed(2)}MM`}
                  tooltip="Infield gathering system connecting patterns to trunk line" />}
                {/* CCUS Infrastructure breakdown */}
                {calcs.captureCapex > 0 && <OutputRow label="Capture Facility" value={`$${calcs.captureCapex.toFixed(1)}MM`} />}
                {calcs.recycleCapex > 0 && <OutputRow label="Recycle Facility" value={`$${calcs.recycleCapex.toFixed(1)}MM`} />}
                {calcs.storageCapex > 0 && <OutputRow label="Storage (MMV)" value={`$${calcs.storageCapex.toFixed(1)}MM`} />}
                {calcs.pipelineCapex > 0 && <OutputRow label="Trunk Pipeline" value={`$${calcs.pipelineCapex.toFixed(1)}MM`} />}
                <OutputRow label="Total CAPEX" value={`$${calcs.totalCapex.toFixed(1)}MM`} highlight />
              </Section>

              <Section title="OPEX Breakdown" >
                {/* Header row */}
                <div className="flex items-center justify-between py-0.5 border-b border-gray-200 mb-1">
                  <span className="text-xs text-gray-500 font-medium"></span>
                  <div className="flex gap-3">
                    <span className="text-xs text-gray-500 font-medium w-20 text-right">Total</span>
                    <span className="text-xs text-gray-500 font-medium w-16 text-right">$/yr</span>
                  </div>
                </div>
                {/* OPEX rows */}
                {[
                  { label: 'Oil Production', total: calcs.oilOpex, show: true },
                  { label: 'Oil Transport', total: calcs.oilTransportCost, show: true },
                  { label: 'Severance Tax', total: calcs.severanceTaxCost, show: true },
                  { label: 'CO₂ Purchase', total: calcs.co2PurchaseCost, show: calcs.co2PurchaseCost > 0 },
                  { label: 'CO₂ Recycle', total: calcs.recycleOpexCost, show: true },
                  { label: 'CO₂ Capture', total: calcs.captureOpexCost, show: calcs.captureOpexCost > 0 },
                  { label: 'CO₂ Storage', total: calcs.storageOpexCost, show: true },
                  { label: 'CO₂ Transport', total: calcs.transportOpexCost, show: calcs.transportOpexCost > 0 },
                ].filter(r => r.show).map(row => (
                  <div key={row.label} className="flex items-center justify-between py-0.5">
                    <span className="text-xs text-gray-600">{row.label}</span>
                    <div className="flex gap-3">
                      <span className="text-xs text-gray-800 w-20 text-right">${row.total.toFixed(1)}MM</span>
                      <span className="text-xs text-gray-500 w-16 text-right">${(row.total / calcs.actualProjectYears).toFixed(2)}MM</span>
                    </div>
                  </div>
                ))}
                {/* Total row */}
                <div className="flex items-center justify-between py-1 mt-1 border-t border-gray-300 bg-blue-50 -mx-2 px-2">
                  <span className="text-xs font-semibold text-gray-700">Total OPEX</span>
                  <div className="flex gap-3">
                    <span className="text-xs font-semibold text-gray-800 w-20 text-right">${calcs.totalOpex.toFixed(1)}MM</span>
                    <span className="text-xs font-semibold text-gray-600 w-16 text-right">${(calcs.totalOpex / calcs.actualProjectYears).toFixed(2)}MM</span>
                  </div>
                </div>
              </Section>
            </div>

            <div>
              <Section title="Production" >
                <OutputRow label="Annual Oil Production" value={calcs.annualProduction.toLocaleString()} unit="bbl" />
                <OutputRow label="Total Oil Production" value={`${(calcs.totalProduction / 1e6).toFixed(1)}MM`} unit="bbl" />
                <OutputRow label="Annual CO₂ Stored" value={`${calcs.annualCO2Stored.toFixed(2)}`} unit="Mt/yr" />
                <OutputRow label="Total CO₂ Injected" value={`${calcs.totalCO2Injected.toFixed(1)}`} unit="Mt" />
                <OutputRow label="Total CO₂ Stored" value={`${calcs.totalCO2Stored.toFixed(1)}`} unit="Mt" />
                <OutputRow label="Storage Efficiency" value={`${(calcs.totalCO2Stored / calcs.totalCO2Injected * 100).toFixed(0)}%`}
                  tooltip="Fraction of injected CO₂ that remains permanently stored" />
              </Section>

              {modelMode === 'pattern' && (
                <Section title="Development Timeline">
                  <OutputRow label="Project Duration" value={calcs.actualProjectYears} unit="yrs"
                    tooltip="Actual simulated project life until all patterns abandoned" />
                  <OutputRow label="Patterns Developed" value={`${calcs.totalPatternsDeveloped} / ${patternDerived.maxPatterns}`}
                    tooltip="Patterns activated vs maximum possible" />
                  <OutputRow label="Final Active" value={calcs.finalActivePatterns} unit="patterns"
                    tooltip="Patterns still producing at project end (in blowdown or active)" />
                  <OutputRow label="Injectors" value={calcs.cumulativeInjectors}
                    tooltip="Total injection wells developed" />
                  <OutputRow label="Producers" value={calcs.cumulativeProducers}
                    tooltip="Total production wells (shared between adjacent patterns)" />
                </Section>
              )}

              <Section title="Unit Economics" >
                <OutputRow label="Net Oil Price" value={`$${(wtiPrice - oilDiff).toFixed(0)}`} unit="/bbl" />
                <OutputRow label="LCOO" value={`$${calcs.lcoo.toFixed(2)}`} unit="/bbl" highlight
                  tooltip="Levelized Cost of Oil - total cost (CAPEX + OPEX) per barrel" />
                <OutputRow label="Margin" value={`$${calcs.margin.toFixed(2)}`} unit="/bbl" highlight
                  tooltip="Net oil price minus LCOO" />
                <OutputRow label="Oil OPEX" value={`$${prodOpex}`} unit="/bbl" />
                <OutputRow label="$/bbl CO₂ Handling" value={`$${(calcs.totalOpex * 1e6 / calcs.totalProduction - prodOpex - oilTransport).toFixed(2)}`} unit="/bbl"
                  tooltip="Total CO₂-related costs per barrel of oil produced" />
              </Section>
            </div>
          </div>
        )}

        {activeTab === 'charts' && (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
            {/* Cumulative Cash Flow */}
            <div className="bg-white border border-gray-200 rounded p-3">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Cumulative Cash Flow</h3>
              <ResponsiveContainer width="100%" height={280}>
                <AreaChart data={calcs.monthlyData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                  <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor(calcs.monthlyData.length / 8)} />
                  <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `$${v.toFixed(0)}M`} />
                  <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                    formatter={(v, name) => [`$${v.toFixed(1)}MM`, name]} />
                  <ReferenceLine y={0} stroke="#6b7280" strokeDasharray="3 3" />
                  <Area type="monotone" dataKey="cumulativeCF" name="EOR Project" fill="#15803d33" stroke="#15803d" strokeWidth={2} />
                  <Legend wrapperStyle={{ fontSize: '10px' }} />
                </AreaChart>
              </ResponsiveContainer>
            </div>

            {/* Production & CO₂/Oil Ratio */}
            <div className="bg-white border border-gray-200 rounded p-3">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Oil Production & CO₂/Oil Ratio</h3>
              <ResponsiveContainer width="100%" height={280}>
                <LineChart data={calcs.monthlyData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                  <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor(calcs.monthlyData.length / 8)} />
                  <YAxis yAxisId="prod" tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1000).toFixed(0)}k`} />
                  <YAxis yAxisId="ratio" orientation="right" tick={{ fill: "#8b5cf6", fontSize: 10 }} tickFormatter={v => `${v.toFixed(1)}`} />
                  <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                    formatter={(v, name) => [
                      name.includes('Ratio') ? `${v.toFixed(2)} t/bbl` : 
                      name.includes('Profile') ? `${v.toFixed(0)}%` :
                      name.includes('Patterns') ? `${v} patterns` :
                      `${v.toLocaleString()} bbl/mo`, name
                    ]} />
                  <Line yAxisId="prod" type="monotone" dataKey="eorProd" name="Oil Production" stroke="#15803d" strokeWidth={2} dot={false} />
                  <Line yAxisId="ratio" type="monotone" dataKey="effectiveRatio" name="CO₂/Oil Ratio (t/bbl)" stroke="#8b5cf6" strokeWidth={2} dot={false} strokeDasharray="5 5" />
                  {!prodProfileFlat && modelMode === 'simple' && <Line yAxisId="ratio" type="monotone" dataKey="prodMultiplier" name="Prod Profile (%)" stroke="#f59e0b" strokeWidth={1.5} dot={false} strokeDasharray="2 2" />}
                  {modelMode === 'pattern' && <Line yAxisId="ratio" type="monotone" dataKey="activePatterns" name="Active Patterns" stroke="#f59e0b" strokeWidth={2} dot={false} />}
                  <Legend wrapperStyle={{ fontSize: '10px' }} />
                </LineChart>
              </ResponsiveContainer>
            </div>

            {/* Revenue vs Costs */}
            <div className="bg-white border border-gray-200 rounded p-3">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Monthly Revenue vs Costs</h3>
              <ResponsiveContainer width="100%" height={280}>
                <BarChart data={calcs.monthlyData?.map(d => ({
                  ...d,
                  costsNegative: -(d.totalCosts || 0),
                  capexNegative: -(d.monthlyCapex || 0)
                })) || []}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                  <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 8)} />
                  <YAxis 
                    tick={{ fill: "#6b7280", fontSize: 10 }} 
                    tickFormatter={v => {
                      if (Math.abs(v) >= 1) return `$${v.toFixed(1)}M`;
                      if (Math.abs(v) >= 0.1) return `$${(v * 1000).toFixed(0)}k`;
                      return `$${(v * 1000).toFixed(1)}k`;
                    }}
                    domain={['auto', 'auto']}
                  />
                  <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                    formatter={(v, name) => [`$${Math.abs(v).toFixed(3)}MM`, name.includes('Negative') ? name.replace(' (Negative)', '') : name]} />
                  <ReferenceLine y={0} stroke="#374151" strokeWidth={1} />
                  <Bar dataKey="oilRevenue" name="Oil Revenue" stackId="pos" fill="#f59e0b" />
                  <Bar dataKey="creditRevenue" name="45Q Credit" stackId="pos" fill="#14b8a6" />
                  <Bar dataKey="costsNegative" name="OPEX" stackId="neg" fill="#ef4444" />
                  <Bar dataKey="capexNegative" name="CAPEX" stackId="neg" fill="#991b1b" />
                  <Legend wrapperStyle={{ fontSize: '10px' }} />
                </BarChart>
              </ResponsiveContainer>
            </div>

            {/* CO2 Storage & Recycle */}
            <div className="bg-white border border-gray-200 rounded p-3">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CO₂ Recycle Fraction Over Time</h3>
              <ResponsiveContainer width="100%" height={280}>
                <AreaChart data={calcs.monthlyData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                  <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor(calcs.monthlyData.length / 8)} />
                  <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${v.toFixed(0)}%`} domain={[0, 100]} />
                  <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                    formatter={(v) => [`${v.toFixed(1)}%`, 'Recycle %']} />
                  <Area type="monotone" dataKey="recycleFraction" fill="#8b5cf633" stroke="#8b5cf6" strokeWidth={2} />
                </AreaChart>
              </ResponsiveContainer>
            </div>

            {/* CAPEX Pie */}
            {capexBreakdown.length > 0 && (
              <div className="bg-white border border-gray-200 rounded p-3">
                <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CAPEX Breakdown</h3>
                <ResponsiveContainer width="100%" height={280}>
                  <PieChart>
                    <Pie data={capexBreakdown} cx="50%" cy="50%" outerRadius={90} dataKey="value" label={({ name, value }) => `${name}: $${value.toFixed(1)}MM`}>
                      {capexBreakdown.map((_, i) => <Cell key={i} fill={COLORS[i % COLORS.length]} />)}
                    </Pie>
                    <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                      formatter={(v) => [`$${v.toFixed(1)}MM`]} />
                  </PieChart>
                </ResponsiveContainer>
              </div>
            )}

            {/* OPEX Pie */}
            <div className="bg-white border border-gray-200 rounded p-3">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Total OPEX Breakdown</h3>
              <ResponsiveContainer width="100%" height={280}>
                <PieChart>
                  <Pie data={opexBreakdown} cx="50%" cy="50%" outerRadius={90} dataKey="value" label={({ name, value }) => `${name}: $${value.toFixed(0)}MM`}>
                    {opexBreakdown.map((_, i) => <Cell key={i} fill={COLORS[i % COLORS.length]} />)}
                  </Pie>
                  <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                    formatter={(v) => [`$${v.toFixed(1)}MM`]} />
                </PieChart>
              </ResponsiveContainer>
            </div>

            {/* LCOO Waterfall */}
            <div className="bg-white border border-gray-200 rounded p-3 sm:col-span-2 lg:col-span-2 xl:col-span-2">
              <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">LCOO Waterfall ($/bbl)</h3>
              {(() => {
                const prod = calcs.totalProduction || 1;
                const perBbl = (val) => ((val || 0) * 1e6) / prod;
                const perBblCapex = (val) => ((val || 0) * 1e6) / prod;
                
                const items = [
                  { name: 'Wells', value: perBbl(calcs.injWellCapex) + perBbl(calcs.prodWellCapexTotal) + perBbl(calcs.wellRetrofitCapex), type: 'capex' },
                  { name: 'Feeder Pipe', value: perBbl(calcs.feederPipeCapex), type: 'capex' },
                  { name: 'Recycle Fac.', value: perBblCapex(calcs.recycleCapex), type: 'capex' },
                  { name: 'Storage Fac.', value: perBblCapex(calcs.storageCapex), type: 'capex' },
                  fullValueChain ? { name: 'Capture Fac.', value: perBblCapex(calcs.captureCapex), type: 'capex' } : null,
                  fullValueChain ? { name: 'CO₂ Pipeline', value: perBblCapex(calcs.pipelineCapex), type: 'capex' } : null,
                  { name: 'Lifting', value: perBbl(calcs.oilOpex), type: 'opex' },
                  { name: 'Oil Trans.', value: perBbl(calcs.oilTransportCost), type: 'opex' },
                  { name: 'Sev. Tax', value: perBbl(calcs.severanceTaxCost), type: 'opex' },
                  { name: 'CO₂ Purch.', value: perBbl(calcs.co2PurchaseCost), type: 'opex' },
                  { name: 'Recycle Op.', value: perBbl(calcs.recycleOpexCost), type: 'opex' },
                  fullValueChain ? { name: 'Capture Op.', value: perBbl(calcs.captureOpexCost), type: 'opex' } : null,
                  { name: 'Storage Op.', value: perBbl(calcs.storageOpexCost), type: 'opex' },
                  fullValueChain ? { name: 'CO₂ Trans.', value: perBbl(calcs.transportOpexCost), type: 'opex' } : null,
                  creditEnabled ? { name: '45Q Credit', value: perBbl(calcs.totalCO2CreditRevenue), type: 'credit' } : null,
                ].filter(d => d && d.value > 0.005);
                
                let runningTotal = 0;
                const waterfallData = items.map((item) => {
                  const start = runningTotal;
                  if (item.type === 'credit') {
                    runningTotal -= item.value;
                  } else {
                    runningTotal += item.value;
                  }
                  return {
                    name: item.name,
                    start: item.type === 'credit' ? runningTotal : start,
                    value: item.value,
                    type: item.type,
                    total: runningTotal,
                  };
                });
                
                const netLcoo = calcs.lcoo || 0;
                waterfallData.push({ name: 'Net LCOO', start: 0, value: netLcoo, type: 'total', total: netLcoo });
                const maxVal = Math.max(...waterfallData.map(d => d.total), netLcoo) * 1.1;
                
                return (
                  <ResponsiveContainer width="100%" height={280}>
                    <BarChart data={waterfallData} margin={{ top: 10, right: 20, left: 5, bottom: 50 }}>
                      <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                      <XAxis dataKey="name" tick={{ fill: "#6b7280", fontSize: 8 }} angle={-45} textAnchor="end" height={60} interval={0} />
                      <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `$${v.toFixed(0)}`} domain={[0, maxVal]} />
                      <Tooltip formatter={(v, name, props) => {
                        if (name === 'start') return [null, null];
                        const item = props.payload;
                        if (item.type === 'credit') return [`-$${v.toFixed(2)}/bbl`, '45Q Credit'];
                        if (item.type === 'total') return [`$${v.toFixed(2)}/bbl`, 'Net LCOO'];
                        return [`$${v.toFixed(2)}/bbl`, item.type === 'capex' ? 'CAPEX' : 'OPEX'];
                      }} />
                      <Bar dataKey="start" stackId="waterfall" fill="transparent" />
                      <Bar dataKey="value" stackId="waterfall">
                        {waterfallData.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.type === 'credit' ? '#16a34a' : entry.type === 'total' ? '#1e40af' : entry.type === 'capex' ? '#6366f1' : '#f97316'} />
                        ))}
                      </Bar>
                      <ReferenceLine y={wtiPrice - oilDiff} stroke="#dc2626" strokeDasharray="5 5" label={{ value: `Oil: $${(wtiPrice-oilDiff).toFixed(0)}`, fill: '#dc2626', fontSize: 9, position: 'right' }} />
                    </BarChart>
                  </ResponsiveContainer>
                );
              })()}
              <div className="flex justify-between text-xs text-gray-600 mt-1 px-2">
                <span>
                  <span className="inline-block w-3 h-3 mr-1 rounded" style={{backgroundColor: '#6366f1'}}></span>CAPEX
                  <span className="inline-block w-3 h-3 ml-3 mr-1 rounded" style={{backgroundColor: '#f97316'}}></span>OPEX
                  <span className="inline-block w-3 h-3 ml-3 mr-1 rounded" style={{backgroundColor: '#16a34a'}}></span>Credit
                  <span className="inline-block w-3 h-3 ml-3 mr-1 rounded" style={{backgroundColor: '#1e40af'}}></span>Net
                </span>
                <span className={`font-semibold ${calcs.margin >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  Margin: ${calcs.margin?.toFixed(2)}/bbl
                </span>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'sensitivity' && (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 auto-rows-fr">
            {/* NPV vs Oil Price */}
            <div className="bg-white border border-gray-200 rounded flex flex-col">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV vs Oil Price (Current: ${wtiPrice}/bbl)</h3></div>
              <div className="p-2 flex-1 min-h-[200px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={oilPriceSensitivity} margin={{ left: 5, right: 10 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="price" tick={{ fontSize: 9 }} tickFormatter={v => `$${v}`} />
                    <YAxis tick={{ fontSize: 9 }} tickFormatter={v => `$${v.toFixed(0)}M`} />
                    <Tooltip formatter={(v) => `$${v.toFixed(1)}MM`} labelFormatter={l => `$${l}/bbl`} />
                    <ReferenceLine y={0} stroke="#666" strokeDasharray="3 3" />
                    <ReferenceLine y={calcs.projectNpv} stroke="#15803d" strokeDasharray="5 5" strokeWidth={2} />
                    <ReferenceLine x={wtiPrice} stroke="#15803d" strokeDasharray="3 3" />
                    <Line type="monotone" dataKey="npv" stroke="#15803d" strokeWidth={2} dot={{ r: 2 }} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* NPV vs CO2 Price */}
            <div className="bg-white border border-gray-200 rounded flex flex-col">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV vs CO₂ Price (Current: ${co2Price}/t)</h3></div>
              <div className="p-2 flex-1 min-h-[200px]">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={co2PriceSensitivity} margin={{ left: 5, right: 10 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="price" tick={{ fontSize: 9 }} tickFormatter={v => v < 0 ? `-$${-v}` : `$${v}`} />
                    <YAxis tick={{ fontSize: 9 }} tickFormatter={v => `$${v.toFixed(0)}M`} />
                    <Tooltip formatter={(v) => `$${v.toFixed(1)}MM`} labelFormatter={l => l < 0 ? `Buy $${-l}/t` : `Receive $${l}/t`} />
                    <ReferenceLine y={0} stroke="#666" strokeDasharray="3 3" />
                    <ReferenceLine y={calcs.projectNpv} stroke="#15803d" strokeDasharray="5 5" strokeWidth={2} />
                    <Bar dataKey="npv" fill="#14b8a6">
                      {co2PriceSensitivity.map((entry, i) => (
                        <Cell key={i} fill={entry.price === co2Price ? '#0d9488' : (entry.npv >= 0 ? '#14b8a6' : '#ef4444')} />
                      ))}
                    </Bar>
                  </BarChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* NPV vs CO2/Oil Ratio - wider chart */}
            <div className="bg-white border border-gray-200 rounded flex flex-col sm:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV vs CO₂/Oil Ratio (Current: {co2OilRatio} t/bbl)</h3></div>
              <div className="p-2 flex-1 min-h-[200px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={co2RatioSensitivity} margin={{ left: 5, right: 10 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="ratio" tick={{ fontSize: 9 }} tickFormatter={v => v.toFixed(1)} />
                    <YAxis tick={{ fontSize: 9 }} tickFormatter={v => `$${v.toFixed(0)}M`} />
                    <Tooltip formatter={(v) => `$${v.toFixed(1)}MM`} labelFormatter={l => `${l.toFixed(2)} t/bbl`} />
                    <ReferenceLine y={0} stroke="#666" strokeDasharray="3 3" />
                    <ReferenceLine y={calcs.projectNpv} stroke="#dc2626" strokeDasharray="5 5" strokeWidth={2} />
                    <ReferenceLine x={co2OilRatio} stroke="#dc2626" strokeDasharray="3 3" />
                    <Line type="monotone" dataKey="npv" stroke="#dc2626" strokeWidth={2} dot={{ r: 2 }} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* Combined NPV & IRR vs Facility Capacity */}
            <div className="bg-white border border-gray-200 rounded flex flex-col sm:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV & IRR vs Facility Size (Current: {facilitySize >= 1000000 ? `${(facilitySize/1000000).toFixed(1)}M` : `${(facilitySize/1000).toFixed(0)}k`} t/yr)</h3></div>
              <div className="p-2 flex-1 min-h-[220px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={facilityCapacitySensitivity.map(d => ({
                    ...d,
                    displayIrr: d.irr === Infinity || d.irr === -Infinity ? null : d.irr
                  }))} margin={{ left: 5, right: 5, top: 5, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="capacityLabel" tick={{ fontSize: 8 }} interval={0} angle={-45} textAnchor="end" height={40} />
                    <YAxis 
                      yAxisId="left" 
                      tick={{ fontSize: 9 }} 
                      tickFormatter={v => `$${v.toFixed(0)}M`}
                    />
                    <YAxis 
                      yAxisId="right" 
                      orientation="right" 
                      tick={{ fontSize: 9 }} 
                      tickFormatter={v => `${v.toFixed(0)}%`}
                    />
                    <Tooltip 
                      formatter={(v, name, props) => {
                        if (name === 'npv') return [`$${v.toFixed(1)}MM`, 'NPV'];
                        if (name === 'displayIrr') {
                          const irr = props.payload.irr;
                          if (irr === Infinity) return ['∞', 'IRR'];
                          if (irr === -Infinity) return ['-∞', 'IRR'];
                          if (irr <= -99) return ['< -99%', 'IRR'];
                          return [`${v.toFixed(1)}%`, 'IRR'];
                        }
                        return [v, name];
                      }} 
                      labelFormatter={(l, payload) => {
                        if (payload && payload[0]) {
                          const acres = payload[0].payload.optimalFieldSize;
                          return `${l} t/yr (Field: ${acres >= 1000 ? `${(acres/1000).toFixed(1)}k` : acres} ac)`;
                        }
                        return `${l} t/yr`;
                      }}
                    />
                    <Legend 
                      verticalAlign="top" 
                      height={25}
                      formatter={(value) => {
                        if (value === 'npv') return <span style={{color: '#7c3aed', fontSize: 9}}>NPV ($MM)</span>;
                        if (value === 'displayIrr') return <span style={{color: '#059669', fontSize: 9}}>IRR (%)</span>;
                        return value;
                      }}
                    />
                    <ReferenceLine yAxisId="left" y={0} stroke="#666" strokeDasharray="3 3" />
                    <Line yAxisId="left" type="monotone" dataKey="npv" stroke="#7c3aed" strokeWidth={2} dot={{ r: 3, fill: '#7c3aed' }} name="npv" />
                    <Line yAxisId="right" type="monotone" dataKey="displayIrr" stroke="#059669" strokeWidth={2} dot={{ r: 3, fill: '#059669' }} name="displayIrr" connectNulls={false} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* LCOO vs Facility Capacity */}
            <div className="bg-white border border-gray-200 rounded flex flex-col sm:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">LCOO{enableTaxCalc ? ' (After-Tax)' : ''} vs Facility Size</h3></div>
              <div className="p-2 flex-1 min-h-[220px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={facilityCapacitySensitivity.map(d => ({
                    ...d,
                    displayLcoo: enableTaxCalc && d.afterTaxLcoo != null ? d.afterTaxLcoo : d.lcoo
                  }))} margin={{ left: 5, right: 10, top: 5, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="capacityLabel" tick={{ fontSize: 8 }} interval={0} angle={-45} textAnchor="end" height={40} />
                    <YAxis tick={{ fontSize: 9 }} tickFormatter={v => `$${v.toFixed(0)}`} domain={['auto', 'auto']} />
                    <Tooltip 
                      formatter={(v) => [`$${v.toFixed(2)}/bbl`, enableTaxCalc ? 'LCOO (After-Tax)' : 'LCOO']} 
                      labelFormatter={(l, payload) => {
                        if (payload && payload[0]) {
                          const acres = payload[0].payload.optimalFieldSize;
                          return `${l} t/yr (Field: ${acres >= 1000 ? `${(acres/1000).toFixed(1)}k` : acres} ac)`;
                        }
                        return `${l} t/yr`;
                      }}
                    />
                    <ReferenceLine 
                      y={enableTaxCalc && calcs.afterTaxLcoo != null ? calcs.afterTaxLcoo : calcs.lcoo} 
                      stroke="#0891b2" 
                      strokeDasharray="5 5" 
                      strokeWidth={2} 
                      label={{ value: `Current: $${(enableTaxCalc && calcs.afterTaxLcoo != null ? calcs.afterTaxLcoo : calcs.lcoo).toFixed(0)}`, position: 'right', fontSize: 9, fill: '#0891b2' }} 
                    />
                    <Line type="monotone" dataKey="displayLcoo" stroke="#0891b2" strokeWidth={2} dot={{ r: 3, fill: '#0891b2' }} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* LCOO vs Recycle Rate */}
            <div className="bg-white border border-gray-200 rounded flex flex-col sm:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">LCOO{enableTaxCalc ? ' (After-Tax)' : ''} vs Recycle Rate</h3></div>
              <div className="p-2 flex-1 min-h-[220px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={recycleRateSensitivity.map(d => ({
                    ...d,
                    displayLcoo: enableTaxCalc && d.afterTaxLcoo != null ? d.afterTaxLcoo : d.lcoo
                  }))} margin={{ left: 5, right: 10, top: 5, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="rateLabel" tick={{ fontSize: 9 }} />
                    <YAxis tick={{ fontSize: 9 }} tickFormatter={v => `$${v.toFixed(0)}`} domain={['auto', 'auto']} />
                    <Tooltip 
                      formatter={(v) => [`$${v.toFixed(2)}/bbl`, enableTaxCalc ? 'LCOO (After-Tax)' : 'LCOO']} 
                      labelFormatter={(l, payload) => {
                        if (payload && payload[0]) {
                          const storageRate = payload[0].payload.storageRate;
                          return `Recycle: ${l} (Storage: ${storageRate}%)`;
                        }
                        return `Recycle: ${l}`;
                      }}
                    />
                    {recycleMode === 'fixed' && (
                      <ReferenceLine 
                        x={`${fixedRecycleRate}%`}
                        stroke="#0891b2" 
                        strokeDasharray="5 5" 
                        strokeWidth={2}
                      />
                    )}
                    <Line type="monotone" dataKey="displayLcoo" stroke="#0891b2" strokeWidth={2} dot={{ r: 3, fill: '#0891b2' }} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* NPV & IRR vs Recycle Rate */}
            <div className="bg-white border border-gray-200 rounded flex flex-col sm:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b flex-shrink-0"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV & IRR vs Recycle Rate</h3></div>
              <div className="p-2 flex-1 min-h-[220px]">
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={recycleRateSensitivity.map(d => ({
                    ...d,
                    displayIrr: d.irr === Infinity || d.irr === -Infinity ? null : d.irr
                  }))} margin={{ left: 5, right: 5, top: 5, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                    <XAxis dataKey="rateLabel" tick={{ fontSize: 9 }} />
                    <YAxis 
                      yAxisId="left" 
                      tick={{ fontSize: 9 }} 
                      tickFormatter={v => `$${v.toFixed(0)}M`}
                    />
                    <YAxis 
                      yAxisId="right" 
                      orientation="right" 
                      tick={{ fontSize: 9 }} 
                      tickFormatter={v => `${v.toFixed(0)}%`}
                    />
                    <Tooltip 
                      formatter={(v, name) => {
                        if (name === 'npv') return [`$${v.toFixed(1)}MM`, 'NPV'];
                        if (name === 'displayIrr') {
                          if (v === null) return ['∞', 'IRR'];
                          return [`${v.toFixed(1)}%`, 'IRR'];
                        }
                        return [v, name];
                      }} 
                      labelFormatter={(l, payload) => {
                        if (payload && payload[0]) {
                          const storageRate = payload[0].payload.storageRate;
                          return `Recycle: ${l} (Storage: ${storageRate}%)`;
                        }
                        return `Recycle: ${l}`;
                      }}
                    />
                    <Legend 
                      verticalAlign="top" 
                      height={25}
                      formatter={(value) => {
                        if (value === 'npv') return <span style={{color: '#7c3aed', fontSize: 9}}>NPV ($MM)</span>;
                        if (value === 'displayIrr') return <span style={{color: '#059669', fontSize: 9}}>IRR (%)</span>;
                        return value;
                      }}
                    />
                    <ReferenceLine yAxisId="left" y={0} stroke="#666" strokeDasharray="3 3" />
                    <Line yAxisId="left" type="monotone" dataKey="npv" stroke="#7c3aed" strokeWidth={2} dot={{ r: 3, fill: '#7c3aed' }} name="npv" />
                    <Line yAxisId="right" type="monotone" dataKey="displayIrr" stroke="#059669" strokeWidth={2} dot={{ r: 3, fill: '#059669' }} name="displayIrr" connectNulls={false} />
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>

            {/* Tornado Chart - Custom SVG with Y-axis in center */}
            <div className="bg-white border border-gray-200 rounded sm:col-span-2 lg:col-span-2 xl:col-span-2">
              <div className="bg-gray-100 px-2 py-1 border-b"><h3 className="text-gray-700 font-semibold text-xs uppercase">Sensitivity Tornado (±25%) — Base NPV: ${calcs.projectNpv.toFixed(0)}MM</h3></div>
              <div className="p-2 overflow-x-auto relative">
                {(() => {
                  const barHeight = 28;
                  const chartHeight = tornadoData.length * barHeight + 60;
                  const labelWidth = 95;
                  const barAreaWidth = 200;
                  const chartWidth = labelWidth + barAreaWidth * 2 + 40;
                  const centerX = labelWidth + barAreaWidth + 10;
                  const baseNpv = calcs.projectNpv;
                  
                  // Find max deviation from base for scaling
                  const maxDev = Math.max(
                    ...tornadoData.map(d => Math.max(Math.abs(d.low - baseNpv), Math.abs(d.high - baseNpv))),
                    1 // Prevent division by zero
                  );
                  
                  return (
                    <>
                      <svg width={chartWidth} height={chartHeight} className="mx-auto" onMouseLeave={() => setTornadoHover(null)}>
                        {/* X-axis labels at top - showing absolute NPV values */}
                        {[-1, -0.5, 0, 0.5, 1].map(pct => {
                          const x = centerX + (pct * barAreaWidth);
                          const val = baseNpv + (pct * maxDev);
                          return (
                            <text key={pct} x={x} y={18} textAnchor="middle" fontSize="9" fill="#6b7280">
                              {pct === 0 ? `$${baseNpv.toFixed(0)}M` : `$${val.toFixed(0)}M`}
                            </text>
                          );
                        })}
                        
                        {/* Grid lines */}
                        {[-1, -0.5, 0.5, 1].map(pct => {
                          const x = centerX + (pct * barAreaWidth);
                          return (
                            <line key={pct} x1={x} y1={25} x2={x} y2={chartHeight - 30} stroke="#e5e7eb" strokeWidth={1} strokeDasharray="3,3" />
                          );
                        })}
                        
                        {/* Center axis (base NPV) */}
                        <line x1={centerX} y1={25} x2={centerX} y2={chartHeight - 30} stroke="#374151" strokeWidth={2} />
                        
                        {/* Bars and labels */}
                        {tornadoData.map((item, idx) => {
                          const y = 32 + idx * barHeight;
                          // Calculate position relative to base NPV
                          const lowDev = item.low - baseNpv;
                          const highDev = item.high - baseNpv;
                          const lowX = centerX + (lowDev / maxDev) * barAreaWidth;
                          const highX = centerX + (highDev / maxDev) * barAreaWidth;
                          
                          // Bar goes from low to high
                          const barStartX = Math.min(lowX, highX);
                          const barEndX = Math.max(lowX, highX);
                          
                          // Red portion (below base) and green portion (above base)
                          const redStart = barStartX;
                          const redEnd = Math.min(barEndX, centerX);
                          const greenStart = Math.max(barStartX, centerX);
                          const greenEnd = barEndX;
                          
                          return (
                            <g key={item.name}>
                              {/* Variable label on left */}
                              <text 
                                x={labelWidth - 5}
                                y={y + barHeight/2 - 2} 
                                textAnchor="end"
                                fontSize="10" 
                                fill="#374151"
                                fontWeight="500"
                              >
                                {item.name}
                              </text>
                              
                              {/* Red bar (below base NPV) */}
                              {redEnd > redStart && (
                                <rect 
                                  x={redStart}
                                  y={y}
                                  width={redEnd - redStart}
                                  height={barHeight - 8}
                                  fill={tornadoHover?.name === item.name && tornadoHover?.type === 'low' ? '#b91c1c' : '#dc2626'}
                                  rx={2}
                                  style={{ cursor: 'pointer' }}
                                  onMouseEnter={() => setTornadoHover({ name: item.name, type: 'low', value: item.low })}
                                />
                              )}
                              
                              {/* Green bar (above base NPV) */}
                              {greenEnd > greenStart && (
                                <rect 
                                  x={greenStart}
                                  y={y}
                                  width={greenEnd - greenStart}
                                  height={barHeight - 8}
                                  fill={tornadoHover?.name === item.name && tornadoHover?.type === 'high' ? '#15803d' : '#16a34a'}
                                  rx={2}
                                  style={{ cursor: 'pointer' }}
                                  onMouseEnter={() => setTornadoHover({ name: item.name, type: 'high', value: item.high })}
                                />
                              )}
                            </g>
                          );
                        })}
                      
                      {/* Legend */}
                      <g transform={`translate(${centerX - 90}, ${chartHeight - 20})`}>
                        <rect x={0} y={0} width={12} height={12} fill="#dc2626" rx={2} />
                        <text x={16} y={10} fontSize="9" fill="#6b7280">Below Base</text>
                        <rect x={90} y={0} width={12} height={12} fill="#16a34a" rx={2} />
                        <text x={106} y={10} fontSize="9" fill="#6b7280">Above Base</text>
                      </g>
                    </svg>
                    
                    {/* Tooltip */}
                    {tornadoHover && (
                      <div className="absolute top-2 right-2 bg-white border border-gray-300 rounded shadow-lg px-3 py-2 text-xs z-10">
                        <div className="font-semibold text-gray-700">{tornadoHover.name}</div>
                        <div className={tornadoHover.type === 'high' ? 'text-green-600 font-mono' : 'text-red-600 font-mono'}>
                          NPV: ${tornadoHover.value.toFixed(1)}MM
                        </div>
                        <div className="text-gray-400 text-[10px]">
                          {tornadoHover.type === 'high' ? `+$${(tornadoHover.value - calcs.projectNpv).toFixed(1)}MM vs base` : `$${(tornadoHover.value - calcs.projectNpv).toFixed(1)}MM vs base`}
                        </div>
                      </div>
                    )}
                    </>
                  );
                })()}
              </div>
            </div>

            {/* NPV Sensitivity Table */}
            <div className="bg-white border border-gray-200 rounded sm:col-span-2 lg:col-span-3 xl:col-span-4">
              <div className="bg-gray-100 px-2 py-1 border-b"><h3 className="text-gray-700 font-semibold text-xs uppercase">NPV Matrix ($MM) — Oil Price vs CO₂ Price (Base: ${calcs.projectNpv.toFixed(0)}MM)</h3></div>
              <div className="p-2 overflow-x-auto">
                <table className="w-full border-collapse text-xs">
                  <thead>
                    <tr className="bg-gray-50">
                      <th className="border border-gray-300 px-2 py-1 text-gray-500">WTI ↓ / CO₂ →</th>
                      {[-30, 0, 30, 60, 85].map(cp => (
                        <th key={cp} className={`border border-gray-300 px-2 py-1 ${cp === co2Price ? 'bg-green-50 text-green-700' : 'text-gray-500'}`}>{cp < 0 ? `Buy $${-cp}` : cp === 0 ? 'Free' : `+$${cp}`}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {[40, 50, 60, 65, 70, 80, 90, 100].map(op => (
                      <tr key={op}>
                        <td className={`border border-gray-300 px-2 py-1 font-semibold ${op === wtiPrice ? 'bg-green-50 text-green-700' : 'text-gray-500'}`}>${op}</td>
                        {[-30, 0, 30, 60, 85].map(cp => {
                          // Use pattern mode for accurate results
                          const result = calculatePatternMetrics({ wtiPrice: op, co2Price: cp });
                          const npv = result.projectNpv;
                          const isCurrentCell = op === wtiPrice && cp === co2Price;
                          return (
                            <td key={cp} className={`border border-gray-300 px-2 py-1 text-right font-mono ${npv >= 0 ? 'text-green-600' : 'text-red-600'} ${isCurrentCell ? 'bg-green-100 font-bold' : ''}`}>
                              {npv.toFixed(0)}
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'montecarlo' && (
          <div>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3 mb-4">
              <Section title="Monte Carlo Parameters" >
                <div className="flex items-center gap-2 mb-2">
                  <InputField label="Iterations" value={mcIterations} onChange={setMcIterations} step={500} />
                </div>
                <div className="flex items-center gap-2 mb-2">
                  <label className="text-gray-400 text-xs">Output Metric</label>
                  <select value={mcOutputMetric} onChange={e => setMcOutputMetric(e.target.value)}
                    className="text-xs bg-white border border-gray-300 rounded px-2 py-0.5 text-gray-800">
                    <option value="npv">Project NPV</option>
                    <option value="incremental" style={{display:'none'}}>Incremental NPV</option>
                    <option value="breakeven">Breakeven Oil</option>
                  </select>
                </div>
                <button onClick={runMonteCarlo} disabled={mcRunning}
                  className={`w-full py-1.5 rounded text-xs font-semibold transition-colors ${mcRunning ? 'bg-gray-300 text-gray-500' : 'bg-green-700 hover:bg-green-600 text-white'}`}>
                  {mcRunning ? 'Running...' : 'Run Monte Carlo'}
                </button>
              </Section>

              <div className="sm:col-span-1 lg:col-span-2 xl:col-span-3">
                <Section title="Variable Parameters" >
                  <div id="mc-params-scroll" className="max-h-48 overflow-y-auto space-y-1">
                    {Object.entries(mcParams).map(([key, config]) => (
                      <div key={key} className="flex items-center gap-2 py-0.5">
                        <button onClick={() => {
                          mcScrollRef.current = document.getElementById('mc-params-scroll')?.scrollTop || 0;
                          setMcParams(prev => ({ ...prev, [key]: { ...prev[key], enabled: !prev[key].enabled } }));
                        }}
                          className={`w-3 h-3 rounded border flex-shrink-0 ${config.enabled ? 'bg-green-600 border-green-500' : 'bg-gray-200 border-gray-300'}`} />
                        <span className={`text-xs flex-1 ${config.enabled ? 'text-gray-700' : 'text-gray-400'}`}>{mcParamLabels[key]}</span>
                        <select value={config.dist} onChange={e => {
                          mcScrollRef.current = document.getElementById('mc-params-scroll')?.scrollTop || 0;
                          setMcParams(prev => ({ ...prev, [key]: { ...prev[key], dist: e.target.value } }));
                        }} className="text-xs bg-white border border-gray-300 rounded px-1 py-0 text-gray-700 w-20" disabled={!config.enabled}>
                          <option value="triangular">Tri</option>
                          <option value="uniform">Uniform</option>
                          <option value="normal">Normal</option>
                        </select>
                        <div className="flex items-center gap-0.5">
                          <input type="number" value={config.spread} onChange={e => {
                            mcScrollRef.current = document.getElementById('mc-params-scroll')?.scrollTop || 0;
                            setMcParams(prev => ({ ...prev, [key]: { ...prev[key], spread: Number(e.target.value) } }));
                          }} className="text-xs bg-white border border-gray-300 rounded px-1 py-0 w-10 text-right text-gray-800 font-mono" disabled={!config.enabled} />
                          <span className="text-gray-500 text-xs">%</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </Section>
              </div>
            </div>

            {mcResults && (
              <div className="space-y-4">
                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-2">
                  {[['Mean', mcResults.stats.mean], ['P10', mcResults.stats.p10], ['P50', mcResults.stats.p50],
                  ['P90', mcResults.stats.p90], ['Min', mcResults.stats.min], ['Max', mcResults.stats.max],
                  ['Std Dev', mcResults.stats.stdDev]].map(([label, val]) => (
                    <div key={label} className="bg-white border border-gray-200 rounded p-2 text-center">
                      <div className="text-xs text-gray-500">{label}</div>
                      <div className="text-sm font-mono text-gray-800">{mcOutputMetric === 'breakeven' ? `$${val.toFixed(1)}` : `$${val.toFixed(0)}MM`}</div>
                    </div>
                  ))}
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Distribution — {mcMetricLabel}</h3>
                    <ResponsiveContainer width="100%" height={280}>
                      <BarChart data={mcResults.histogram}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="bin" tick={{ fill: "#6b7280", fontSize: 9 }}
                          tickFormatter={v => mcOutputMetric === 'breakeven' ? `$${v.toFixed(0)}` : `${v.toFixed(0)}`} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${v.toFixed(1)}%`} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v) => [`${v.toFixed(1)}%`, 'Frequency']} />
                        <Bar dataKey="frequency" fill="#8b5cf6" />
                        <ReferenceLine x={mcResults.stats.p50} stroke="#15803d" strokeDasharray="3 3" label={{ value: 'P50', fill: '#15803d', fontSize: 9, position: 'top' }} />
                      </BarChart>
                    </ResponsiveContainer>
                  </div>

                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CDF — {mcMetricLabel}</h3>
                    <ResponsiveContainer width="100%" height={280}>
                      <LineChart data={mcResults.cdf}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="value" tick={{ fill: "#6b7280", fontSize: 9 }}
                          tickFormatter={v => mcOutputMetric === 'breakeven' ? `$${v.toFixed(0)}` : `${v.toFixed(0)}`} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${v.toFixed(0)}%`} domain={[0, 100]} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v, name) => [`${v.toFixed(1)}%`, 'Probability']} />
                        <ReferenceLine y={50} stroke="#15803d33" strokeDasharray="3 3" />
                        <Line type="monotone" dataKey="probability" stroke="#8b5cf6" strokeWidth={2} dot={false} />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {activeTab === 'development' && (
          <div className="space-y-4">
            {modelMode === 'simple' ? (
              <div className="bg-yellow-50 border border-yellow-200 rounded p-4 text-center">
                <p className="text-yellow-800 text-sm">Development Timeline is only available in Pattern-Based mode.</p>
                <p className="text-yellow-600 text-xs mt-1">Switch to Pattern-Based mode in the header to see detailed field development visualization.</p>
              </div>
            ) : !calcs.monthlyData ? (
              <div className="bg-gray-50 border border-gray-200 rounded p-4 text-center">
                <p className="text-gray-600 text-sm">Loading development data...</p>
              </div>
            ) : (
              <>
                {/* Animation Controls */}
                <div className="bg-white border border-gray-200 rounded p-3">
                  <div className="flex items-center justify-between flex-wrap gap-2">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase">Field Development Animation</h3>
                    <div className="flex items-center gap-2">
                      <button 
                        onClick={() => { setAnimationMonth(0); setIsAnimating(false); }}
                        className="px-2 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded">⏮ Reset</button>
                      <button 
                        onClick={() => setIsAnimating(!isAnimating)}
                        className={`px-3 py-1 text-xs rounded ${isAnimating ? 'bg-red-500 text-white' : 'bg-green-600 text-white'}`}>
                        {isAnimating ? '⏸ Pause' : '▶ Play'}
                      </button>
                      <span className="text-xs text-gray-500">
                        Month {animationMonth} / {calcs.monthlyData?.length > 0 ? calcs.monthlyData[calcs.monthlyData.length - 1]?.month : 0}
                        {' '}(Year {(animationMonth / 12).toFixed(1)})
                      </span>
                    </div>
                  </div>
                  
                  {/* Field Visualization */}
                  <div className="mt-3">
                    {/* Expanded Animated Field Map */}
                    <div className="w-full overflow-auto">
                      {(() => {
                        // Calculate field dimensions based on acreage
                        // 640 acres = 1 sq mile = 1 section
                        const sqMiles = fieldSize / 640;
                        const fieldWidthMiles = Math.sqrt(sqMiles * (fieldShapeFactor || 0.8));
                        
                        // Scale patterns to fit - limit display for very large fields
                        const totalPatterns = patternDerived.maxPatterns || 0;
                        const maxPat = Math.min(totalPatterns, 1000); // Allow up to 1000 patterns
                        
                        // Dynamic grid sizing based on pattern count
                        // For large fields, use more columns and smaller spacing
                        let cols, rows, spacing;
                        if (maxPat <= 16) {
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat * 1.2)), 6);
                          spacing = patternType === 'single-well' ? 50 : 60;
                        } else if (maxPat <= 36) {
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat * 1.1)), 8);
                          spacing = patternType === 'single-well' ? 40 : 48;
                        } else if (maxPat <= 64) {
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat)), 10);
                          spacing = patternType === 'single-well' ? 32 : 38;
                        } else if (maxPat <= 144) {
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat)), 14);
                          spacing = patternType === 'single-well' ? 22 : 26;
                        } else if (maxPat <= 400) {
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat)), 22);
                          spacing = patternType === 'single-well' ? 14 : 16;
                        } else {
                          // Massive fields (400-1000 patterns) - ultra compact
                          cols = Math.min(Math.ceil(Math.sqrt(maxPat)), 35);
                          spacing = patternType === 'single-well' ? 10 : 12;
                        }
                        rows = Math.ceil(maxPat / cols);
                        
                        // Calculate SVG dimensions - scale viewBox to fit content
                        const contentWidth = cols * spacing + 100;
                        const contentHeight = rows * spacing + 80;
                        
                        // Fixed display size, let viewBox handle scaling
                        const svgWidth = contentWidth;
                        const svgHeight = contentHeight;
                        
                        const baseX = 70;
                        const baseY = 40;
                        
                        // Show indicator if we're truncating
                        const isTruncated = totalPatterns > maxPat;
                        
                        return (
                          <svg viewBox={`0 0 ${svgWidth} ${svgHeight}`} className="w-full border border-gray-300 rounded bg-gradient-to-br from-amber-50 to-amber-100" style={{maxHeight: '450px'}} preserveAspectRatio="xMidYMid meet">
                            {/* Field boundary */}
                            <rect x={baseX - spacing/2 - 10} y={baseY - spacing/2 - 10} 
                              width={cols * spacing + 20} height={rows * spacing + 20}
                              fill="none" stroke="#92400e" strokeWidth="2" strokeDasharray="8,4" rx="4" />
                            <text x={baseX + cols * spacing / 2} y={baseY - spacing/2 - 18} 
                              textAnchor="middle" fontSize={maxPat > 36 ? "8" : "10"} fill="#92400e" fontWeight="bold">
                              {fieldSize} acres ({sqMiles.toFixed(1)} sq mi) - {totalPatterns} patterns{isTruncated ? ` (showing ${maxPat})` : ''}
                            </text>
                            
                            {/* Main trunk pipeline */}
                            <line x1={10} y1={svgHeight/2} x2={baseX - spacing/2 - 10} y2={svgHeight/2} stroke="#1e40af" strokeWidth={maxPat > 36 ? "4" : "6"} />
                            <line x1={baseX - spacing/2 - 10} y1={baseY} x2={baseX - spacing/2 - 10} y2={baseY + rows * spacing} stroke="#1e40af" strokeWidth={maxPat > 36 ? "3" : "4"} />
                            <text x={5} y={svgHeight/2 - 6} fontSize={maxPat > 36 ? "6" : "8"} fill="#1e40af" fontWeight="bold">Trunk</text>
                            
                            {/* Patterns */}
                            {(() => {
                              const patternStartMonths = calcs.patternsStartedThisProject || [];
                              const existingPatternsCount = scenarioType === 'Existing' ? patternDerived.existingPatterns : 0;
                              
                              // Calculate pattern states
                              const patternStates = [...Array(maxPat)].map((_, idx) => {
                                let isExisting = idx < existingPatternsCount;
                                let isDeveloped = false;
                                let patternAge = 0;
                                
                                if (isExisting) {
                                  isDeveloped = true;
                                  patternAge = (avgPatternAge * 12) + animationMonth;
                                } else {
                                  const patternIdx = idx - existingPatternsCount;
                                  if (patternIdx >= 0 && patternIdx < patternStartMonths.length) {
                                    const startMonth = patternStartMonths[patternIdx];
                                    if (animationMonth >= startMonth) {
                                      isDeveloped = true;
                                      patternAge = animationMonth - startMonth;
                                    }
                                  }
                                }
                                
                                // Calculate lifecycle state - different for H&P vs continuous/WAG
                                const ageYears = patternAge / 12;
                                let inBlowdown = false;
                                let isAbandoned = false;
                                
                                if (eorMethod === 'huffpuff') {
                                  // H&P lifecycle: cycles then blowdown then abandoned
                                  const cycleDays = hpInjectionDays + hpSoakDays + hpProductionDays;
                                  const cycleMonths = cycleDays / 30;
                                  const totalHPDuration = cycleMonths * hpCycles;
                                  const postHPAge = patternAge - totalHPDuration;
                                  
                                  if (isDeveloped && postHPAge > 0) {
                                    inBlowdown = true;
                                    if (postHPAge > 24) { // 2 years of blowdown max
                                      isAbandoned = true;
                                    }
                                  }
                                } else {
                                  // Continuous/WAG lifecycle
                                  const declineStart = patternFillYears + patternRampYears + patternPeakYears;
                                  const declineYears = Math.max(0, ageYears - declineStart);
                                  const declineFactor = Math.pow(1 - patternDeclineRate / 100, declineYears);
                                  inBlowdown = isDeveloped && ageYears >= declineStart && declineFactor < patternAbandonmentPct / 100;
                                  isAbandoned = isDeveloped && declineFactor < 0.02;
                                }
                                
                                return { isDeveloped, isExisting, inBlowdown, isAbandoned, patternAge };
                              });
                              
                              const elements = [];
                              // Scale well sizes based on pattern count
                              const wellRadius = maxPat > 400 ? 1.5 : (maxPat > 144 ? 2 : (maxPat > 64 ? 3 : (maxPat > 36 ? 4 : (maxPat > 16 ? 5 : 6))));
                              const injRadius = wellRadius + (maxPat > 144 ? 0.5 : (maxPat > 36 ? 1 : 2));
                              const strokeWidth = maxPat > 144 ? 0.3 : (maxPat > 36 ? 0.5 : 1);
                              const feederWidth = maxPat > 144 ? 0.5 : (maxPat > 36 ? 1 : 1.5);
                              
                              if (patternType === '5-spot' || patternType === 'inv-5-spot') {
                                // Draw pattern boundaries and feeder lines
                                for (let idx = 0; idx < maxPat; idx++) {
                                  const row = Math.floor(idx / cols);
                                  const col = idx % cols;
                                  const cx = baseX + col * spacing;
                                  const cy = baseY + row * spacing;
                                  const state = patternStates[idx];
                                  
                                  elements.push(
                                    <g key={`pattern-bg-${idx}`} opacity={state.isDeveloped ? 1 : 0.25}>
                                      {state.isDeveloped && (
                                        <line x1={baseX - spacing/2 - 10} y1={cy} x2={cx - spacing/2 + 3} y2={cy} 
                                          stroke="#3b82f6" strokeWidth={feederWidth} 
                                          strokeDasharray={state.isExisting ? "none" : "3,2"} />
                                      )}
                                      <rect x={cx - spacing/2} y={cy - spacing/2} width={spacing} height={spacing}
                                        fill={state.isAbandoned ? '#f3f4f6' : (state.inBlowdown ? '#fef3c7' : 'none')}
                                        stroke={state.isDeveloped ? (state.isAbandoned ? '#9ca3af' : '#92400e') : '#d4a574'}
                                        strokeWidth={strokeWidth} strokeDasharray="2,2" rx="1" />
                                      {maxPat <= 64 && (
                                        <text x={cx} y={cy + spacing/2 + (maxPat > 36 ? 5 : (maxPat > 16 ? 6 : 8))} textAnchor="middle" fontSize={maxPat > 36 ? "4" : (maxPat > 16 ? "5" : "6")} 
                                          fill={state.isAbandoned ? '#9ca3af' : '#6b7280'}>#{idx + 1}</text>
                                      )}
                                    </g>
                                  );
                                }
                                
                                // Injectors at pattern centers (5-spot)
                                if (patternType === '5-spot') {
                                  for (let idx = 0; idx < maxPat; idx++) {
                                    const row = Math.floor(idx / cols);
                                    const col = idx % cols;
                                    const cx = baseX + col * spacing;
                                    const cy = baseY + row * spacing;
                                    const state = patternStates[idx];
                                    
                                    // For WAG: determine if in CO2 or water phase
                                    let injColor, injLabel, strokeColor;
                                    if (!state.isDeveloped) {
                                      injColor = '#fca5a5'; // light red - undeveloped
                                      strokeColor = '#7f1d1d';
                                      injLabel = 'I';
                                    } else if (state.isAbandoned) {
                                      injColor = '#4b5563'; // gray - abandoned
                                      strokeColor = '#1f2937';
                                      injLabel = 'X';
                                    } else if (state.inBlowdown) {
                                      injColor = '#f59e0b'; // amber - blowdown
                                      strokeColor = '#92400e';
                                      injLabel = 'B';
                                    } else if (eorMethod === 'wag') {
                                      // WAG with staggered groups: patterns are assigned to groups
                                      // that take turns with CO2 injection
                                      const numStaggerGroups = Math.round(1 + wagRatio); // 1:1=2, 2:1=3, etc.
                                      const staggerGroup = idx % numStaggerGroups;
                                      const fullCycleMonths = wagCycleMonths * (1 + wagRatio);
                                      
                                      // Each group is offset by (group# * co2PhaseDuration)
                                      const groupOffset = staggerGroup * wagCycleMonths;
                                      const adjustedAge = state.patternAge + groupOffset;
                                      const monthInCycle = adjustedAge % fullCycleMonths;
                                      const isWaterPhase = monthInCycle >= wagCycleMonths;
                                      
                                      if (isWaterPhase) {
                                        injColor = '#3b82f6'; // blue - water phase
                                        strokeColor = '#1e40af';
                                        injLabel = 'W';
                                      } else {
                                        injColor = '#dc2626'; // red - CO2 phase
                                        strokeColor = '#7f1d1d';
                                        injLabel = 'C';
                                      }
                                    } else {
                                      injColor = '#dc2626'; // red - normal CO2 injection
                                      strokeColor = '#7f1d1d';
                                      injLabel = 'I';
                                    }
                                    
                                    elements.push(
                                      <g key={`inj-${idx}`}>
                                        <circle cx={cx} cy={cy} r={injRadius} fill={injColor} stroke={strokeColor} strokeWidth="1">
                                          {state.isDeveloped && !state.inBlowdown && !state.isAbandoned && (
                                            <animate attributeName="r" values={`${injRadius};${injRadius+1.5};${injRadius}`} dur="1s" repeatCount="indefinite" />
                                          )}
                                        </circle>
                                        {maxPat <= 15 && (
                                          <text x={cx} y={cy + 2} textAnchor="middle" fontSize="5" fill="white" fontWeight="bold">
                                            {injLabel}
                                          </text>
                                        )}
                                      </g>
                                    );
                                  }
                                  
                                  // Producers at corners (shared)
                                  for (let prow = 0; prow <= rows; prow++) {
                                    for (let pcol = 0; pcol <= cols; pcol++) {
                                      const adjacentPatterns = [
                                        prow > 0 && pcol > 0 ? (prow - 1) * cols + (pcol - 1) : -1,
                                        prow > 0 && pcol < cols ? (prow - 1) * cols + pcol : -1,
                                        prow < rows && pcol > 0 ? prow * cols + (pcol - 1) : -1,
                                        prow < rows && pcol < cols ? prow * cols + pcol : -1
                                      ].filter(i => i >= 0 && i < maxPat);
                                      
                                      if (adjacentPatterns.length === 0) continue;
                                      
                                      const px = baseX - spacing/2 + pcol * spacing;
                                      const py = baseY - spacing/2 + prow * spacing;
                                      
                                      const anyDeveloped = adjacentPatterns.some(i => patternStates[i].isDeveloped);
                                      const allAbandoned = adjacentPatterns.every(i => !patternStates[i].isDeveloped || patternStates[i].isAbandoned);
                                      const anyBlowdown = adjacentPatterns.some(i => patternStates[i].inBlowdown && !patternStates[i].isAbandoned);
                                      
                                      const prodColor = !anyDeveloped ? '#86efac' :
                                        allAbandoned ? '#4b5563' :
                                        anyBlowdown ? '#84cc16' : '#16a34a';
                                      
                                      elements.push(
                                        <g key={`prod-${prow}-${pcol}`}>
                                          <circle cx={px} cy={py} r={wellRadius} fill={prodColor} stroke="#166534" strokeWidth="0.5">
                                            {anyDeveloped && !allAbandoned && (
                                              <animate attributeName="opacity" values="1;0.6;1" dur="1.5s" repeatCount="indefinite" />
                                            )}
                                          </circle>
                                        </g>
                                      );
                                    }
                                  }
                                } else {
                                  // Inverted 5-spot: producer at center
                                  for (let idx = 0; idx < maxPat; idx++) {
                                    const row = Math.floor(idx / cols);
                                    const col = idx % cols;
                                    const cx = baseX + col * spacing;
                                    const cy = baseY + row * spacing;
                                    const state = patternStates[idx];
                                    
                                    const prodColor = !state.isDeveloped ? '#86efac' :
                                      state.isAbandoned ? '#4b5563' :
                                      state.inBlowdown ? '#84cc16' : '#16a34a';
                                    
                                    elements.push(
                                      <g key={`prod-${idx}`}>
                                        <circle cx={cx} cy={cy} r={wellRadius} fill={prodColor} stroke="#166534" strokeWidth="0.5">
                                          {state.isDeveloped && !state.isAbandoned && (
                                            <animate attributeName="opacity" values="1;0.6;1" dur="1.5s" repeatCount="indefinite" />
                                          )}
                                        </circle>
                                      </g>
                                    );
                                  }
                                  
                                  // Injectors at corners for inverted 5-spot
                                  for (let irow = 0; irow <= rows; irow++) {
                                    for (let icol = 0; icol <= cols; icol++) {
                                      const adjacentPatterns = [
                                        irow > 0 && icol > 0 ? (irow - 1) * cols + (icol - 1) : -1,
                                        irow > 0 && icol < cols ? (irow - 1) * cols + icol : -1,
                                        irow < rows && icol > 0 ? irow * cols + (icol - 1) : -1,
                                        irow < rows && icol < cols ? irow * cols + icol : -1
                                      ].filter(i => i >= 0 && i < maxPat);
                                      
                                      if (adjacentPatterns.length === 0) continue;
                                      
                                      const ix = baseX - spacing/2 + icol * spacing;
                                      const iy = baseY - spacing/2 + irow * spacing;
                                      
                                      const anyDeveloped = adjacentPatterns.some(i => patternStates[i].isDeveloped);
                                      const anyInjecting = adjacentPatterns.some(i => patternStates[i].isDeveloped && !patternStates[i].inBlowdown && !patternStates[i].isAbandoned);
                                      const allAbandoned = adjacentPatterns.every(i => !patternStates[i].isDeveloped || patternStates[i].isAbandoned);
                                      const anyBlowdown = adjacentPatterns.some(i => patternStates[i].inBlowdown);
                                      
                                      const injColor = !anyDeveloped ? '#fca5a5' :
                                        allAbandoned ? '#4b5563' :
                                        anyBlowdown ? '#f59e0b' : '#dc2626';
                                      
                                      elements.push(
                                        <g key={`inj-${irow}-${icol}`}>
                                          <circle cx={ix} cy={iy} r={injRadius} fill={injColor} stroke="#7f1d1d" strokeWidth="1">
                                            {anyInjecting && (
                                              <animate attributeName="r" values={`${injRadius};${injRadius+1.5};${injRadius}`} dur="1s" repeatCount="indefinite" />
                                            )}
                                          </circle>
                                        </g>
                                      );
                                    }
                                  }
                                }
                              } else {
                                // Single-well (H&P)
                                for (let idx = 0; idx < maxPat; idx++) {
                                  const row = Math.floor(idx / cols);
                                  const col = idx % cols;
                                  const cx = baseX + col * spacing;
                                  const cy = baseY + row * spacing;
                                  const state = patternStates[idx];
                                  
                                  const cycleDays = hpInjectionDays + hpSoakDays + hpProductionDays;
                                  const cycleMonths = cycleDays / 30;
                                  const monthInCycle = state.patternAge % cycleMonths;
                                  const injPhase = hpInjectionDays / 30;
                                  const soakPhase = (hpInjectionDays + hpSoakDays) / 30;
                                  
                                  let phase = 'inactive';
                                  if (state.isDeveloped && !state.isAbandoned) {
                                    if (monthInCycle < injPhase) phase = 'huff';
                                    else if (monthInCycle < soakPhase) phase = 'soak';
                                    else phase = 'puff';
                                  }
                                  if (state.isAbandoned) phase = 'abandoned';
                                  
                                  const wellColor = phase === 'huff' ? '#dc2626' :
                                    phase === 'soak' ? '#f59e0b' :
                                    phase === 'puff' ? '#16a34a' :
                                    phase === 'abandoned' ? '#4b5563' : '#fca5a5';
                                  
                                  elements.push(
                                    <g key={`hp-${idx}`} opacity={state.isDeveloped ? 1 : 0.25}>
                                      {state.isDeveloped && (
                                        <line x1={baseX - spacing/2 - 10} y1={cy} x2={cx} y2={cy} stroke="#3b82f6" strokeWidth="1" />
                                      )}
                                      <circle cx={cx} cy={cy} r={injRadius} fill={wellColor} stroke="#374151" strokeWidth="1">
                                        {phase === 'huff' && <animate attributeName="r" values={`${injRadius};${injRadius+2};${injRadius}`} dur="0.8s" repeatCount="indefinite" />}
                                        {phase === 'puff' && <animate attributeName="opacity" values="1;0.6;1" dur="1.5s" repeatCount="indefinite" />}
                                      </circle>
                                      {maxPat <= 20 && (
                                        <text x={cx} y={cy + spacing/2 + 8} textAnchor="middle" fontSize="6" fill="#6b7280">#{idx + 1}</text>
                                      )}
                                    </g>
                                  );
                                }
                              }
                              
                              return elements;
                            })()}
                            
                            {/* Legend */}
                            <g transform={`translate(${svgWidth - 75}, 15)`}>
                              <rect x={0} y={0} width={70} height={eorMethod === 'wag' ? 115 : (eorMethod === 'huffpuff' ? 105 : 100)} fill="white" fillOpacity="0.95" stroke="#e5e7eb" rx="4" />
                              <text x={35} y={12} textAnchor="middle" fontSize="7" fill="#374151" fontWeight="bold">Legend</text>
                              
                              {eorMethod === 'wag' ? (
                                <>
                                  <circle cx={10} cy={25} r={5} fill="#dc2626" stroke="#7f1d1d" />
                                  <text x={20} y={28} fontSize="6" fill="#374151">CO₂ Phase</text>
                                  
                                  <circle cx={10} cy={38} r={5} fill="#3b82f6" stroke="#1e40af" />
                                  <text x={20} y={41} fontSize="6" fill="#374151">Water Phase</text>
                                  
                                  <circle cx={10} cy={51} r={5} fill="#f59e0b" stroke="#d97706" />
                                  <text x={20} y={54} fontSize="6" fill="#374151">Blowdown</text>
                                  
                                  <circle cx={10} cy={64} r={4} fill="#16a34a" stroke="#166534" />
                                  <text x={20} y={67} fontSize="6" fill="#374151">Producing</text>
                                  
                                  <circle cx={10} cy={77} r={4} fill="#4b5563" stroke="#374151" />
                                  <text x={20} y={80} fontSize="6" fill="#374151">Abandoned</text>
                                  
                                  <line x1={6} y1={90} x2={16} y2={90} stroke="#3b82f6" strokeWidth="1.5" />
                                  <text x={20} y={93} fontSize="6" fill="#374151">Feeder</text>
                                  
                                  <line x1={6} y1={103} x2={16} y2={103} stroke="#1e40af" strokeWidth="3" />
                                  <text x={20} y={106} fontSize="6" fill="#374151">Trunk</text>
                                </>
                              ) : eorMethod === 'huffpuff' ? (
                                <>
                                  <circle cx={10} cy={25} r={5} fill="#dc2626" stroke="#7f1d1d" />
                                  <text x={20} y={28} fontSize="6" fill="#374151">Huff (Inject)</text>
                                  
                                  <circle cx={10} cy={38} r={5} fill="#f59e0b" stroke="#d97706" />
                                  <text x={20} y={41} fontSize="6" fill="#374151">Soak</text>
                                  
                                  <circle cx={10} cy={51} r={5} fill="#16a34a" stroke="#166534" />
                                  <text x={20} y={54} fontSize="6" fill="#374151">Puff (Produce)</text>
                                  
                                  <circle cx={10} cy={64} r={4} fill="#4b5563" stroke="#374151" />
                                  <text x={20} y={67} fontSize="6" fill="#374151">Abandoned</text>
                                  
                                  <line x1={6} y1={80} x2={16} y2={80} stroke="#3b82f6" strokeWidth="1.5" />
                                  <text x={20} y={83} fontSize="6" fill="#374151">Feeder</text>
                                  
                                  <line x1={6} y1={93} x2={16} y2={93} stroke="#1e40af" strokeWidth="3" />
                                  <text x={20} y={96} fontSize="6" fill="#374151">Trunk</text>
                                </>
                              ) : (
                                <>
                                  <circle cx={10} cy={25} r={5} fill="#dc2626" stroke="#7f1d1d" />
                                  <text x={20} y={28} fontSize="6" fill="#374151">Injecting</text>
                                  
                                  <circle cx={10} cy={38} r={5} fill="#f59e0b" stroke="#d97706" />
                                  <text x={20} y={41} fontSize="6" fill="#374151">Blowdown</text>
                                  
                                  <circle cx={10} cy={51} r={4} fill="#16a34a" stroke="#166534" />
                                  <text x={20} y={54} fontSize="6" fill="#374151">Producing</text>
                                  
                                  <circle cx={10} cy={64} r={4} fill="#4b5563" stroke="#374151" />
                                  <text x={20} y={67} fontSize="6" fill="#374151">Abandoned</text>
                                  
                                  <line x1={6} y1={77} x2={16} y2={77} stroke="#3b82f6" strokeWidth="1.5" />
                                  <text x={20} y={80} fontSize="6" fill="#374151">Feeder</text>
                                  
                                  <line x1={6} y1={90} x2={16} y2={90} stroke="#1e40af" strokeWidth="3" />
                                  <text x={20} y={93} fontSize="6" fill="#374151">Trunk</text>
                                </>
                              )}
                            </g>
                            
                            {/* Stats overlay */}
                            <g transform="translate(15, 15)">
                              <rect x={0} y={0} width={65} height={45} fill="white" fillOpacity="0.9" stroke="#e5e7eb" rx="3" />
                              <text x={5} y={12} fontSize="7" fill="#374151" fontWeight="bold">Field Stats</text>
                              <text x={5} y={23} fontSize="6" fill="#6b7280">Patterns: {patternDerived.maxPatterns}</text>
                              <text x={5} y={33} fontSize="6" fill="#6b7280">Active: {calcs.monthlyData?.find(d => d.month >= animationMonth)?.activePatterns || 0}</text>
                              <text x={5} y={43} fontSize="6" fill="#6b7280">Wells: {(calcs.monthlyData?.find(d => d.month >= animationMonth)?.cumulativeInjectors || 0) + (calcs.monthlyData?.find(d => d.month >= animationMonth)?.cumulativeProducers || 0)}</text>
                            </g>
                          </svg>
                        );
                      })()}
                    </div>
                    
                    {/* Status Panel - below visualization */}
                    <div className="mt-3 grid grid-cols-2 md:grid-cols-4 gap-3">
                      <div className="bg-gray-50 rounded p-2">
                        <h4 className="text-xs font-semibold text-gray-700 mb-1">Current Status</h4>
                        <div className="text-xs space-y-0.5">
                          <div className="flex justify-between"><span>Active Patterns:</span><span className="font-medium">{
                            calcs.monthlyData?.find(d => d.month >= animationMonth)?.activePatterns || 0
                          }</span></div>
                          <div className="flex justify-between"><span>Injectors:</span><span className="font-medium">{
                            calcs.monthlyData?.find(d => d.month >= animationMonth)?.cumulativeInjectors || 0
                          }</span></div>
                          <div className="flex justify-between"><span>Producers:</span><span className="font-medium">{
                            calcs.monthlyData?.find(d => d.month >= animationMonth)?.cumulativeProducers || 0
                          }</span></div>
                        </div>
                      </div>
                      
                      <div className="bg-blue-50 rounded p-2">
                        <h4 className="text-xs font-semibold text-blue-700 mb-1">CAPEX Summary</h4>
                        <div className="text-xs space-y-0.5">
                          <div className="flex justify-between"><span>Wells:</span><span className="font-medium">${((calcs.injWellCapex || 0) + (calcs.prodWellCapexTotal || 0) + (calcs.wellRetrofitCapex || 0)).toFixed(1)}MM</span></div>
                          <div className="flex justify-between"><span>Feeder Pipe:</span><span className="font-medium">${(calcs.feederPipeCapex || 0).toFixed(2)}MM</span></div>
                          <div className="flex justify-between"><span>CCUS:</span><span className="font-medium">${(calcs.ccusCapex || 0).toFixed(1)}MM</span></div>
                        </div>
                      </div>
                      
                      <div className="bg-green-50 rounded p-2">
                        <h4 className="text-xs font-semibold text-green-700 mb-1">Production</h4>
                        <div className="text-xs space-y-0.5">
                          <div className="flex justify-between"><span>Oil Rate:</span><span className="font-medium">{
                            ((calcs.monthlyData?.find(d => d.month >= animationMonth)?.eorProd || 0) / 1000).toFixed(1)
                          }k bbl/mo</span></div>
                          <div className="flex justify-between"><span>CO₂ Inj:</span><span className="font-medium">{
                            ((calcs.monthlyData?.find(d => d.month >= animationMonth)?.co2Injection || 0) / 1000).toFixed(1)
                          }k t/mo</span></div>
                        </div>
                      </div>
                      
                      <div className="bg-purple-50 rounded p-2">
                        <h4 className="text-xs font-semibold text-purple-700 mb-1">CO₂ Storage</h4>
                        <div className="text-xs space-y-0.5">
                          <div className="flex justify-between"><span>Monthly:</span><span className="font-medium">{
                            ((calcs.monthlyData?.find(d => d.month >= animationMonth)?.co2Stored || 0) / 1000).toFixed(1)
                          }k t</span></div>
                          <div className="flex justify-between"><span>Cumulative:</span><span className="font-medium">{
                            ((calcs.monthlyData?.find(d => d.month >= animationMonth)?.co2StoredCumulative || 0) / 1e6).toFixed(3)
                          } Mt</span></div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  {/* Timeline slider */}
                  <div className="mt-3">
                    <input 
                      type="range" 
                      min={0} 
                      max={calcs.monthlyData?.length > 0 ? calcs.monthlyData[calcs.monthlyData.length - 1]?.month : 120}
                      value={animationMonth}
                      onChange={(e) => setAnimationMonth(parseInt(e.target.value))}
                      className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                  </div>
                </div>
                
                {/* Profile Charts */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {/* Oil Production Profile */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Oil Production Profile</h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <AreaChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1000).toFixed(0)}k`} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v) => [`${v.toLocaleString()} bbl/mo`, 'Production']} />
                        <Area type="monotone" dataKey="eorProd" fill="#16a34a33" stroke="#16a34a" strokeWidth={2} />
                        {calcs.monthlyData?.length > 0 && (
                          <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" label={{ value: 'Now', fill: '#ef4444', fontSize: 10 }} />
                        )}
                      </AreaChart>
                    </ResponsiveContainer>
                  </div>
                  
                  {/* CO2 Injection Profile */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">
                      CO₂ Balance: Injected, Produced, Stored
                    </h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <LineChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1000).toFixed(0)}k`} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v, name) => [`${Math.round(v).toLocaleString()} t/mo`, name]} />
                        <Line type="monotone" dataKey="co2Injection" stroke="#dc2626" strokeWidth={2} dot={false} name="CO₂ Injected" />
                        <Line type="monotone" dataKey="co2Produced" stroke="#f59e0b" strokeWidth={2} dot={false} name="CO₂ Produced" />
                        <Line type="monotone" dataKey="co2Stored" stroke="#16a34a" strokeWidth={2} dot={false} name="CO₂ Stored (Net)" />
                        {calcs.monthlyData?.length > 0 && (
                          <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                        )}
                        <Legend wrapperStyle={{ fontSize: '10px' }} />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  
                  {/* Water Balance Chart - WAG only */}
                  {eorMethod === 'wag' && (
                    <div className="bg-white border border-gray-200 rounded p-3">
                      <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">
                        Water Balance: Injected vs Produced (WAG)
                      </h3>
                      <ResponsiveContainer width="100%" height={220}>
                        <LineChart data={calcs.monthlyData || []}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                          <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                          <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1000).toFixed(0)}k`} />
                          <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                            formatter={(v, name) => [`${Math.round(v).toLocaleString()} bbl/mo`, name]} />
                          <Line type="monotone" dataKey="waterInjection" stroke="#3b82f6" strokeWidth={2} dot={false} name="Water Injected" />
                          <Line type="monotone" dataKey="waterProduced" stroke="#06b6d4" strokeWidth={2} dot={false} name="Water Produced" />
                          {calcs.monthlyData?.length > 0 && (
                            <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                          )}
                          <Legend wrapperStyle={{ fontSize: '10px' }} />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>
                  )}
                  
                  {/* CO2/Oil Ratio Profile */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CO₂/Oil Ratio Over Time</h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <LineChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => v != null ? `${v.toFixed(1)}` : '0'} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v) => [v != null ? `${v.toFixed(2)} t/bbl` : '0', 'CO₂/Oil']} />
                        <Line type="monotone" dataKey="effectiveRatio" stroke="#8b5cf6" strokeWidth={2} dot={false} />
                        <ReferenceLine y={co2OilRatio} stroke="#f59e0b" strokeDasharray="5 5" label={{ value: 'Target', fill: '#f59e0b', fontSize: 9 }} />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  
                  {/* CO2 Storage Profile (Monthly) */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CO₂ Storage (Monthly)</h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <AreaChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1000).toFixed(0)}k`} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v) => [`${v.toLocaleString()} t/mo`, 'CO₂ Stored']} />
                        <Area type="monotone" dataKey="co2Stored" fill="#7c3aed33" stroke="#7c3aed" strokeWidth={2} />
                        {calcs.monthlyData?.length > 0 && (
                          <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                        )}
                      </AreaChart>
                    </ResponsiveContainer>
                  </div>
                  
                  {/* CO2 Storage Profile (Cumulative) */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">CO₂ Storage (Cumulative)</h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <AreaChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `${(v / 1e6).toFixed(2)}Mt`} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                          formatter={(v) => [`${(v / 1e6).toFixed(3)} Mt`, 'Cumulative CO₂']} />
                        <Area type="monotone" dataKey="co2StoredCumulative" fill="#7c3aed33" stroke="#7c3aed" strokeWidth={2} />
                        {calcs.monthlyData?.length > 0 && (
                          <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                        )}
                      </AreaChart>
                    </ResponsiveContainer>
                  </div>
                </div>
                
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {/* Wells & Patterns Timeline */}
                  <div className="bg-white border border-gray-200 rounded p-3">
                    <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Wells & Patterns Development</h3>
                    <ResponsiveContainer width="100%" height={220}>
                      <LineChart data={calcs.monthlyData || []}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                        <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                        <YAxis yAxisId="wells" tick={{ fill: "#6b7280", fontSize: 10 }} />
                        <YAxis yAxisId="patterns" orientation="right" tick={{ fill: "#f59e0b", fontSize: 10 }} />
                        <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }} />
                        <Line yAxisId="wells" type="stepAfter" dataKey="cumulativeInjectors" name="Injectors" stroke="#dc2626" strokeWidth={2} dot={false} />
                        <Line yAxisId="wells" type="stepAfter" dataKey="cumulativeProducers" name="Producers" stroke="#16a34a" strokeWidth={2} dot={false} />
                        <Line yAxisId="patterns" type="stepAfter" dataKey="totalPatterns" name="Total Patterns" stroke="#8b5cf6" strokeWidth={2} dot={false} />
                        <Line yAxisId="patterns" type="stepAfter" dataKey="activePatterns" name="Active Patterns" stroke="#f59e0b" strokeWidth={2} dot={false} strokeDasharray="5 5" />
                        {calcs.monthlyData?.length > 0 && (
                          <ReferenceLine yAxisId="wells" x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                        )}
                        <Legend wrapperStyle={{ fontSize: '10px' }} />
                      </LineChart>
                    </ResponsiveContainer>
                  </div>
                  
                  {/* EOR Method Specific Chart */}
                  {eorMethod === 'huffpuff' ? (
                    <div className="bg-white border border-gray-200 rounded p-3">
                      <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Huff & Puff Phase Distribution</h3>
                      <ResponsiveContainer width="100%" height={220}>
                        <AreaChart data={calcs.monthlyData || []}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                          <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                          <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} />
                          <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }} />
                          <Area type="stepAfter" dataKey="patternsInHuff" name="Injecting (Huff)" stackId="1" fill="#dc2626" stroke="#dc2626" />
                          <Area type="stepAfter" dataKey="patternsInSoak" name="Soaking" stackId="1" fill="#f59e0b" stroke="#f59e0b" />
                          <Area type="stepAfter" dataKey="patternsInPuff" name="Producing (Puff)" stackId="1" fill="#16a34a" stroke="#16a34a" />
                          {calcs.monthlyData?.length > 0 && (
                            <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                          )}
                          <Legend wrapperStyle={{ fontSize: '10px' }} />
                        </AreaChart>
                      </ResponsiveContainer>
                    </div>
                  ) : (
                    <div className="bg-white border border-gray-200 rounded p-3">
                      <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">45Q Credit Revenue</h3>
                      <ResponsiveContainer width="100%" height={220}>
                        <AreaChart data={calcs.monthlyData || []}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                          <XAxis dataKey="label" tick={{ fill: "#6b7280", fontSize: 10 }} interval={Math.floor((calcs.monthlyData?.length || 1) / 6)} />
                          <YAxis tick={{ fill: "#6b7280", fontSize: 10 }} tickFormatter={v => `$${v.toFixed(1)}MM`} />
                          <Tooltip contentStyle={{ backgroundColor: "#fff", border: "1px solid #e5e7eb", borderRadius: '6px', fontSize: '11px' }}
                            formatter={(v) => [`$${v.toFixed(3)}MM`, '45Q Revenue']} />
                          <Area type="monotone" dataKey="creditRevenue" fill="#10b98133" stroke="#10b981" strokeWidth={2} />
                          {calcs.monthlyData?.length > 0 && (
                            <>
                              <ReferenceLine x={`Y${creditYears}`} stroke="#f59e0b" strokeDasharray="5 5" label={{ value: '45Q Ends', fill: '#f59e0b', fontSize: 9 }} />
                              <ReferenceLine x={`Y${Math.ceil(animationMonth / 12)}`} stroke="#ef4444" strokeDasharray="3 3" />
                            </>
                          )}
                        </AreaChart>
                      </ResponsiveContainer>
                    </div>
                  )}
                </div>
                
                {/* Development Events Table */}
                <div className="bg-white border border-gray-200 rounded p-3">
                  <h3 className="text-xs font-semibold text-gray-700 uppercase mb-2">Development Events Timeline</h3>
                  <div className="overflow-x-auto">
                    <table className="w-full text-xs">
                      <thead>
                        <tr className="bg-gray-50">
                          <th className="px-2 py-1 text-left">Month</th>
                          <th className="px-2 py-1 text-left">Year</th>
                          <th className="px-2 py-1 text-left">Type</th>
                          <th className="px-2 py-1 text-left">Description</th>
                          <th className="px-2 py-1 text-right">Cost</th>
                        </tr>
                      </thead>
                      <tbody>
                        {(calcs.developmentEvents || []).map((event, idx) => (
                          <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                            <td className="px-2 py-1">{event.month}</td>
                            <td className="px-2 py-1">{(event.month / 12).toFixed(1)}</td>
                            <td className="px-2 py-1">
                              <span className={`px-1.5 py-0.5 rounded text-xs ${
                                event.type === 'wells' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'
                              }`}>
                                {event.type === 'wells' ? '🛢️ Wells' : '🔧 Pipeline'}
                              </span>
                            </td>
                            <td className="px-2 py-1">{event.description}</td>
                            <td className="px-2 py-1 text-right font-medium">${(event.cost / 1e6).toFixed(2)}MM</td>
                          </tr>
                        ))}
                        {(!calcs.developmentEvents || calcs.developmentEvents.length === 0) && (
                          <tr><td colSpan={5} className="px-2 py-4 text-center text-gray-500">No development events (existing infrastructure)</td></tr>
                        )}
                      </tbody>
                    </table>
                  </div>
                </div>
              </>
            )}
          </div>
        )}

        {activeTab === 'assumptions' && (
          <div className="max-w-4xl space-y-3">
            <Section title="Model Structure" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p>This model calculates economics for CO₂ Enhanced Oil Recovery (EOR) projects. Two calculation modes are available:</p>
                <p><strong className="text-gray-700">Simple Mode:</strong> Steady-state injection with production derived from CO₂ injection volume and utilization ratio. Good for quick screening.</p>
                <p><strong className="text-gray-700">Pattern-Based Mode:</strong> Simulates individual well patterns through their lifecycle (fill → ramp → peak → decline → blowdown → abandonment). Dynamically adds patterns as CO₂ capacity becomes available from recycling. Field size determines maximum patterns, facility size constrains development rate.</p>
              </div>
            </Section>

            <Section title="Pattern-Based Model" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p><strong className="text-gray-700">Pattern Types:</strong> 5-Spot (1 injector center, 4 shared producers at corners), Inverted 5-Spot (1 producer center, 4 injectors at corners), Single-Well Huff & Puff (cyclic injection/soak/production).</p>
                <p><strong className="text-gray-700">EOR Methods:</strong> Continuous (constant CO₂ injection), WAG (alternating water/CO₂ slugs, 5-25% better sweep), Huff & Puff (cyclic injection for tight reservoirs).</p>
                <p><strong className="text-gray-700">Pattern Lifecycle:</strong> Fill (0.5-2 yr, CO₂ bank development) → Ramp (1-3 yr, production increase) → Peak (2-5 yr, maximum rate) → Decline (8-15 yr, 8-15%/yr decline) → Blowdown (injection stops at 15-25% of peak) → Abandonment (&lt;2% of peak).</p>
                <p><strong className="text-gray-700">Development Logic:</strong> As patterns mature, recycle increases (0→30→60→80%), freeing fresh CO₂ capacity for new patterns. Development naturally accelerates over time. Total injection = Fresh + Recycled, can exceed facility fresh capacity.</p>
                <p><strong className="text-gray-700">5-Spot Sharing:</strong> Producers on corners shared between adjacent patterns. 1 pattern = 4 producers, 4 patterns (2×2) = 9 producers.</p>
              </div>
            </Section>

            <Section title="Scenario Types" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p><strong className="text-gray-700">Existing Flood:</strong> Assumes existing infrastructure — no producing well costs, no recycle CAPEX. CO₂ is already being injected.</p>
                <p><strong className="text-gray-700">New Flood:</strong> Assumes retrofit of a conventional field — includes injection well costs ($1MM/well), recycle plant CAPEX (~$76MM), and pipeline CAPEX.</p>
                <p><strong className="text-gray-700">EOR Only:</strong> Operator buys or receives CO₂ at the field gate. Capture and transport costs are excluded — they are embedded in the CO₂ price paid/received. Relevant for operators who purchase CO₂ from a third party.</p>
                <p><strong className="text-gray-700">Full Chain:</strong> Operator owns the entire CCUS value chain from emitter retrofit through capture, transport, and injection. Capture CAPEX/OPEX and transport CAPEX/OPEX are included. The CO₂ price input then represents the raw feedstock arrangement, and the 45Q credits accrue to the integrated operator.</p>
              </div>
            </Section>

            <Section title="CO₂ Recycle Model" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p>In CO₂ EOR, injected CO₂ is initially retained in the reservoir — early years see high storage and low recycling. Over time, CO₂ breaks through to production wells and an increasing fraction is produced, separated, and re-injected. This is a closed-loop system where the need for purchased (fresh) CO₂ declines as recycled volumes grow.</p>
                <p><strong className="text-gray-700">Fixed Mode:</strong> Uses a constant recycle rate throughout the project life. Useful for screening or when field-specific data is available.</p>
                <p><strong className="text-gray-700">Ramping Mode:</strong> S-curve ramp calibrated to field data. Denbury (2018) reports ~20% recycled by year 15, ~50% by year 20, ~70% by year 25, ~80% by year 30. For typical 10–20 year project horizons, the model uses an accelerated S-curve: 0% → 10% (yr 1–3) → 30% (yr 6) → 55% (yr 10) → 70% (yr 15) → 80%+ plateau.</p>
                <p>Net CO₂ stored = Total injected − Recycled. 45Q credits apply only to net stored tonnes. As recycle increases, net storage per period decreases.</p>
              </div>
            </Section>

            <Section title="CO₂/Oil Utilization Ratio Model" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p>Oil production is derived from CO₂ injection volume divided by the effective CO₂/oil utilization ratio (tonnes CO₂ per barrel of incremental oil). This ratio varies over the life of the flood:</p>
                <p><strong className="text-gray-700">New Flood Ramp:</strong> When CO₂ is first injected into a reservoir, it must fill pore space and build a miscible bank before oil is mobilized. The effective ratio starts very high (50× base — nearly all CO₂ is stored, minimal oil produced), then rapidly improves as the flood develops. By year 3-5 the ratio approaches design efficiency. After reaching steady-state (~year 5-7), slight degradation occurs (~2%/yr) as CO₂ channels through swept zones. This matches field observations at Bell Creek, SACROC, and the EERC 31-project study showing utilization rates highest early in floods.</p>
                <p><strong className="text-gray-700">Existing Flood:</strong> CO₂ is already in the reservoir, so the ratio starts near design efficiency (1.1× base) and reaches steady-state within the first year. After the midpoint of project life, slight degradation (~1.5%/yr) reflects diminishing sweep efficiency in late-life operations.</p>
                <p><strong className="text-gray-700">Literature Range:</strong> EERC (31 US projects): 4.8-10.5 MCF/bbl net (0.25-0.55 t/bbl). DOE Chapter 8: 10-15 MCF/bbl (0.5-0.75 t/bbl). OGJ Permian: 4-5 MCF/bbl purchased. Bell Creek: ~1 t/bbl gross early flood. Kuuskraa (2013): 30 Bt for 100 Bbbl = 0.30 t/bbl lifetime average. PMC global LCA: net 7.96 MCF/bbl ≈ 0.41 t/bbl.</p>
              </div>
            </Section>

            <Section title="CAPEX Scaling (Full Value Chain)" >
              <div className="text-xs text-gray-600 space-y-2 leading-relaxed">
                <p><strong className="text-gray-700">Capture CAPEX — Source Purity Model:</strong> Capture cost is primarily driven by CO₂ concentration in the source stream. NETL (2022) found average capture cost of $17.5/t for high-purity sources (&gt;95% CO₂) vs $62/t for low-purity (&lt;50%). The model uses CAPEX per tonne-annual-capacity ($/tpa) from published data: Ethanol ~$60/tpa (near-pure, compression only), Natural Gas Processing ~$75/tpa, Ammonia/H₂ ~$90/tpa, Refinery/SMR ~$280/tpa (amine scrubbing), Cement ~$350/tpa, Coal Power ~$400/tpa (Shand NOAK $265, BD FOAK $800), NGCC ~$500/tpa. Incorrys (2025) global average: $270-320/tpa; EOR projects: ~$270/tpa. A 0.7 capacity scaling exponent (standard chemical engineering) adjusts unit cost for scale: larger facilities have lower $/tpa.</p>
                <p><strong className="text-gray-700">Transport CAPEX — Pipeline Inch-Mile Model:</strong> Uses the standard pipeline cost formula: CAPEX = D(in) × L(mi) × $/inch-mile × 1.15 overhead. Pipeline diameter is estimated from throughput as D = 5.35 × Q^0.45 (Mt/yr), fitted to Kinder Morgan/Denbury data. Literature pipeline cost range: Trimeric/OSTI $51k-$119k/inch-mile; EPA Platform v6 $228k/inch-mile. Default $85k/inch-mile is mid-range for 2024$ onshore US. The 1.15 multiplier covers compression stations, ROW, and miscellaneous. For the default case (1.875 Mt/yr, 50 mi), this yields a ~7" pipe at ~$34MM — substantially higher than the original Enverus model's $6.3MM.</p>
                <p><strong className="text-gray-700">Recycle CAPEX:</strong> Unchanged from OSTI Report #1557133. For facilities under 579k t/yr: $1,200/MCFD × 1.5x contingency. For larger: base $36MM + $750k per MMCFD above 30 MMCFD × 1.5x. CO₂ volume conversion: 19 MCF per tonne at standard conditions.</p>
                <p><strong className="text-gray-700">Capture OPEX:</strong> Auto-set from source type. High-purity sources: $6-10/t (mostly compression energy). Low-purity: $35-65/t (amine regeneration, parasitic power loss). Original Enverus model: $14.80/t.</p>
                <p><strong className="text-gray-700">Recycle OPEX:</strong> WTI × 0.01 × 19 (model formula). Energy-intensive gas compression and dehydration, cost scales with energy prices. At $65 WTI = $12.35/t.</p>
                <p><strong className="text-gray-700">Storage OPEX:</strong> (34,000 + 4×5,000) × 1.5 / injection_per_well_yr. Well monitoring, compliance, and subsurface management. At 30,000 t/well/yr = $2.70/t.</p>
              </div>
            </Section>

            <Section title="Real-World CCS Benchmarks" >
              <div className="overflow-x-auto">
                <table className="w-full border-collapse text-xs">
                  <thead>
                    <tr className="bg-gray-100">
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Project</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Total CAPEX</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Capacity</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">$/tpa</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Source</th>
                    </tr>
                  </thead>
                  <tbody className="text-gray-700">
                    <tr><td className="border border-gray-200 px-2 py-1">Boundary Dam (FOAK)</td><td className="border border-gray-200 px-2 py-1">~C$1B</td><td className="border border-gray-200 px-2 py-1">1.0 Mt/yr</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$800</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Coal, 12% CO₂</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Petra Nova (FOAK)</td><td className="border border-gray-200 px-2 py-1">~$1B</td><td className="border border-gray-200 px-2 py-1">1.4 Mt/yr</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$714</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Coal, 12% CO₂</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Quest (all-in)</td><td className="border border-gray-200 px-2 py-1">$1.35B</td><td className="border border-gray-200 px-2 py-1">1.08 Mt/yr</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$750</td><td className="border border-gray-200 px-2 py-1 text-gray-500">H₂/upgrader. Incl T&S</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Shand Study (NOAK)</td><td className="border border-gray-200 px-2 py-1">Est. 67% lower/t</td><td className="border border-gray-200 px-2 py-1">~1 Mt/yr</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$265</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Coal, 2nd-gen design</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Incorrys Avg (post-2020)</td><td className="border border-gray-200 px-2 py-1">Various</td><td className="border border-gray-200 px-2 py-1">Various</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$290</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Global CCS projects</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Incorrys EOR projects</td><td className="border border-gray-200 px-2 py-1">Various</td><td className="border border-gray-200 px-2 py-1">Various</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$270</td><td className="border border-gray-200 px-2 py-1 text-gray-500">EOR-specific average</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">BKV Corp (small)</td><td className="border border-gray-200 px-2 py-1">$36MM</td><td className="border border-gray-200 px-2 py-1">0.183 Mt/yr</td><td className="border border-gray-200 px-2 py-1 font-semibold">~$197</td><td className="border border-gray-200 px-2 py-1 text-gray-500">All-in integrated, high-purity</td></tr>
                  </tbody>
                </table>
              </div>
            </Section>

            <Section title="Key Assumptions" >
              <div className="overflow-x-auto">
                <table className="w-full border-collapse text-xs">
                  <thead>
                    <tr className="bg-gray-100">
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Parameter</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Default</th>
                      <th className="border border-gray-300 px-2 py-1 text-left text-gray-400">Notes</th>
                    </tr>
                  </thead>
                  <tbody className="text-gray-700">
                    <tr><td className="border border-gray-200 px-2 py-1">Oil Production</td><td className="border border-gray-200 px-2 py-1">Derived from CO₂ injection ÷ ratio × profile</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Oil = (CO₂ injected / effective ratio) × production multiplier. Multiplier ramps up (10%→100%) over ramp-up period, holds at peak, then declines exponentially.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">CO₂ Injection</td><td className="border border-gray-200 px-2 py-1">30,000 t/well/yr</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Based on Denver Unit MRV data (~1,286 wells)</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Injection Wells</td><td className="border border-gray-200 px-2 py-1">62.5</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Producer:Injector ~1.6:1</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">CO₂/Oil Ratio</td><td className="border border-gray-200 px-2 py-1">0.35 t/bbl (6.7 MCF/bbl)</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Steady-state. EERC 31 projects: 4.8-10.5 MCF/bbl. DOE: 0.3-0.5 t/bbl. Ramps for new floods.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">45Q Credit</td><td className="border border-gray-200 px-2 py-1">$85/t (EOR)</td><td className="border border-gray-200 px-2 py-1 text-gray-500">IRA 2022: $85/t saline. 12-yr window. Optional inflation escalation.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Capture CAPEX</td><td className="border border-gray-200 px-2 py-1">$60-500/tpa</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Full chain. Varies by CO₂ source purity (NETL 2022, IEA, Incorrys 2025)</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Transport CAPEX</td><td className="border border-gray-200 px-2 py-1">$85k/in-mi</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Full chain. Pipe diameter from throughput, mid-range of $51-228k literature (Trimeric/OSTI/EPA)</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Recycle CAPEX</td><td className="border border-gray-200 px-2 py-1">$75.9MM</td><td className="border border-gray-200 px-2 py-1 text-gray-500">New floods only. OSTI gas processing formula, varies with injection rate.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Capture OPEX</td><td className="border border-gray-200 px-2 py-1">$6-65/t</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Full chain. Auto-set from source type. High-purity: $6-10/t; low-purity: $35-65/t</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Recycle OPEX</td><td className="border border-gray-200 px-2 py-1">$12.35/t</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Formula: WTI×0.01×19. Energy cost scales with oil price.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Storage OPEX</td><td className="border border-gray-200 px-2 py-1">$2.70/t</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Formula: (34k+20k)×1.5÷(t/well/yr). Well-count dependent.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Pipeline Distance</td><td className="border border-gray-200 px-2 py-1">50 mi</td><td className="border border-gray-200 px-2 py-1 text-gray-500">For inch-mile transport CAPEX. Adjustable in Full Chain mode.</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">Severance Tax</td><td className="border border-gray-200 px-2 py-1">8%</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Applied to gross oil revenue</td></tr>
                    <tr><td className="border border-gray-200 px-2 py-1">NPV Method</td><td className="border border-gray-200 px-2 py-1">Mid-period</td><td className="border border-gray-200 px-2 py-1 text-gray-500">Monthly DCF with mid-period discounting</td></tr>
                  </tbody>
                </table>
              </div>
            </Section>

            <Section title="Data Sources" >
              <div className="text-xs text-gray-600 space-y-1">
                <p>• EERC/UND (Peck et al., 2014) — CO₂ utilization rates at 31 EOR projects: 4.8-10.5 MCF/bbl</p>
                <p>• Kuuskraa et al. (2013) DOE — 100 Bbbl from 30 Bt CO₂: 0.30 t/bbl lifetime average</p>
                <p>• CATF/IEA Life Cycle Analysis — 0.30 t CO₂ stored per barrel of EOR oil</p>
                <p>• PMC (2022) Global TEA-LCA — Gross 15.77 MCF/bbl, net 7.96 MCF/bbl</p>
                <p>• OGJ Permian Basin — 4-5 MCF purchased CO₂ per incremental barrel</p>
                <p>• NETL "Cost of Capturing CO₂ from Industrial Sources" (Hughes & Zoelle, 2022) — Capture cost by source purity</p>
                <p>• Incorrys "CCS Capital Cost" (2025) — Global CAPEX benchmarks: $270-320/tpa average</p>
                <p>• IEA "Is Carbon Capture Too Expensive?" — Capture $15-120/t by source; Transport $2-14/t US onshore</p>
                <p>• IEA/CCS Knowledge Centre — Shand NOAK study: 67% cost reduction vs Boundary Dam FOAK</p>
                <p>• Trimeric/OSTI — Pipeline costs $51k-$119k/inch-mile (Illinois Basin study, 2017$)</p>
                <p>• EPA Platform v6 — Pipeline cost at $228k/inch-mile; CO₂ storage cost curves by state</p>
                <p>• Boundary Dam / Petra Nova / Quest — Real-world FOAK CAPEX benchmarks ($714-$800/tpa)</p>
                <p>• BKV Corp Investor Presentation 3Q2024 — Small-scale capture CAPEX ($197/tpa all-in)</p>
                <p>• OSTI Report #1557133 — CO₂ recycle plant CAPEX/OPEX scaling formulas</p>
                <p>• Denbury Resources (2018) — Long-term CO₂ recycle ramp data</p>
                <p>• Oxy Wasson San Andres / Denver Unit MRV (EPA, 2023) — Production & injection field data</p>
                <p>• IRS 45Q / IRA 2022 — Carbon sequestration tax credit rates, inflation indexing</p>
                <p>• Enverus Intelligence Research — Original model structure and scenario framework</p>
              </div>
            </Section>

            <div className="bg-yellow-50 border border-yellow-200 rounded p-3">
              <h3 className="font-semibold text-xs text-yellow-800 mb-1">Disclaimer</h3>
              <p className="text-xs text-yellow-700">
                This model provides screening-level estimates based on published field data. Actual costs and production vary significantly by reservoir, location, and operator. Monte Carlo results show probabilistic ranges, not guarantees. Professional analysis required for investment decisions. Based on Enverus EOR model framework.
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="bg-gray-100 border-t border-gray-200 px-4 py-1.5 text-xs text-gray-500 text-center flex-shrink-0">
        CO₂ EOR Economic Model v1.2 • {scenarioType} Flood • {fullValueChain ? `Full Chain (${(CO2_SOURCES[co2SourceType] || {label:'?'}).label})` : 'EOR Only'} • WTI ${wtiPrice} • CO₂/Oil {co2OilRatio} t/bbl
      </div>
    </div>
  );
};



    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EORModelApp />);
  </script>
</body>
</html>
